#!/usr/bin/env python

"""Figures for FastSpecFit paper 1.

# build the data
time $HOME/code/desihub/fastspecfit-projects/fastpaper1/fastpaper1-figures --match-lss
time $HOME/code/desihub/fastspecfit-projects/fastpaper1/fastpaper1-figures --write-example-spectra

# build the figures
time $HOME/code/desihub/fastspecfit-projects/fastpaper1/fastpaper1-figures --mstar

"""
import os, pdb
import numpy as np
import fitsio
from astropy.table import Table, vstack
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

from desitarget import geomask
from desiutil.log import get_logger
log = get_logger()

from fastspecfit.util import C_LIGHT

fujidir = '/pscratch/sd/i/ioannis/fastspecfit/vac/data1/fuji/catalogs' # to be updated

paperdir = os.path.join(os.getenv('DESI_ROOT'), 'users', 'ioannis', 'fastspecfit', 'fastpaper1')
figdir = os.path.join(paperdir, 'figures')
datadir = os.path.join(paperdir, 'data')

@ticker.FuncFormatter
def major_formatter(x, pos):
    if x >= 0:
        return '{:.0f}'.format(10**x)
    else:
        return '{:.1f}'.format(10**x)

def plot_style(font_scale=1.2, paper=False, talk=True, style='ticks'):

    import seaborn as sns
    rc = {'font.family': 'serif'}#, 'text.usetex': True}
    #rc = {'font.family': 'serif', 'text.usetex': True,
    #       'text.latex.preamble': r'\boldmath'})
    palette, context = 'Set2', 'talk'
    
    if paper:
        context = 'paper'
        palette = 'deep'
        rc.update({'text.usetex': False})
    
    if talk:
        context = 'talk'
        palette = 'deep'
        #rc.update({'text.usetex': True})

    sns.set(context=context, style=style, font_scale=font_scale, rc=rc)
    sns.set_palette(palette, 12)

    colors = sns.color_palette()
    #sns.reset_orig()

    return sns, colors

def write_example_spectra(overwrite=False):
    """Simple script to write out small coadded spectra and redrock files needed for
    the example spectra/modeling figures in the paper.

    """
    from fastspecfit.io import one_desi_spectrum

    outdir = os.path.join(datadir, 'example-spectra')

    # 1 - example-emlines figure

    # 1a - nice star-forming galaxy
    one_desi_spectrum(survey='sv1', program='dark', healpix=8140, targetid=39633560344201268,
                      specprod='fuji', outdir=outdir, overwrite=overwrite)

    # 1b - broad-line AGN example (z=0.287)
    one_desi_spectrum(survey='sv3', program='bright', healpix=26065, targetid=39627878949720219,
                      specprod='fuji', outdir=outdir, overwrite=overwrite)

    # 1c - gorgeous QSO (z=0.191)
    one_desi_spectrum(survey='sv3', program='dark', healpix=16040, targetid=39633451392961492,
                       specprod='fuji', outdir=outdir, overwrite=overwrite)

    # 1d - nice QSO with strong MgII and Hbeta (z=0.693)
    one_desi_spectrum(survey='sv1', program='dark', healpix=7022, targetid=39633331528141827,
                      specprod='fuji', outdir=outdir, overwrite=overwrite)

    # 2 - example-continuum figure

    # 2a - narrow-line AGN on a somewhat evolved continuum; nice [OIII] 5007 (z=0.202)
    one_desi_spectrum(survey='sv1', program='bright', healpix=17675, targetid=39627628474278005,
                      specprod='fuji', outdir=outdir, overwrite=overwrite)

    # 2b - early-type spectrum with some weak (AGN) emission (z=0.132)
    one_desi_spectrum(survey='sv3', program='bright', healpix=9813, targetid=39633109787873428,
                      specprod='fuji', outdir=outdir, overwrite=overwrite)

def read_clustering(targetclass=['BGS_ANY', 'LRG', 'ELG', 'QSO']):
    """Read the matched clustering files (from match_lss).

    """
    from fastspecfit.io import read_fastspecfit

    data = {}
    for targtype in np.atleast_1d(targetclass):
        fastfile = os.path.join(datadir, 'clustering', f'fastspec-clustering-{targtype}.fits')
        if not os.path.isfile(fastfile):
            log.info(f'{fastfile} not found.')
        else:
            fast, meta, _, _ = read_fastspecfit(fastfile)
            lssfile = os.path.join(datadir, 'clustering', f'lss-clustering-{targtype}.fits')
            lss = Table(fitsio.read(lssfile))
            log.info(f'Read {len(lss):,d} objects from {lssfile}')
            data[targtype] = {'fast': fast, 'meta': meta, 'lss': lss}
            
    return data     


def match_lss(overwrite=False):
    """Match to the LSS catalogs (full and clustering)."""

    from fastspecfit.io import read_fastspecfit
    from fastspecfit.io import write_fastspecfit
    #from desispec.validredshifts import actually_validate
    #actually_validate(cat, fiberstatus_cut=True, ignore_emline=True)
    #https://github.com/desihub/LSS/blob/main/py/LSS/main/cattools.py#L2968

    # read the clustering catalogs
    lssdir = '/global/cfs/cdirs/desi/vac/edr/lss/v2.0/LSScats'
    for targtype in ['BGS_ANY', 'LRG', 'ELG', 'QSO']:

        fastfile = os.path.join(datadir, 'clustering', f'fastspec-clustering-{targtype}.fits')
        lssfile = os.path.join(datadir, 'clustering', f'lss-clustering-{targtype}.fits')
        #lssfullfile = os.path.join(datadir, 'full', f'lss-full-{targtype}.fits')

        if os.path.isfile(fastfile) and os.path.isfile(lssfile) and not overwrite:
            log.info(f'fastspecfit file {fastfile} exists')
            log.info(f'LSS clustering file {lssfile} exists')
        else:
            lssNfile = os.path.join(lssdir, 'clustering', f'{targtype}_N_clustering.dat.fits')
            lssSfile = os.path.join(lssdir, 'clustering', f'{targtype}_S_clustering.dat.fits')
            lssN = fitsio.read(lssNfile)
            lssS = fitsio.read(lssSfile)
            lss = Table(np.concatenate((lssN, lssS)))
            log.info(f'Read {len(lssN):,d} objects from {lssNfile}')
            log.info(f'Read {len(lssS):,d} objects from {lssSfile}')
            log.info(f'  Total number of {targtype}: {len(lss):,d}')
            del lssN, lssS
    
            if targtype == 'BGS_ANY':
                sv3file = fujidir+'/fastspec-fuji-sv3-bright.fits'
                fast, meta, _, _ = read_fastspecfit(sv3file)
            else:
                sv3file = fujidir+'/fastspec-fuji-sv3-dark.fits'
                fast, meta, _, _ = read_fastspecfit(sv3file)
    
            indx_fast, indx_lss = geomask.match(fast['TARGETID'], lss['TARGETID'])
            fast = fast[indx_fast]
            meta = meta[indx_fast]
            lss = lss[indx_lss]
            assert(np.all(meta['TARGETID'] == lss['TARGETID']))
    
            write_fastspecfit(fast, meta, outfile=fastfile)
    
            lss.write(lssfile, overwrite=True)
            log.info(f'Wrote {len(lss):,d} objects to {lssfile}')


def compare_zouhu(png=None):
    """Compare with the Hu Zou VAC."""

    from fastspecfit.io import read_fastspecfit

    zouhufile = '/global/cfs/cdirs/desi/users/zouhu/vac/edr/edr_galaxy_stellarmass_lineinfo_v1.0.fits'
    zouhu = Table(fitsio.read(zouhufile))
    _, uindx = np.unique(zouhu['TARGETID'], return_index=True)
    zouhu = zouhu[uindx]

    if False:
        darkfile = fujidir+'/fastspec-fuji-sv3-dark.fits'
        brightfile = fujidir+'/fastspec-fuji-sv3-bright.fits'
        fastbright, metabright, _, _ = read_fastspecfit(brightfile)
        fastdark, metadark, _, _ = read_fastspecfit(darkfile)
        fast = vstack((fastbright, fastdark))
        meta = vstack((metabright, metadark))
        del fastbright, metabright, fastdark, metadark
    else:
        fastfile = fujidir+'/fastspec-fuji.fits'
        fast, meta, _, _ = read_fastspecfit(fastfile)

    _, uindx = np.unique(fast['TARGETID'], return_index=True)
    fast = fast[uindx]
    meta = meta[uindx]

    indx_fast, indx_zouhu = geomask.match(fast['TARGETID'], zouhu['TARGETID'])
    fast = fast[indx_fast]
    meta = meta[indx_fast]
    zouhu = zouhu[indx_zouhu]
    assert(np.all(meta['TARGETID'] == zouhu['TARGETID']))
    
    I = ((fast['HALPHA_FLUX'] > 0) * (fast['HALPHA_FLUX_IVAR'] > 0) *
         (fast['HALPHA_BOXFLUX'] > 0) * (fast['HALPHA_BOXFLUX_IVAR'] > 0) *
         (fast['HALPHA_BROAD_FLUX_IVAR'] == 0) *
         (zouhu['HALPHA_FLUX'] > 0) * (zouhu['HALPHA_FLUXERR'] > 0) *
         np.isfinite(zouhu['HALPHA_FLUX']) * np.isfinite(zouhu['HALPHA_FLUXERR']) )

    B = (fast['HALPHA_FLUX'][I] * np.sqrt(fast['HALPHA_FLUX_IVAR'][I]) > 1.5) * ((np.log10(fast['HALPHA_FLUX'][I])-np.log10(zouhu['HALPHA_FLUX'][I])) > 0.25)
    check = fast[I][B]['SURVEY', 'PROGRAM', 'HEALPIX', 'TARGETID', 'HALPHA_FLUX', 'HALPHA_BOXFLUX', 'HALPHA_SIGMA']
    check['HU_HALPHA_FLUX'] = zouhu['HALPHA_FLUX'][I][B]
    check['HU_HALPHA_SIGMA'] = zouhu['HALPHA_SIGMA'][I][B]

    #ax.scatter(fast['HALPHA_SIGMA'][I], np.log10(fast['HALPHA_FLUX'][I])-np.log10(zouhu['HALPHA_FLUX'][I]), s=1)

    #fig, ax = plt.subplots()
    #ax.scatter(zouhu['HALPHA_SIGMA'][I], np.log10(fast['HALPHA_FLUX'][I])-np.log10(zouhu['HALPHA_FLUX'][I]), s=1)
    #ax.set_ylim(-1, 1)
    #fig.tight_layout()
    #fig.savefig('desi-users/ioannis/tmp/junk2.png')
    
    fig, ((ax1, ax2), (ax3, ax4), (ax5, ax6)) = plt.subplots(3, 2, figsize=(10, 12))

    ax1.scatter(np.log10(fast['HALPHA_FLUX'][I]), np.log10(zouhu['HALPHA_FLUX'][I]), s=1)
    #ax1.scatter(np.log10(fast['HALPHA_FLUX'][I][B]), np.log10(zouhu['HALPHA_FLUX'][I][B]), s=1, color='orange')

    ax2.scatter(np.log10(fast['HALPHA_BOXFLUX'][I]), np.log10(zouhu['HALPHA_FLUX'][I]), s=1)
    #B = ((np.log10(fast['HALPHA_BOXFLUX'][I]) > 3) *
    #     (np.log10(zouhu['HALPHA_FLUX'][I]) > 2) * (np.log10(zouhu['HALPHA_FLUX'][I]) < 3))
    #ax2.scatter(np.log10(fast['HALPHA_BOXFLUX'][I][B]), np.log10(zouhu['HALPHA_FLUX'][I][B]), s=1, color='orange')

    ax3.scatter(np.log10(1/np.sqrt(fast['HALPHA_FLUX_IVAR'][I])), np.log10(zouhu['HALPHA_FLUXERR'][I]), s=1)
    ax4.scatter(np.log10(1/np.sqrt(fast['HALPHA_BOXFLUX_IVAR'][I])), np.log10(zouhu['HALPHA_FLUXERR'][I]), s=1)

    ax5.scatter(np.log10(fast['HALPHA_FLUX'][I]*np.sqrt(fast['HALPHA_FLUX_IVAR'][I])),
                np.log10(zouhu['HALPHA_FLUX'][I]/zouhu['HALPHA_FLUXERR'][I]), s=1)
    ax6.scatter(np.log10(fast['HALPHA_FLUX'][I]*np.sqrt(fast['HALPHA_BOXFLUX_IVAR'][I])),
                np.log10(zouhu['HALPHA_FLUX'][I]/zouhu['HALPHA_FLUXERR'][I]), s=1)

    ax1.set_ylabel('log Flux [Hu Zou / mpfit]')
    ax1.set_xlabel('log Flux [fastspec, Gauss]')
    ax2.set_xlabel('log Flux [fastspec, Box]')
    for xx in [ax1, ax2]:
        xx.set_xlim(-2, 5)
        xx.set_ylim(-2, 5)
        xx.plot([-2, 5], [-2, 5], color='k')

    ax3.set_ylabel('log Flux Error [Hu Zou / mpfit]')
    ax3.set_xlabel('log Flux Error [fastspec, Gauss]')
    ax4.set_xlabel('log Flux Error [fastspec, Box]')
    for xx in [ax3, ax4]:
        xx.set_xlim(-2, 2.5)
        xx.set_ylim(-2, 2.5)
        xx.plot([-2, 2.5], [-2, 2.5], color='k')

    ax5.set_ylabel('log Flux S/N [Hu Zou / mpfit]')
    ax5.set_xlabel('log Flux S/N [fastspec, Gauss]')
    ax6.set_xlabel('log Flux S/N [fastspec, Box]')
    for xx in [ax5, ax6]:
        xx.set_xlim(-1.5, 3.5)
        xx.set_ylim(-1.5, 3.5)
        xx.plot([-1.5, 3.5], [-1.5, 3.5], color='k')
        
    fig.tight_layout()
    fig.savefig('desi-users/ioannis/tmp/junk.png')

def compare_raga(overwrite=False):

    import corner as cn
    from fastspecfit.io import read_fastspecfit
    from fastspecfit.io import write_fastspecfit

    sns, colors = plot_style(talk=True, font_scale=0.8)

    # build / read the sample
    ragafile = os.path.join(datadir, 'lowmass-blcandidates.fits')
    raga = Table(fitsio.read(ragafile, ext=1, upper=True)) # from Raga
    raga = raga[(raga['SURVEY'] == 'sv1')*(raga['PROGRAM'] == 'bright')]
    print('Read {} objects from {}'.format(len(raga), ragafile))

    fastfile = os.path.join(datadir, 'fastspec-fuji-lowmass-blcandidates.fits')
    if os.path.isfile(fastfile):
        fast, meta, _, _ = read_fastspecfit(fastfile)
    else:
        fast, meta = [], []
        for survey in set(raga['SURVEY']):
            J = np.where(survey == raga['SURVEY'])[0]
            for program in set(raga['PROGRAM'][J]):
                K = np.where(program == raga['PROGRAM'][J])[0]

                survey = survey.strip()
                program = program.strip()

                fastfile1 = fujidir+f'/fastspec-fuji-{survey}-{program}.fits'
                #fastfile1 = os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'fastspecfit', 'fuji', 'catalogs', f'fastspec-fuji-{survey}-{program}.fits')
                targetids = fitsio.read(fastfile1, ext='METADATA', columns='TARGETID')
                I = np.where(np.isin(targetids, raga[J][K]['TARGETID']))[0]
                
                fast1, meta1, _, _ = read_fastspecfit(fastfile1, rows=I)
                fast.append(fast1)
                meta.append(meta1)

        fast = vstack(fast)
        meta = vstack(meta)

        I = np.hstack([np.where(meta['TARGETID'] == tid)[0] for tid in raga['TARGETID']])
        fast = fast[I]
        meta = meta[I]
        assert(np.all(meta['TARGETID'] == raga['TARGETID']))

        write_fastspecfit(fast, meta, outfile=fastfile)

    I = fast['HALPHA_BROAD_SIGMA'] > 0
    print(fast['SURVEY', 'PROGRAM', 'HEALPIX', 'TARGETID', 'HALPHA_AMP', 'HALPHA_BROAD_AMP', 'HALPHA_SIGMA', 'HALPHA_BROAD_SIGMA'][I])
    print(raga['SURVEY', 'PROGRAM', 'HEALPIX', 'TARGETID', 'HA_N_AMPLITUDE', 'HA_B_AMPLITUDE', 'HA_N_SIGMA_FITS', 'HA_B_SIGMA_FITS'][I])

def vac_diagnostics(specprod='fuji'):
    """Wide range of VAC diagnostics.

    """
    from matplotlib.backends.backend_pdf import PdfPages    
    
    from desitarget.targetmask import desi_mask, bgs_mask, scnd_mask

    from desitarget.sv1.sv1_targetmask import desi_mask as sv1_desi_mask
    from desitarget.sv2.sv2_targetmask import desi_mask as sv2_desi_mask
    from desitarget.sv3.sv3_targetmask import desi_mask as sv3_desi_mask

    from desitarget.sv1.sv1_targetmask import bgs_mask as sv1_bgs_mask
    from desitarget.sv2.sv2_targetmask import bgs_mask as sv2_bgs_mask
    from desitarget.sv3.sv3_targetmask import bgs_mask as sv3_bgs_mask

    from desitarget.sv1.sv1_targetmask import scnd_mask as sv1_scnd_mask
    from desitarget.sv2.sv2_targetmask import scnd_mask as sv2_scnd_mask
    from desitarget.sv3.sv3_targetmask import scnd_mask as sv3_scnd_mask

    from fastspecfit.emlines import read_emlines

    linetable = read_emlines()

    for targ in ['BGS_ANY']:
        data = read_clustering(targetclass=targ)
        if not bool(data):
            return
        fast, meta = data[targ]['fast'], data[targ]['meta']
        del data

        print(meta.colnames)
    
        pdffile = os.path.join(datadir, 'vac-diagnostics', f'vac-{specprod}-{targ.lower()}.pdf')

        print(f'Writing {pdffile}')
        with PdfPages(pdffile) as pdf:
            fig, ax = plt.subplots()
            txt = [f'Target class: {targ}', f'N={len(meta):,d}', 
                   '',
                   f'specprod = {specprod}',
                   'set(survey) = {}'.format(', '.join(set(meta['SURVEY']))),
                   'set(program) = {}'.format(', '.join(set(meta['PROGRAM']))),
                   '',
                   'set(zwarn) = {}'.format(', '.join(set(meta['ZWARN'].astype(str)))),
                   'set(coadd_fiberstatus) = {}'.format(', '.join(set(meta['COADD_FIBERSTATUS'].astype(str))))]
            ax.text(0.1, 0.9, '\n'.join(txt), ha='left', va='center',
                    transform=ax.transAxes)
            ax.axis('off')
            pdf.savefig()

            fig, ax = plt.subplots()
            for zwarn in set(meta['ZWARN']):
                I = np.where(zwarn == meta['ZWARN'])[0]
                ax.hist(meta['Z'][I], bins=50, alpha=0.7, label=f'zwarn={zwarn} (N={len(I):,d})')
            ax.set_yscale('log')
            ax.legend()
            ax.set_xlabel('Redshift')
            ax.set_ylabel('Number of Objects')
            fig.tight_layout()
            pdf.savefig()

    pdb.set_trace()
    
def fig_vdisp(overwrite=False, png=None):

    import corner as cn
    from fastspecfit.io import read_fastspecfit
    from fastspecfit.io import write_fastspecfit

    sns, colors = plot_style(talk=True, font_scale=0.8)

    # build / read the sample
    fpfile = os.path.join(datadir, 'fuji_FP.fits')
    fp = Table(fitsio.read(fpfile, ext=1, upper=True)) # from Khaled
    log.info('Read {} from {}'.format(len(fp), fpfile))

    fastfile = os.path.join(datadir, 'fastspec-fuji_FP.fits')
    if os.path.isfile(fastfile) and not overwrite:
        fast, meta, _, _ = read_fastspecfit(fastfile)
    else:
        fast, meta = [], []
        for survey in set(fp['SURVEY']):
            J = np.where(survey == fp['SURVEY'])[0]
            for program in set(fp['PROGRAM'][J]):
                K = np.where(program == fp['PROGRAM'][J])[0]

                survey = survey.strip()
                program = program.strip()

                fastfile1 = fujidir+f'/fastspec-fuji-{survey}-{program}.fits'
                #fastfile1 = os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'fastspecfit', 'fuji', 'catalogs', f'fastspec-fuji-{survey}-{program}.fits')
                targetids = fitsio.read(fastfile1, ext='METADATA', columns='TARGETID')
                I = np.where(np.isin(targetids, fp[J][K]['TARGETID']))[0]
                
                fast1, meta1, _, _ = read_fastspecfit(fastfile1, rows=I)
                fast.append(fast1)
                meta.append(meta1)

        fast = vstack(fast)
        meta = vstack(meta)

        I = np.hstack([np.where(meta['TARGETID'] == tid)[0] for tid in fp['TARGETID']])
        fast = fast[I]
        meta = meta[I]
        assert(np.all(meta['TARGETID'] == fp['TARGETID']))

        write_fastspecfit(fast, meta, outfile=fastfile)

    I = np.where((fast['VDISP'] != 125.) * (fp['PPXF_SIGMA'] / fp['PPXF_SIGMA_ERROR'] > 2))[0]
    #I = np.where(fast['VDISP'] != 125.)[0]
    print(len(fast), len(I))
    #I = np.arange(len(fast))
    fast['VDISP_ERR'] = np.zeros(len(fast), 'f4') + 100
    fast['VDISP_ERR'][I] = 1 / np.sqrt(fast['VDISP_IVAR'][I])

    # make the plot
    vdisplim = np.array([40, 350])
    redlim = [0.0, 0.22]
    snrlim = np.log10([1, 150])
    mstarlim = [9.5, 12]
    residlim = np.array([-120, 120])

    col = colors[0]
    levels = [0.5, 0.75, 0.95]
    contour_kwargs = {'colors': col, 'alpha': 0.5}
    data_kwargs = {'color': col, 'alpha': 0.5, 'ms': 4}
    smooth = 1.5

    vresid = fast['VDISP'][I] - fp['PPXF_SIGMA'][I]
    
    #fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 10))
    fig = plt.figure(figsize=(8, 8))
    gs = fig.add_gridspec(nrows=2, ncols=3, height_ratios=[1, 0.4], width_ratios=[0.5, 0.5, 0.5])

    #from sklearn import linear_model
    #ransac = linear_model.RANSACRegressor()
    #ransac.fit((fp['PPXF_SIGMA'][I].data-vdispoff).reshape(len(I), 1), fast['VDISP'][I].data)

    npix = 100
    vdispoff = 200. # [km/s]
    vdispaxis = np.linspace(vdisplim[0], vdisplim[1], npix)

    import statsmodels.api as sm
    rlm = sm.RLM(fast['VDISP'][I].data, sm.add_constant(fp['PPXF_SIGMA'][I].data-vdispoff)).fit()

    #vdispmodel = ransac.predict((vdispaxis-vdispoff).reshape(npix, 1))
    #vcoeff = np.hstack([ransac.estimator_.coef_, ransac.estimator_.intercept_])
    vcoeff = [rlm.params[1], rlm.params[0]]
    vdispmodel = np.polyval(vcoeff, vdispaxis-vdispoff)

    #vcoeff = np.polyfit(fp['PPXF_SIGMA'][I], fast['VDISP'][I], 1)
    log.info(vcoeff)

    bigax = fig.add_subplot(gs[0, :]) # rows x cols

    cn.hist2d(fp['PPXF_SIGMA'][I], fast['VDISP'][I],
              bins=100, color=col, smooth=smooth, levels=levels,
              range=[vdisplim, vdisplim], ax=bigax, contour_kwargs=contour_kwargs,
              data_kwargs=data_kwargs)
    #bigax.errorbar(fp['PPXF_SIGMA'][I], fast['VDISP'][I], xerr=fp['PPXF_SIGMA_ERROR'][I],
    #               yerr=fast['VDISP_ERR'][I], fmt='s', color=colors[1], ecolor=colors[1], 
    #               markersize=1, capthick=2, capsize=1, alpha=0.2)
    txt = r'$\sigma_{{\mathrm{{fastspec}}}} = {:.3f}(\sigma_{{\mathrm{{pPXF}}}}-200) + {:.0f}$ km/s'.format(vcoeff[0], vcoeff[1])
    bigax.plot(vdispaxis, vdispmodel, lw=2, ls='--', color='k', label=txt)
    #bigax.plot(vdispaxis, np.polyval(vcoeff, vdispaxis), lw=2, ls='--', color='k')
    #bigax.scatter(fp['PPXF_SIGMA'][I], fast['VDISP'][I], s=1)
    bigax.plot(vdisplim, vdisplim, color='k', ls='-', alpha=0.6)
    #bigax.plot(vdisplim, vdisplim+10, color='k', ls='--', alpha=0.6)
    bigax.set_xlim(vdisplim)
    bigax.set_ylim(vdisplim)
    bigax.legend(loc='lower right', frameon=False, fontsize=11)
    bigax.set_xlabel(r'$\sigma$ [pPXF, km/s]')
    bigax.set_ylabel(r'$\sigma$ [fastspec, km/s]')

    ax1 = fig.add_subplot(gs[1, 0]) # rows x cols
    cn.hist2d(fast['Z'][I], vresid, 
              bins=100, color=col, smooth=smooth, levels=levels,
              range=[redlim, residlim], ax=ax1,
              contour_kwargs=contour_kwargs, data_kwargs=data_kwargs)
    #ax1.scatter(fast['Z'][I], vresid, s=1)
    ax1.axhline(y=0, color='k', ls='-')
    ax1.set_xlim(redlim)
    ax1.set_ylim(residlim)
    ax1.set_ylabel(r'$\Delta\sigma$ (km/s)')
    ax1.set_xlabel('Redshift')

    ax2 = fig.add_subplot(gs[1, 1])
    cn.hist2d(fast['LOGMSTAR'][I], vresid, 
              bins=100, color=col, smooth=smooth, levels=levels,
              range=[mstarlim, residlim], ax=ax2,
              contour_kwargs=contour_kwargs, data_kwargs=data_kwargs)
    #ax2.scatter(fast['LOGMSTAR'][I], vresid, s=1)
    ax2.axhline(y=0, color='k', ls='-')
    ax2.set_xlim(mstarlim)
    ax2.set_ylim(residlim)
    ax2.set_yticklabels([])
    ax2.set_xlabel(r'$\log_{10} (M/M_{\odot})$')

    ax3 = fig.add_subplot(gs[1, 2])
    cn.hist2d(np.log10(fast['SNR_B'][I]), vresid, 
              bins=100, color=col, smooth=smooth, levels=levels,
              range=[snrlim, residlim], ax=ax3,
              contour_kwargs=contour_kwargs, data_kwargs=data_kwargs)
    #ax3.scatter(fast['SNR_B'][I], vresid, s=1)
    ax3.axhline(y=0, color='k', ls='-')
    #ax3.set_xscale('log')
    ax3.xaxis.set_major_formatter(major_formatter)    
    ax3.set_xlim(snrlim)
    ax3.set_ylim(residlim)
    ax3.set_yticklabels([])
    ax3.set_xlabel(r'$S/N_{b}$ (pixel$^{-1}$)')

    if png:
        pngfile = os.path.join(figdir, png)
        log.info('Writing {}'.format(pngfile))
        #fig.subplots_adjust(bottom=0.15, right=0.85, top=0.95)
        fig.tight_layout()
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_mstar(overwrite=False, png=None):
    """Build the stellar mass figures."""

    sns, colors = plot_style(talk=True, font_scale=0.8)

    data = read_clustering()
    if not bool(data):
        return
        
    fig, ax = plt.subplots()
    ax.scatter(data['BGS_ANY']['fast']['Z'], data['BGS_ANY']['fast']['LOGMSTAR'], s=1)
    ax.scatter(data['LRG']['fast']['Z'], data['LRG']['fast']['LOGMSTAR'], s=1)
    ax.scatter(data['ELG']['fast']['Z'], data['ELG']['fast']['LOGMSTAR'], s=1)

    if png:
        pngfile = os.path.join(figdir, png)
        log.info('Writing {}'.format(pngfile))
        #fig.subplots_adjust(bottom=0.15, right=0.85, top=0.95)
        fig.tight_layout()
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_bpt_broadlines(overwrite=False, png=None):
    """Incidence of broad line-emission and BPT diagrams.

    """
    sns, colors = plot_style(talk=True, font_scale=0.8)

    data = read_clustering(targetclass='BGS_ANY')
    if not bool(data):
        return
    fast, meta = data['BGS_ANY']['fast'], data['BGS_ANY']['meta']
    del data

    snrcut = 2.
    #B = ((fast['HALPHA_AMP'] * np.sqrt(fast['HALPHA_AMP_IVAR']) > snrcut) * 
    #     (fast['HALPHA_BROAD_AMP'] * np.sqrt(fast['HALPHA_BROAD_AMP_IVAR']) > snrcut))
    B = (fast['HALPHA_BROAD_AMP'] * np.sqrt(fast['HALPHA_BROAD_AMP_IVAR']) > snrcut)
    N = (fast['HALPHA_AMP'] * np.sqrt(fast['HALPHA_AMP_IVAR']) > snrcut) * (fast['HALPHA_BROAD_AMP'] == 0.)

    fig, ax = plt.subplots()
    #ax.hist(fast['HALPHA_SIGMA'][N], bins=100, range=[0, 750])
    ax.hist(fast['HALPHA_BROAD_SIGMA'][B], bins=100, range=[0, 1e4])
    #ax.hist(fast['HALPHA_BROAD_SIGMA'][B], bins=100, alpha=0.7)
    ax.set_xlabel(r'$\sigma(\mathrm{H}\alpha)$ (km/s)')
    ax.set_ylabel('Number of Galaxies')
    ax.set_yscale('log')
    #ax.set_xscale('log')

    if png:
        pngfile = os.path.join(figdir, png)
        log.info('Writing {}'.format(pngfile))
        #fig.subplots_adjust(bottom=0.15, right=0.85, top=0.95)
        fig.tight_layout()
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

    pdb.set_trace()

def fig_example_emlines(png=None):
    """Illustrate our emission-line measurements.

    """
    from scipy.ndimage import gaussian_filter
    from matplotlib.patches import Rectangle, ConnectionPatch
    from desispec.io import read_spectra
    from desispec.coaddition import coadd_cameras    
    from fastspecfit.io import read_fastspecfit
    from fastspecfit.emlines import read_emlines
        
    sns, colors = plot_style(talk=True, font_scale=0.8)

    survey, program, healpix, targetid = 'sv1', 'dark', 8140, 39633560344201268

    exampledir = os.path.join(datadir, 'example-spectra')
    specfile = os.path.join(exampledir, f'coadd-{survey}-{program}-{healpix}-{targetid}.fits')
    fastfile = os.path.join(exampledir, f'fastspec-{survey}-{program}-{healpix}-{targetid}.fits')

    spec = read_spectra(specfile)
    coadd = coadd_cameras(spec)
    fast, meta, _, _, models = read_fastspecfit(fastfile, read_models=True)

    hdr = fitsio.read_header(fastfile, ext='MODELS')
    modelwave = hdr['CRVAL1'] + np.arange(hdr['NAXIS1']) * hdr['CDELT1']

    continuum = models[0, 0, :]
    smooth_continuum = models[0, 1, :]
    emlinemodel = models[0, 2, :]

    emlinewave = coadd.wave['brz']
    assert(np.all(np.isclose(modelwave, emlinewave)))
    
    specflux = coadd.flux['brz'][0, :]
    emlineflux = specflux - continuum - smooth_continuum
    specflux_nolines = specflux - emlinemodel

    #specflux = gaussian_filter(specflux, 2)
    #specflux_nolines = gaussian_filter(specflux_nolines, 2)

    linetable = read_emlines()

    nsigma = 3.
    redshift = fast['Z']

    linenames = ['OII_3729', 'OIII_5007', 'HALPHA', 'SII_6716']

    fig = plt.figure(figsize=(10, 8))
    gs = fig.add_gridspec(3, 4, height_ratios=[0.6, 0.2, 0.2]) # nrows, ncols

    specax = fig.add_subplot(gs[0, :])

    #specax.plot(emlinewave, gaussian_filter(specflux, 2))
    for icam, cam in enumerate(spec.bands):
        specax.plot(spec.wave[cam], gaussian_filter(spec.flux[cam].flat, 2))

    specax.margins(x=0)
    specax.set_ylabel(r'$F_{\lambda}\ (10^{-17}~{\rm erg}~{\rm s}^{-1}~{\rm cm}^{-2}~\AA^{-1})$')

    for iline, linename in enumerate(linenames):

        oneline = linetable[linetable['name'] == linename.lower()]
    
        linez = redshift + fast['{}_VSHIFT'.format(linename)][0] / C_LIGHT
        linezwave = oneline['restwave'] * (1 + linez)
        linesigma = fast['{}_SIGMA'.format(linename)][0]   # [km/s]
        amp = fast['{}_AMP'.format(linename)][0] 
        cont = fast['{}_CONT'.format(linename)][0]
        cont_sigma = 1. / np.sqrt(fast['{}_CONT_IVAR'.format(linename)][0])   # [km/s]

        linesigma_ang = linesigma * linezwave / C_LIGHT # [observed-frame Angstrom]
        linesigma_ang_window = linesigma_ang
    
        lineindx = np.where((emlinewave >= (linezwave - nsigma*linesigma_ang_window)) *
                            (emlinewave <= (linezwave + nsigma*linesigma_ang_window)))[0]
    
        indxlo = np.where((emlinewave > (linezwave - 10*linesigma_ang_window)) *
                          (emlinewave < (linezwave - 3.*linesigma_ang_window)))[0]
        indxhi = np.where((emlinewave < (linezwave + 10*linesigma_ang_window)) *
                          (emlinewave > (linezwave + 3.*linesigma_ang_window)))[0]
        indx = np.hstack((indxlo, indxhi))
    
        _indx = np.arange(indx[-1]-indx[0])+indx[0]

        plotindx = np.where((emlinewave >= (linezwave - 15*linesigma_ang_window)) *
                            (emlinewave <= (linezwave + 15*linesigma_ang_window)))[0]

        xx = fig.add_subplot(gs[1, iline])
        xx.plot(emlinewave[plotindx], emlineflux[plotindx])
        xx.plot(modelwave[plotindx], emlinemodel[plotindx])
        xx.axvline(x=emlinewave[lineindx[0]], color='blue', ls='--')
        xx.axvline(x=emlinewave[lineindx[-1]], color='blue', ls='--')
        xx.set_ylim(-0.5, np.max(emlinemodel[_indx])*1.2)
        xx.margins(0)
        xx.set_xticks([])

        xlim = xx.get_xlim()
        ylim = xx.get_ylim()

        xx.add_artist(ConnectionPatch(xyA=(xlim[0], ylim[1]), xyB=(xlim[0], cont-cont_sigma), 
                                      coordsA='data', coordsB='data', alpha=0.5,
                                      axesA=xx, axesB=specax, color='k'))
        xx.add_artist(ConnectionPatch(xyA=(xlim[1], ylim[1]), xyB=(xlim[1], cont-cont_sigma), 
                                      coordsA='data', coordsB='data', alpha=0.5,
                                      axesA=xx, axesB=specax, color='k'))
        specax.add_artist(Rectangle((xlim[0], cont-2*cont_sigma), np.ptp(xlim), amp,
                                    fill=False, color='k', alpha=0.5))

        # continuum plots
        xx = fig.add_subplot(gs[2, iline])
        xx.plot(emlinewave[plotindx], specflux_nolines[plotindx])
        xx.scatter(emlinewave[indxlo], specflux_nolines[indxlo], color='red', marker='s')
        xx.scatter(emlinewave[indxhi], specflux_nolines[indxhi], color='red', marker='s')
        xx.axhline(y=cont, color='k', ls='-')
        xx.axhline(y=cont+cont_sigma, color='k', ls='--')
        xx.axhline(y=cont-cont_sigma, color='k', ls='--')

    if png:
        pngfile = os.path.join(figdir, png)
        log.info('Writing {}'.format(pngfile))
        fig.subplots_adjust(left=0.11, bottom=0.1, right=0.95, top=0.95, hspace=0.25, wspace=0.25)
        #fig.tight_layout()
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_example_continuum(png=None):
    """Illustrate our continuum-fitting

    """
    pass

def _smooth_continuum(wave, flux, ivar, redshift, medbin=150, 
                      smooth_window=50, smooth_step=20, maskkms_uv=3000.0, 
                      maskkms_balmer=1000.0, maskkms_narrow=200.0,
                      linetable=None, emlinesfile=None, linemask=None, png=None,
                      log=None, verbose=False):
    """Build a smooth, nonparametric continuum spectrum.

    Parameters
    ----------
    wave : :class:`numpy.ndarray` [npix]
        Observed-frame wavelength array.
    flux : :class:`numpy.ndarray` [npix]
        Spectrum corresponding to `wave`.
    ivar : :class:`numpy.ndarray` [npix]
        Inverse variance spectrum corresponding to `flux`.
    redshift : :class:`float`
        Object redshift.
    medbin : :class:`int`, optional, defaults to 150 pixels
        Width of the median-smoothing kernel in pixels; a magic number.
    smooth_window : :class:`int`, optional, defaults to 50 pixels
        Width of the sliding window used to compute the iteratively clipped
        statistics (mean, median, sigma); a magic number. Note: the nominal
        extraction width (0.8 A) and observed-frame wavelength range
        (3600-9800 A) corresponds to pixels that are 66-24 km/s. So
        `smooth_window` of 50 corresponds to 3300-1200 km/s, which is
        conservative for all but the broadest lines. A magic number. 
    smooth_step : :class:`int`, optional, defaults to 10 pixels
        Width of the step size when computing smoothed statistics; a magic
        number.
    maskkms_uv : :class:`float`, optional, defaults to 3000 km/s
        Masking width for UV emission lines. Pixels within +/-3*maskkms_uv
        are masked before median-smoothing.
    maskkms_balmer : :class:`float`, optional, defaults to 3000 km/s
        Like `maskkms_uv` but for Balmer lines.
    maskkms_narrow : :class:`float`, optional, defaults to 300 km/s
        Like `maskkms_uv` but for narrow, forbidden lines.
    linemask : :class:`numpy.ndarray` of type :class:`bool`, optional, defaults to `None`
        Boolean mask with the same number of pixels as `wave` where `True`
        means a pixel is (possibly) affected by an emission line
        (specifically a strong line which likely cannot be median-smoothed).
    png : :class:`str`, optional, defaults to `None`
        Generate a simple QA plot and write it out to this filename.

    Returns
    -------
    smooth :class:`numpy.ndarray` [npix]
        Smooth continuum spectrum which can be subtracted from `flux` in
        order to create a pure emission-line spectrum.
    smoothsigma :class:`numpy.ndarray` [npix]
        Smooth one-sigma uncertainty spectrum.

    """
    from numpy.lib.stride_tricks import sliding_window_view
    from scipy.ndimage import median_filter
    from scipy.stats import sigmaclip
    #from astropy.stats import sigma_clip

    if log is None:
        from desiutil.log import get_logger, DEBUG
        if verbose:
            log = get_logger(DEBUG)
        else:
            log = get_logger()

    if linetable is None:
        from fastspecfit.emlines import read_emlines        
        linetable = read_emlines(emlinesfile=emlinesfile)
        
    npix = len(wave)

    # If we're not given a linemask, make a conservative one.
    if linemask is None:
        linemask = np.zeros(npix, bool) # True = (possibly) affected by emission line

        nsig = 3

        # select just strong lines
        zlinewaves = linetable['restwave'] * (1 + redshift)
        inrange = (zlinewaves > np.min(wave)) * (zlinewaves < np.max(wave))
        if np.sum(inrange) > 0:
            linetable = linetable[inrange]
            linetable = linetable[linetable['amp'] >= 1]
            if len(linetable) > 0:
                for oneline in linetable:
                    zlinewave = oneline['restwave'] * (1 + redshift)
                    if oneline['isbroad']:
                        if oneline['isbalmer']:
                            sigma = maskkms_balmer
                        else:
                            sigma = maskkms_uv
                    else:
                        sigma = maskkms_narrow
                
                    sigma *= zlinewave / C_LIGHT # [km/s --> Angstrom]
                    I = (wave >= (zlinewave - nsig*sigma)) * (wave <= (zlinewave + nsig*sigma))
                    if len(I) > 0:
                        linemask[I] = True

        # Special: mask Ly-a (1215 A)
        zlinewave = 1215.0 * (1 + redshift)
        if (zlinewave > np.min(wave)) * (zlinewave < np.max(wave)):
            sigma = maskkms_uv * zlinewave / C_LIGHT # [km/s --> Angstrom]
            I = (wave >= (zlinewave - nsig*sigma)) * (wave <= (zlinewave + nsig*sigma))
            if len(I) > 0:
                linemask[I] = True

    if len(linemask) != npix:
        errmsg = 'Linemask must have the same number of pixels as the input spectrum.'
        log.critical(errmsg)
        raise ValueError(errmsg)

    # Build the smooth (line-free) continuum by computing statistics in a
    # sliding window, accounting for masked pixels and trying to be smart
    # about broad lines. See:
    #   https://stackoverflow.com/questions/41851044/python-median-filter-for-1d-numpy-array
    #   https://numpy.org/devdocs/reference/generated/numpy.lib.stride_tricks.sliding_window_view.html
    
    wave_win = sliding_window_view(wave, window_shape=smooth_window)
    flux_win = sliding_window_view(flux, window_shape=smooth_window)
    ivar_win = sliding_window_view(ivar, window_shape=smooth_window)
    noline_win = sliding_window_view(np.logical_not(linemask), window_shape=smooth_window)

    nminpix = 15

    smooth_wave, smooth_flux, smooth_sigma, smooth_mask = [], [], [], []
    for swave, sflux, sivar, noline in zip(wave_win[::smooth_step],
                                           flux_win[::smooth_step],
                                           ivar_win[::smooth_step],
                                           noline_win[::smooth_step]):

        # if there are fewer than XX good pixels after accounting for the
        # line-mask, skip this window.
        sflux = sflux[noline]
        if len(sflux) < nminpix:
            smooth_mask.append(True)
            continue
        swave = swave[noline]
        sivar = sivar[noline]

        cflux, _, _ = sigmaclip(sflux, low=2.0, high=2.0)
        if len(cflux) < nminpix:
            smooth_mask.append(True)
            continue

        # Toss out regions with too little good data.
        if np.sum(sivar > 0) < nminpix:
            smooth_mask.append(True)
            continue

        I = np.isin(sflux, cflux) # fragile?
        sig = np.std(cflux) # simple median and sigma
        mn = np.median(cflux)

        #if png and mn < -1:# and np.mean(swave[I]) > 7600:
        #    print(np.mean(swave[I]), mn)

        # One more check for crummy spectral regions.
        if mn == 0.0:
            smooth_mask.append(True)
            continue

        smooth_wave.append(np.mean(swave[I]))
        smooth_mask.append(False)

        ## astropy is too slow!!
        #cflux = sigma_clip(sflux, sigma=2.0, cenfunc='median', stdfunc='std', masked=False, grow=1.5)
        #if np.sum(np.isfinite(cflux)) < 10:
        #    smooth_mask.append(True)
        #    continue
        #I = np.isfinite(cflux) # should never be fully masked!
        #smooth_wave.append(np.mean(swave[I]))
        #smooth_mask.append(False)
        #sig = np.std(cflux[I])
        #mn = np.median(cflux[I])

        ## inverse-variance weighted mean and sigma
        #norm = np.sum(sivar[I])
        #mn = np.sum(sivar[I] * cflux[I]) / norm # weighted mean
        #sig = np.sqrt(np.sum(sivar[I] * (cflux[I] - mn)**2) / norm) # weighted sigma

        smooth_sigma.append(sig)
        smooth_flux.append(mn)

    smooth_mask = np.array(smooth_mask)
    smooth_wave = np.array(smooth_wave)
    smooth_sigma = np.array(smooth_sigma)
    smooth_flux = np.array(smooth_flux)

    # For debugging.
    if png:
        _smooth_wave = smooth_wave.copy()
        _smooth_flux = smooth_flux.copy()

    # corner case for very wacky spectra
    if len(smooth_flux) == 0:
        smooth_flux = flux
        smooth_sigma = flux * 0 + np.std(flux)
    else:
        from scipy.interpolate import make_interp_spline
        srt = np.argsort(smooth_wave)
        bspl_flux = make_interp_spline(smooth_wave[srt], smooth_flux[srt], k=1)
        smooth_flux = bspl_flux(wave)

        bspl_sigma = make_interp_spline(smooth_wave[srt], smooth_sigma[srt], k=1)
        smooth_sigma = bspl_sigma(wave)
        #pdb.set_trace()
        #smooth_flux = np.interp(wave, smooth_wave, smooth_flux)
        #smooth_sigma = np.interp(wave, smooth_wave, smooth_sigma)

    if False:
        smooth = smooth_flux
        smoothsigma = smooth_sigma
    else:
        smooth = median_filter(smooth_flux, medbin, mode='nearest')
        smoothsigma = median_filter(smooth_sigma, medbin, mode='nearest')

    Z = (flux == 0.0) * (ivar == 0.0)
    if np.sum(Z) > 0:
        smooth[Z] = 0.0

    # Optional QA.
    if png:
        import matplotlib.pyplot as plt

        minwave, maxwave = wave.min(), wave.max() # 5000, 9000
        I = (wave > minwave) * (wave < maxwave)

        fig, ax = plt.subplots(2, 1, figsize=(8, 10), sharex=True)
        ax[0].plot(wave[I], flux[I], alpha=0.5, color='gray')
        ax[0].scatter(wave[linemask], flux[linemask], s=10, marker='s', color='k', alpha=0.7)#, zorder=2)
        ax[0].plot(wave, smooth, color='orange')
        #ax[0].scatter(_smooth_wave, _smooth_flux, color='red', s=5, marker='s')
        #ax[0].scatter(_smooth_wave, _smooth_flux, color='orange', marker='s', ls='-', s=20)

        ax[1].plot(wave[I], flux[I] - smooth[I], color='gray', alpha=0.5)
        ax[1].axhline(y=0, color='k', lw=2)

        for xx in ax:
            xx.set_xlim(minwave, maxwave)
        #for xx in ax:
        #    xx.set_ylim(-2.5, 2)

        zlinewaves = linetable['restwave'] * (1 + redshift)
        linenames = linetable['name']
        inrange = np.where((zlinewaves > np.min(wave)) * (zlinewaves < np.max(wave)))[0]
        if len(inrange) > 0:
            for linename, zlinewave in zip(linenames[inrange], zlinewaves[inrange]):
                #print(linename, zlinewave)
                for xx in ax:
                    xx.axvline(x=zlinewave, color='gray')

        fig.savefig(png)

    return smooth, smoothsigma
    
def smooth_continuum(overwrite=False):
    """Illustrating the smooth continuum algorithm.

    """
    from scipy.ndimage import gaussian_filter
    from desispec.io import read_spectra
    from desispec.coaddition import coadd_cameras    
    from fastspecfit.io import read_fastspecfit, DESISpectra
    from fastspecfit.io import cache_templates, get_templates_filename
    from fastspecfit.continuum import ContinuumTools

    #from fastspecfit.continuum import _smooth_continuum
    
    exampledir = os.path.join(datadir, 'example-spectra')
    survey, program, healpix, targetid = 'sv1', 'dark', 7610, 39633483106093315

    one_desi_spectrum(survey=survey, program=program, healpix=healpix,
                      targetid=targetid, specprod='fuji', outdir=exampledir,
                      overwrite=overwrite)
    
    redfile = os.path.join(exampledir, f'redrock-{survey}-{program}-{healpix}-{targetid}.fits')
    specfile = os.path.join(exampledir, f'coadd-{survey}-{program}-{healpix}-{targetid}.fits')
    fastfile = os.path.join(exampledir, f'fastspec-{survey}-{program}-{healpix}-{targetid}.fits')

    Spec = DESISpectra()
    Spec.select(redfile)
    data = Spec.read_and_unpack()
    data = data[0]

    specwave = np.hstack(data['wave'])
    specflux = np.hstack(data['flux'])
    specivar = np.hstack(data['ivar']) * np.logical_not(np.hstack(data['linemask'])) # mask emission lines

    #spec = read_spectra(specfile)
    #coadd = coadd_cameras(spec)
    #wave = np.hstack([coadd.wave[cam] for cam in coadd.bands])
    #flux = np.hstack([coadd.flux[cam].flatten() for cam in coadd.bands])
    #ivar = np.hstack([coadd.ivar[cam].flatten() for cam in coadd.bands])

    fast, meta, _, _, models = read_fastspecfit(fastfile, read_models=True)

    redshift = fast['Z'][0]
    use_vdisp = fast['VDISP'][0]
    coeff = fast['COEFF'].flatten()

    #hdr = fitsio.read_header(fastfile, ext='MODELS')
    #modelwave = hdr['CRVAL1'] + np.arange(hdr['NAXIS1']) * hdr['CDELT1']
    #continuum = models[0, 0, :]
    #smooth_continuum = models[0, 1, :]
    #emlinemodel = models[0, 2, :]

    templates = get_templates_filename()
    templatecache = cache_templates(templates, mintemplatewave=450.0, maxtemplatewave=40e4)
    CTools = ContinuumTools(continuum_pixkms=templatecache['continuum_pixkms'],
                            pixkms_wavesplit=templatecache['pixkms_wavesplit'])

    input_templateflux_nolines = templatecache['templateflux_nolines']

    desitemplates_nolines, _ = CTools.templates2data(
        input_templateflux_nolines, templatecache['templatewave'], redshift=redshift,
        dluminosity=data['dluminosity'],
        specwave=data['wave'], specres=data['res'], specmask=data['mask'], 
        vdisp=use_vdisp, cameras=data['cameras'], stack_cameras=True, 
        synthphot=False)

    desimodel_nolines = desitemplates_nolines.dot(coeff)    

    residuals = specflux - desimodel_nolines
    linemask = np.hstack(data['linemask'])

    smooth, smoothsigma = _smooth_continuum(specwave, residuals, specivar, redshift=redshift, 
                                            linemask=linemask, png='smooth.png')

    pdb.set_trace()

    minwave, maxwave = 8400, 8500
    I = (specwave > minwave) * (specwave < maxwave)

    #fig, ax = plt.subplots()
    #ax.plot(specwave, 1 / np.sqrt(specivar))
    #ax.plot(specwave, smoothsigma)
    #fig.tight_layout()
    #fig.savefig('smooth.png')

    fig, ax = plt.subplots()
    ax.plot(specwave, gaussian_filter(specflux, 0))
    ax.plot(specwave, gaussian_filter(desimodel_nolines, 0))
    ax.plot(specwave, gaussian_filter(desimodel_nolines+smooth, 0))
    ax.plot(specwave, gaussian_filter(smooth, 0))
    ax.set_ylim(-0.2, 1.5)
    fig.tight_layout()
    fig.savefig('smooth.png')

def fig_sps_models(png=None):

    from scipy.stats import gmean
    from matplotlib.patches import Rectangle
    from speclite import filters
    from fastspecfit.io import cache_templates
    from fastspecfit.util import TabulatedDESI

    sns, colors = plot_style(style='ticks', talk=True, font_scale=1.1)

    @ticker.FuncFormatter
    def major_formatter(x, pos):
        if (x >= 0.01) and (x < 0.1):
            return f'{x:.2f}'
        elif (x >= 0.1) and (x < 1):
            return f'{x:.1f}'
        else:
            return f'{x:.0f}'

    def age_formatter(x):
        xMyr = x / 1e6
        xGyr = x / 1e9
        if (xMyr < 1e3):
            return f'{xMyr:.0f} Myr'
        else:
            return f'{xGyr:.1f} Gyr'

    filt = filters.load_filters('decam2014-g', 'decam2014-r', 'decam2014-z', 
                                'wise2010-W1', 'wise2010-W2', 'wise2010-W3', 'wise2010-W4')
    bands = ['g', 'r', 'z', 'W1', 'W2', 'W3', 'W4']

    templateversion = '1.1.0'
    cache = cache_templates(templateversion=templateversion)

    wave = cache['templatewave'] 
    allflux = cache['templateflux']
    allmeta = cache['templateinfo']
    print(set(allmeta['age']))

    zref = 0.1
    cosmo = TabulatedDESI()
    dlum = cosmo.luminosity_distance(zref)

    logmstar = 10.5
    fluxnorm = 1. #1e17
    T = fluxnorm * 10**logmstar * (10. / (1e6 * dlum))**2 / (1. + zref)
    factor = 10**(0.4 * 48.6) * wave**2 / (C_LIGHT * 1e13) # flam --> fnu

    wdesi = [0.36, 0.98]
    ffact = -3.

    def plotit(ax, I, txt, show_legend=False, show_filters=False, xlabel=None, 
               xticks=None, yticks=None, xlim=[0.06, 40], ylim=[29.5, 3]):

        flux = allflux[:, I]
        meta = allmeta[I]
    
        npix, nmodel = flux.shape
        #print(npix, nmodel)
    
        ax.add_artist(Rectangle((wdesi[0], ylim[1]), np.ptp(wdesi), np.ptp(ylim), 
                                fill=True, color='gray', alpha=0.2))#, zorder=0)

        for ii in range(nmodel):
            flux1 = factor * T * flux[:, ii]
            J = np.where(flux1 > 0)[0]
            ax.plot(wave[J] / 1e4, -2.5 * np.log10(flux1[J]), lw=2,
                    label=age_formatter(meta['age'][ii]), zorder=1)

        if show_filters:
            for ff, band in zip(filt, bands):
                ax.plot(ff.wavelength / 1e4, ffact * ff.response / np.max(ff.response) + ylim[0], 
                        color='k', alpha=0.8, lw=1)
                #print(band, ff.effective_wavelength.value / 1e4, 0.5 * ffact + ylim[0])
                ax.text(ff.effective_wavelength.value / 1e4, -0.7 + ffact + ylim[0],
                        band, fontsize=10, va='center', ha='center')
            #ax.text(1.0, 25., 'g', fontsize=20, va='center', ha='center')

        #print((wdesi[0], ylim[0]), np.ptp(wdesi), np.ptp(ylim))

        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
        ax.set_xscale('log')

        if xticks == '':
            ax.xaxis.set_major_formatter(ticker.NullFormatter())
            #ax.set_xticks([])
        else:
            ax.xaxis.set_major_formatter(major_formatter)
            #ax.set_xticks(np.array([0.1, 0.2, 0.5, 1.0, 1.5, 3.0, 5.0, 10.0, 20.0]))

        if yticks == '':
            ax.yaxis.set_major_formatter(ticker.NullFormatter())
            #ax.set_yticks([])

        ax.text(0.03, 0.96, '\n'.join(txt), transform=ax.transAxes, 
                fontsize=14, va='top', ha='left')

        if xlabel:
            ax.set_xlabel(xlabel)

        if show_legend:
            ax.legend(fontsize=10, ncols=1, loc='lower right')

    #fig, ((ax1, ax2, ax3), (ax4, ax5, ax6)) = plt.subplots(
    #    2, 3, sharex=True, sharey=True, figsize=(16, 9))

    fig = plt.figure(figsize=(16, 9))
    gs = fig.add_gridspec(nrows=2, ncols=3)

    ax1 = fig.add_subplot(gs[0, 0]) # rows x cols
    ax2 = fig.add_subplot(gs[0, 1])
    ax3 = fig.add_subplot(gs[0, 2])
    ax4 = fig.add_subplot(gs[1, 0])
    ax5 = fig.add_subplot(gs[1, 1])

    plotit(ax1, np.where((allmeta['av'] == 0.) * (allmeta['zzsun'] == -1.))[0],
           [r'$Z=0.1Z_{\odot}$', r'$A(V)=0$ mag'], show_filters=True, xticks='')
    plotit(ax2, np.where((allmeta['av'] == 0.) * (allmeta['zzsun'] == 0.))[0],
           [r'$Z=Z_{\odot}$', r'$A(V)=0$ mag'], show_filters=True, xticks='', yticks='')
    plotit(ax3, np.where((allmeta['av'] == 0.) * (allmeta['zzsun'] == 0.3))[0],
           [r'$Z=2Z_{\odot}$', r'$A(V)=0$ mag'], show_filters=True, xticks='', yticks='')

    plotit(ax4, np.where((allmeta['av'] == 0.11521167) * (allmeta['zzsun'] == 0.))[0],
           [r'$Z=Z_{\odot}$', r'$A(V)=0.115$ mag'], show_filters=True, 
           xlabel='Rest Wavelength ($\mu$m)')
    plotit(ax5, np.where((allmeta['av'] == 1.412526) * (allmeta['zzsun'] == 0.))[0],
           [r'$Z=Z_{\odot}$', r'$A(V)=1.41$ mag'], show_legend=False, show_filters=True, 
           yticks='', xlabel='Rest Wavelength ($\mu$m)')

    # SFH - from build_fsps_templates
    ax6 = fig.add_subplot(gs[1, 2])

    agelims = np.array([0., 0.01, 0.03, 0.1, 0.33, 1.1, 3.6, 12., 14.]) # [Gyr]
    nages = len(agelims) - 1
    agebins = np.array([agelims[:-1], agelims[1:]]).T # [Gyr]
    sfrs = [0.4, 0.12, 0.15, 0.19, 0.14, 0.44, 0.52, 0.66]

    handles, labels = ax1.get_legend_handles_labels()

    for ibin, (abin, sfr, handle, label) in enumerate(zip(agebins, sfrs, handles, labels)):
        #print(abin, np.mean(abin))
        #sfr = 0.1+ibin/10
        if ibin == 0:
            xpos = 0.006
        else:
            xpos = gmean(abin)
        ypos = sfr * 1.2
        ax6.add_artist(Rectangle((abin[0], 0), np.ptp(abin), sfr, 
                                 fill=True, color=handle.get_color()))
        ax6.text(xpos, ypos, label.replace(' ', '\n'),
                 ha='center', va='center', fontsize=11)

    ax6.set_xlim(4e-3, 20.)

    ax6.set_ylim(1e-1, 1)
    ax6.set_yscale('log')
    ax6.yaxis.set_minor_formatter(ticker.NullFormatter())
    ax6.yaxis.set_major_formatter(ticker.NullFormatter())

    ax6.set_xscale('log')
    ax6.xaxis.set_major_formatter(major_formatter)
    ax6.set_xlabel('Lookback Time (Gyr)')

    ax6_twin = ax6.twinx()
    ax6_twin.set_ylim(1e-1, 1)
    ax6_twin.set_yscale('log')
    ax6_twin.set_xscale('log')
    ax6_twin.yaxis.set_minor_formatter(ticker.NullFormatter())
    ax6_twin.yaxis.set_major_formatter(ticker.NullFormatter())
    ax6_twin.set_ylabel(r'SFR ($M_{\odot}~\mathrm{yr}^{-1}$)'+'\n(arbitrary normalization)')

    #ax6.legend(hh, ll, loc='upper left', fontsize=12)

    ulpos = ax1.get_position()
    llpos = ax4.get_position()
    lrpos = ax6.get_position()

    #fig.text((lrpos.x1-llpos.x0)/2+llpos.x0, lrpos.y0-0.07, 
    #         'Rest Wavelength ($\mu$m)', ha='center', va='center')
    fig.text(ulpos.x0-0.1, (ulpos.y1-llpos.y0)/2+llpos.y0, 
             f'AB mag ($10^{{{logmstar:.1f}}}~M_{{\odot}}$ galaxy at $z={zref:.1f}$)', 
             ha='center', va='center', rotation=90)
    fig.subplots_adjust(left=0.08, right=0.92, top=0.95, bottom=0.12, wspace=0.08, hspace=0.08)

    if png:
        pngfile = os.path.join(figdir, png)
        log.info('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def main():

    import argparse    

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # build data sets
    parser.add_argument('--match-lss', action='store_true', help='Match to the LSS catalogs (no figures, just catalogs).')
    parser.add_argument('--write-example-spectra', action='store_true', help='Build example spectra (no figures, just catalogs).')

    # diagnostic figures
    parser.add_argument('--smooth-continuum', action='store_true')
    parser.add_argument('--compare-raga', action='store_true', help='Compare with Ragas broad-line fitting.')
    parser.add_argument('--compare-zouhu', action='store_true', help='Compare with the zouhu VAC.')    
    parser.add_argument('--vac-diagnostics', action='store_true', help='Wide range of VAC diagnostic plots.')

    # figures for paper
    parser.add_argument('--vdisp', action='store_true', help='Velocity dispersion comparison.')
    parser.add_argument('--mstar', action='store_true', help='Stellar mass plots.')
    parser.add_argument('--example-emlines', action='store_true', help='Illustration of the emission-line fitting.')
    parser.add_argument('--example-continuum', action='store_true', help='Illustration of the continuum-fitting.')
    parser.add_argument('--sps-models', action='store_true', help='SPS model spectra.')
    parser.add_argument('--bpt-broadlines', action='store_true', help='Incidence of broad line-emission and BPT diagrams.')

    # other options
    parser.add_argument('--specprod', default='fuji', help='Spectroscopic production.')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing QA files.')
    args = parser.parse_args()

    # data below here
    if args.match_lss:
        match_lss(overwrite=args.overwrite)
    if args.write_example_spectra:
        write_example_spectra(overwrite=args.overwrite)

    # diagnostic figures
    if args.smooth_continuum:
        smooth_continuum()
    if args.compare_zouhu:
        compare_zouhu()
    if args.compare_raga:
        compare_raga()
    if args.vac_diagnostics:
        vac_diagnostics(specprod=args.specprod)

    # paper figures below here
    if args.vdisp:
        fig_vdisp(overwrite=args.overwrite, png='ppxf-vdisp.png')
    if args.mstar:
        fig_mstar(png='mstar.png')
    if args.example_emlines:
        fig_example_emlines(png='example-emlines.png')
    if args.example_continuum:
        fig_example_continuum(png='example-continuum.png')
    if args.sps_models:
        fig_sps_models(png='sps-models.png')
    if args.bpt_broadlines:
        fig_bpt_broadlines(png='bpt-broadlines.png')

if __name__ == '__main__':
   main()

