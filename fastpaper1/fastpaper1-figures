#!/usr/bin/env python

"""Figures for FastSpecFit paper 1.

# build the data
time /global/u2/i/ioannis/code/desihub/fastspecfit-projects/fastpaper1/fastpaper1-figures --match-lss
time /global/u2/i/ioannis/code/desihub/fastspecfit-projects/fastpaper1/fastpaper1-figures --build-example-spectra

# build the figures
time /global/u2/i/ioannis/code/desihub/fastspecfit-projects/fastpaper1/fastpaper1-figures --mstar

"""
import os, pdb
import numpy as np
import fitsio
from astropy.table import Table, vstack
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

from desitarget import geomask
from desiutil.log import get_logger
log = get_logger()

from fastspecfit.util import C_LIGHT

paperdir = os.path.join(os.getenv('DESI_ROOT'), 'users', 'ioannis', 'fastspecfit', 'fastpaper1')
figdir = os.path.join(paperdir, 'figures')
datadir = os.path.join(paperdir, 'data')

@ticker.FuncFormatter
def major_formatter(x, pos):
    if x >= 0:
        return '{:.0f}'.format(10**x)
    else:
        return '{:.1f}'.format(10**x)

def plot_style(font_scale=1.2, paper=False, talk=True):

    import seaborn as sns
    rc = {'font.family': 'serif'}#, 'text.usetex': True}
    #rc = {'font.family': 'serif', 'text.usetex': True,
    #       'text.latex.preamble': r'\boldmath'})
    palette, context = 'Set2', 'talk'
    
    if paper:
        context = 'paper'
        palette = 'deep'
        rc.update({'text.usetex': False})
    
    if talk:
        context = 'talk'
        palette = 'deep'
        #rc.update({'text.usetex': True})

    sns.set(context=context, style='ticks', font_scale=font_scale, rc=rc)
    sns.set_palette(palette, 12)

    colors = sns.color_palette()
    #sns.reset_orig()

    return sns, colors

def build_example_spectra(overwrite=False):
    """Simple script to write out small coadded spectra and redrock files needed for
    the example spectra/modeling figures in the paper.

    """
    from redrock.external.desi import write_zbest
    from desispec.io import write_spectra, read_spectra
    from fastspecfit.qa import fastqa
    from fastspecfit.fastspecfit import fastspec

    def write_one_spectrum(survey, program, healpix, targetid, specprod='fuji', overwrite=False):

        os.environ['SPECPROD'] = specprod # needed to get write_spectra have the correct dependency

        specdir = os.path.join(os.environ.get('DESI_ROOT'), 'spectro', 'redux', specprod, 'healpix',
                               survey, program, str(healpix//100), str(healpix))
        coaddfile = os.path.join(specdir, f'coadd-{survey}-{program}-{healpix}.fits')
        redrockfile = os.path.join(specdir, f'redrock-{survey}-{program}-{healpix}.fits')

        outdir = os.path.join(datadir, 'example-spectra')
        out_coaddfile = os.path.join(outdir, f'coadd-{survey}-{program}-{healpix}-{targetid}.fits')
        out_redrockfile = os.path.join(outdir, f'redrock-{survey}-{program}-{healpix}-{targetid}.fits')
        out_fastfile = os.path.join(outdir, f'fastspec-{survey}-{program}-{healpix}-{targetid}.fits')
        if (os.path.isfile(out_coaddfile) or os.path.isfile(out_redrockfile) or os.path.isfile(out_fastfile)) and not overwrite:
            if os.path.isfile(out_coaddfile):
                print(f'Coadd file {out_coaddfile} exists and overwrite is False')
            if os.path.isfile(out_redrockfile):
                print(f'Redrock file {out_redrockfile} exists and overwrite is False')
            if os.path.isfile(out_fastfile):
                print(f'fastspec file {out_fastfile} exists and overwrite is False')
            return
        
        redhdr = fitsio.read_header(redrockfile)
        zbest = Table.read(redrockfile, 'REDSHIFTS')
        fibermap = Table.read(redrockfile, 'FIBERMAP')
        expfibermap = Table.read(redrockfile, 'EXP_FIBERMAP')
        tsnr2 = Table.read(redrockfile, 'TSNR2')
        
        spechdr = fitsio.read_header(coaddfile)
        
        zbest = zbest[np.isin(zbest['TARGETID'], targetid)]
        fibermap = fibermap[np.isin(fibermap['TARGETID'], targetid)]
        expfibermap = expfibermap[np.isin(expfibermap['TARGETID'], targetid)]
        tsnr2 = tsnr2[np.isin(tsnr2['TARGETID'], targetid)]
        
        archetype_version = None
        template_version = {redhdr['TEMNAM{:02d}'.format(nn)]: redhdr['TEMVER{:02d}'.format(nn)] for nn in np.arange(10)}

        print(f'Writing {out_redrockfile}')
        write_zbest(out_redrockfile, zbest, fibermap, expfibermap, tsnr2,
                    template_version, archetype_version, spec_header=spechdr)
        
        spec = read_spectra(coaddfile).select(targets=targetid)
        print(f'Writing {out_coaddfile}')
        write_spectra(out_coaddfile, spec)

        fastspec(args=f'{out_redrockfile} -o {out_fastfile}'.split())
        fastqa(args=f'{out_fastfile} --redrockfiles {out_redrockfile} -o {outdir}'.split())

    # broad-line AGN example
    write_one_spectrum(survey='sv3', program='bright', healpix=26065, targetid=39627878949720219,
                       specprod='fuji', overwrite=overwrite)

    ## narrow-line spectrum on a somewhat evolved continuum; nice [OIII] 5007
    #write_one_spectrum(survey='sv1', program='bright', healpix=17675, targetid=39627628474278005,
    #                   specprod='fuji', overwrite=overwrite)

    # nice star-forming galaxy
    write_one_spectrum(survey='sv1', program='dark', healpix=8140, targetid=39633560344201268,
                       specprod='fuji', overwrite=overwrite)

    # testing smooth continuum algorithm
    write_one_spectrum(survey='sv1', program='dark', healpix=7610, targetid=39633483106093315,
                       specprod='fuji', overwrite=overwrite)

def compare_zouhu(png=None):
    """Compare with the Hu Zou VAC."""

    from fastspecfit.io import read_fastspecfit

    zouhufile = '/global/cfs/cdirs/desi/users/zouhu/vac/edr/edr_galaxy_stellarmass_lineinfo_v1.0.fits'
    zouhu = Table(fitsio.read(zouhufile))
    _, uindx = np.unique(zouhu['TARGETID'], return_index=True)
    zouhu = zouhu[uindx]

    if False:
        darkfile = '/pscratch/sd/i/ioannis/fastspecfit/data/fuji/catalogs/fastspec-fuji-sv3-dark.fits'
        brightfile = '/pscratch/sd/i/ioannis/fastspecfit/data/fuji/catalogs/fastspec-fuji-sv3-bright.fits'
        fastbright, metabright, _, _ = read_fastspecfit(brightfile)
        fastdark, metadark, _, _ = read_fastspecfit(darkfile)
        fast = vstack((fastbright, fastdark))
        meta = vstack((metabright, metadark))
        del fastbright, metabright, fastdark, metadark
    else:
        fastfile = '/pscratch/sd/i/ioannis/fastspecfit/data3/fuji/catalogs/fastspec-fuji.fits'
        fast, meta, _, _ = read_fastspecfit(fastfile)

    _, uindx = np.unique(fast['TARGETID'], return_index=True)
    fast = fast[uindx]
    meta = meta[uindx]

    indx_fast, indx_zouhu = geomask.match(fast['TARGETID'], zouhu['TARGETID'])
    fast = fast[indx_fast]
    meta = meta[indx_fast]
    zouhu = zouhu[indx_zouhu]
    assert(np.all(meta['TARGETID'] == zouhu['TARGETID']))
    
    I = ((fast['HALPHA_FLUX'] > 0) * (fast['HALPHA_FLUX_IVAR'] > 0) *
         (fast['HALPHA_BOXFLUX'] > 0) * (fast['HALPHA_BOXFLUX_IVAR'] > 0) *
         (fast['HALPHA_BROAD_FLUX_IVAR'] == 0) *
         (zouhu['HALPHA_FLUX'] > 0) * (zouhu['HALPHA_FLUXERR'] > 0) *
         np.isfinite(zouhu['HALPHA_FLUX']) * np.isfinite(zouhu['HALPHA_FLUXERR']) )

    B = (fast['HALPHA_FLUX'][I] * np.sqrt(fast['HALPHA_FLUX_IVAR'][I]) > 1.5) * ((np.log10(fast['HALPHA_FLUX'][I])-np.log10(zouhu['HALPHA_FLUX'][I])) > 0.25)
    check = fast[I][B]['SURVEY', 'PROGRAM', 'HEALPIX', 'TARGETID', 'HALPHA_FLUX', 'HALPHA_BOXFLUX', 'HALPHA_SIGMA']
    check['HU_HALPHA_FLUX'] = zouhu['HALPHA_FLUX'][I][B]
    check['HU_HALPHA_SIGMA'] = zouhu['HALPHA_SIGMA'][I][B]

    #ax.scatter(fast['HALPHA_SIGMA'][I], np.log10(fast['HALPHA_FLUX'][I])-np.log10(zouhu['HALPHA_FLUX'][I]), s=1)

    fig, ax = plt.subplots()
    ax.scatter(zouhu['HALPHA_SIGMA'][I], np.log10(fast['HALPHA_FLUX'][I])-np.log10(zouhu['HALPHA_FLUX'][I]), s=1)
    ax.set_ylim(-1, 1)
    fig.tight_layout()
    fig.savefig('desi-users/ioannis/tmp/junk2.png')
    
    fig, ((ax1, ax2), (ax3, ax4), (ax5, ax6)) = plt.subplots(3, 2, figsize=(10, 12))

    ax1.scatter(np.log10(fast['HALPHA_FLUX'][I]), np.log10(zouhu['HALPHA_FLUX'][I]), s=1)
    ax1.scatter(np.log10(fast['HALPHA_FLUX'][I][B]), np.log10(zouhu['HALPHA_FLUX'][I][B]), s=1, color='orange')

    ax2.scatter(np.log10(fast['HALPHA_BOXFLUX'][I]), np.log10(zouhu['HALPHA_FLUX'][I]), s=1)
    #B = ((np.log10(fast['HALPHA_BOXFLUX'][I]) > 3) *
    #     (np.log10(zouhu['HALPHA_FLUX'][I]) > 2) * (np.log10(zouhu['HALPHA_FLUX'][I]) < 3))
    ax2.scatter(np.log10(fast['HALPHA_BOXFLUX'][I][B]), np.log10(zouhu['HALPHA_FLUX'][I][B]), s=1, color='orange')

    ax3.scatter(np.log10(1/np.sqrt(fast['HALPHA_FLUX_IVAR'][I])), np.log10(zouhu['HALPHA_FLUXERR'][I]), s=1)
    ax4.scatter(np.log10(1/np.sqrt(fast['HALPHA_BOXFLUX_IVAR'][I])), np.log10(zouhu['HALPHA_FLUXERR'][I]), s=1)

    ax5.scatter(np.log10(fast['HALPHA_FLUX'][I]*np.sqrt(fast['HALPHA_FLUX_IVAR'][I])),
                np.log10(zouhu['HALPHA_FLUX'][I]/zouhu['HALPHA_FLUXERR'][I]), s=1)
    ax6.scatter(np.log10(fast['HALPHA_FLUX'][I]*np.sqrt(fast['HALPHA_BOXFLUX_IVAR'][I])),
                np.log10(zouhu['HALPHA_FLUX'][I]/zouhu['HALPHA_FLUXERR'][I]), s=1)

    ax1.set_ylabel('log Flux [Hu Zou / mpfit]')
    ax1.set_xlabel('log Flux [fastspec, Gauss]')
    ax2.set_xlabel('log Flux [fastspec, Box]')
    for xx in [ax1, ax2]:
        xx.set_xlim(-2, 4)
        xx.set_ylim(-2, 4)
        xx.plot([-2, 4], [-2, 4], color='k')

    ax3.set_ylabel('log Flux Error [Hu Zou / mpfit]')
    ax3.set_xlabel('log Flux Error [fastspec, Gauss]')
    ax4.set_xlabel('log Flux Error [fastspec, Box]')
    for xx in [ax3, ax4]:
        xx.set_xlim(-2, 2.5)
        xx.set_ylim(-2, 2.5)
        xx.plot([-2, 2.5], [-2, 2.5], color='k')

    ax5.set_ylabel('log Flux S/N [Hu Zou / mpfit]')
    ax5.set_xlabel('log Flux S/N [fastspec, Gauss]')
    ax6.set_xlabel('log Flux S/N [fastspec, Box]')
    for xx in [ax5, ax6]:
        xx.set_xlim(-1.5, 3.5)
        xx.set_ylim(-1.5, 3.5)
        xx.plot([-1.5, 3.5], [-1.5, 3.5], color='k')
        
    fig.tight_layout()
    fig.savefig('desi-users/ioannis/tmp/junk.png')

    pdb.set_trace()

def match_lss(overwrite=False):
    """Match to the LSS catalogs (full and clustering)."""

    from fastspecfit.io import read_fastspecfit
    from fastspecfit.io import write_fastspecfit
    #from desispec.validredshifts import actually_validate
    #actually_validate(cat, fiberstatus_cut=True, ignore_emline=True)
    #https://github.com/desihub/LSS/blob/main/py/LSS/main/cattools.py#L2968

    # read the clustering catalogs
    lssdir = '/global/cfs/cdirs/desi/vac/edr/lss/v2.0/LSScats'
    for targtype in ['BGS_ANY', 'LRG', 'ELG', 'QSO']:

        fastfile = os.path.join(datadir, 'clustering', f'fastspec-clustering-{targtype}.fits')
        lssfile = os.path.join(datadir, 'clustering', f'lss-clustering-{targtype}.fits')
        #lssfullfile = os.path.join(datadir, 'full', f'lss-full-{targtype}.fits')

        if os.path.isfile(fastfile) and os.path.isfile(lssfile) and not overwrite:
            log.info(f'fastspecfit file {fastfile} exists')
            log.info(f'LSS clustering file {lssfile} exists')
        else:
            lssN = fitsio.read(os.path.join(lssdir, 'clustering', f'{targtype}_N_clustering.dat.fits'))
            lssS = fitsio.read(os.path.join(lssdir, 'clustering', f'{targtype}_S_clustering.dat.fits'))
            lss = Table(np.concatenate((lssN, lssS)))
            del lssN, lssS
    
            if targtype == 'BGS_ANY':
                sv3file = '/pscratch/sd/i/ioannis/fastspecfit/data/fuji/catalogs/fastspec-fuji-sv3-bright.fits'
                fast, meta, _, _ = read_fastspecfit(fastfile)
            else:
                sv3file = '/pscratch/sd/i/ioannis/fastspecfit/data/fuji/catalogs/fastspec-fuji-sv3-dark.fits'
                fast, meta, _, _ = read_fastspecfit(fastfile)
    
            indx_fast, indx_lss = geomask.match(fast['TARGETID'], lss['TARGETID'])
            fast = fast[indx_fast]
            meta = meta[indx_fast]
            lss = lss[indx_lss]
            assert(np.all(meta['TARGETID'] == lss['TARGETID']))
    
            write_fastspecfit(fast, meta, outfile=fastfile)
    
            lss.write(lssfile, overwrite=True)
            log.info(f'Wrote {len(lss)} objects to {lssfile}')

def fig_broadline(overwrite=False, png=None):

    import corner as cn
    from fastspecfit.io import read_fastspecfit
    from fastspecfit.io import write_fastspecfit

    sns, colors = plot_style(talk=True, font_scale=0.8)

    # build / read the sample
    ragafile = os.path.join(datadir, 'lowmass-blcandidates.fits')
    raga = Table(fitsio.read(ragafile, ext=1, upper=True)) # from Raga
    raga = raga[(raga['SURVEY'] == 'sv1')*(raga['PROGRAM'] == 'bright')]
    print('Read {} objects from {}'.format(len(raga), ragafile))

    fastfile = os.path.join(datadir, 'fastspec-fuji-lowmass-blcandidates.fits')
    if os.path.isfile(fastfile):
        fast, meta, _, _ = read_fastspecfit(fastfile)
    else:
        fast, meta = [], []
        for survey in set(raga['SURVEY']):
            J = np.where(survey == raga['SURVEY'])[0]
            for program in set(raga['PROGRAM'][J]):
                K = np.where(program == raga['PROGRAM'][J])[0]

                survey = survey.strip()
                program = program.strip()

                fastfile1 = '/pscratch/sd/i/ioannis/fastspecfit/data/fuji/catalogs/'+f'fastspec-fuji-{survey}-{program}.fits'
                #fastfile1 = os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'fastspecfit', 'fuji', 'catalogs', f'fastspec-fuji-{survey}-{program}.fits')
                targetids = fitsio.read(fastfile1, ext='METADATA', columns='TARGETID')
                I = np.where(np.isin(targetids, raga[J][K]['TARGETID']))[0]
                
                fast1, meta1, _, _ = read_fastspecfit(fastfile1, rows=I)
                fast.append(fast1)
                meta.append(meta1)

        fast = vstack(fast)
        meta = vstack(meta)

        I = np.hstack([np.where(meta['TARGETID'] == tid)[0] for tid in raga['TARGETID']])
        fast = fast[I]
        meta = meta[I]
        assert(np.all(meta['TARGETID'] == raga['TARGETID']))

        write_fastspecfit(fast, meta, outfile=fastfile)

    I = fast['HALPHA_BROAD_SIGMA'] > 0
    print(fast['SURVEY', 'PROGRAM', 'HEALPIX', 'TARGETID', 'HALPHA_AMP', 'HALPHA_BROAD_AMP', 'HALPHA_SIGMA', 'HALPHA_BROAD_SIGMA'][I])
    print(raga['SURVEY', 'PROGRAM', 'HEALPIX', 'TARGETID', 'HA_N_AMPLITUDE', 'HA_B_AMPLITUDE', 'HA_N_SIGMA_FITS', 'HA_B_SIGMA_FITS'][I])
    
def fig_vdisp(overwrite=False, png=None):

    import corner as cn
    from fastspecfit.io import read_fastspecfit
    from fastspecfit.io import write_fastspecfit

    sns, colors = plot_style(talk=True, font_scale=0.8)

    # build / read the sample
    fpfile = os.path.join(datadir, 'fuji_FP.fits')
    fp = Table(fitsio.read(fpfile, ext=1, upper=True)) # from Khaled
    log.info('Read {} from {}'.format(len(fp), fpfile))

    fastfile = os.path.join(datadir, 'fastspec-fuji_FP.fits')
    if os.path.isfile(fastfile) and not overwrite:
        fast, meta, _, _ = read_fastspecfit(fastfile)
    else:
        fast, meta = [], []
        for survey in set(fp['SURVEY']):
            J = np.where(survey == fp['SURVEY'])[0]
            for program in set(fp['PROGRAM'][J]):
                K = np.where(program == fp['PROGRAM'][J])[0]

                survey = survey.strip()
                program = program.strip()

                fastfile1 = f'/pscratch/sd/i/ioannis/fastspecfit/data/fuji/catalogs/fastspec-fuji-{survey}-{program}.fits'
                #fastfile1 = os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'fastspecfit', 'fuji', 'catalogs', f'fastspec-fuji-{survey}-{program}.fits')
                targetids = fitsio.read(fastfile1, ext='METADATA', columns='TARGETID')
                I = np.where(np.isin(targetids, fp[J][K]['TARGETID']))[0]
                
                fast1, meta1, _, _ = read_fastspecfit(fastfile1, rows=I)
                fast.append(fast1)
                meta.append(meta1)

        fast = vstack(fast)
        meta = vstack(meta)

        I = np.hstack([np.where(meta['TARGETID'] == tid)[0] for tid in fp['TARGETID']])
        fast = fast[I]
        meta = meta[I]
        assert(np.all(meta['TARGETID'] == fp['TARGETID']))

        write_fastspecfit(fast, meta, outfile=fastfile)

    I = np.where((fast['VDISP'] != 125.) * (fp['PPXF_SIGMA'] / fp['PPXF_SIGMA_ERROR'] > 2))[0]
    #I = np.where(fast['VDISP'] != 125.)[0]
    log.info(len(fast), len(I))
    #I = np.arange(len(fast))
    fast['VDISP_ERR'] = np.zeros(len(fast), 'f4') + 100
    fast['VDISP_ERR'][I] = 1 / np.sqrt(fast['VDISP_IVAR'][I])

    # make the plot
    vdisplim = np.array([75, 325])
    redlim = [0.0, 0.22]
    snrlim = np.log10([1, 150])
    mstarlim = [9.5, 12]
    residlim = np.array([-120, 120])

    col = colors[0]
    levels = [0.5, 0.75, 0.95]
    contour_kwargs = {'colors': col, 'alpha': 0.5}
    data_kwargs = {'color': col, 'alpha': 0.5, 'ms': 4}
    smooth = 1.5

    vresid = fast['VDISP'][I] - fp['PPXF_SIGMA'][I]
    
    #fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 10))
    fig = plt.figure(figsize=(8, 8))
    gs = fig.add_gridspec(nrows=2, ncols=3, height_ratios=[1, 0.4], width_ratios=[0.5, 0.5, 0.5])

    #from sklearn import linear_model
    #ransac = linear_model.RANSACRegressor()
    #ransac.fit((fp['PPXF_SIGMA'][I].data-vdispoff).reshape(len(I), 1), fast['VDISP'][I].data)

    npix = 100
    vdispoff = 200. # [km/s]
    vdispaxis = np.linspace(vdisplim[0], vdisplim[1], npix)

    import statsmodels.api as sm
    rlm = sm.RLM(fast['VDISP'][I].data, sm.add_constant(fp['PPXF_SIGMA'][I].data-vdispoff)).fit()

    #vdispmodel = ransac.predict((vdispaxis-vdispoff).reshape(npix, 1))
    #vcoeff = np.hstack([ransac.estimator_.coef_, ransac.estimator_.intercept_])
    vcoeff = [rlm.params[1], rlm.params[0]]
    vdispmodel = np.polyval(vcoeff, vdispaxis-vdispoff)

    #vcoeff = np.polyfit(fp['PPXF_SIGMA'][I], fast['VDISP'][I], 1)
    log.info(vcoeff)

    bigax = fig.add_subplot(gs[0, :]) # rows x cols

    cn.hist2d(fp['PPXF_SIGMA'][I], fast['VDISP'][I],
              bins=100, color=col, smooth=smooth, levels=levels,
              range=[vdisplim, vdisplim], ax=bigax, contour_kwargs=contour_kwargs,
              data_kwargs=data_kwargs)
    #bigax.errorbar(fp['PPXF_SIGMA'][I], fast['VDISP'][I], xerr=fp['PPXF_SIGMA_ERROR'][I],
    #               yerr=fast['VDISP_ERR'][I], fmt='s', color=colors[1], ecolor=colors[1], 
    #               markersize=1, capthick=2, capsize=1, alpha=0.2)
    txt = r'$\sigma_{{\mathrm{{fastspec}}}} = {:.3f}(\sigma_{{\mathrm{{pPXF}}}}-200) + {:.0f}$ km/s'.format(vcoeff[0], vcoeff[1])
    bigax.plot(vdispaxis, vdispmodel, lw=2, ls='--', color='k', label=txt)
    #bigax.plot(vdispaxis, np.polyval(vcoeff, vdispaxis), lw=2, ls='--', color='k')
    #bigax.scatter(fp['PPXF_SIGMA'][I], fast['VDISP'][I], s=1)
    bigax.plot(vdisplim, vdisplim, color='k', ls='-', alpha=0.6)
    #bigax.plot(vdisplim, vdisplim+10, color='k', ls='--', alpha=0.6)
    bigax.set_xlim(vdisplim)
    bigax.set_ylim(vdisplim)
    bigax.legend(loc='lower right', frameon=False, fontsize=11)
    bigax.set_xlabel(r'$\sigma$ [pPXF, km/s]')
    bigax.set_ylabel(r'$\sigma$ [fastspec, km/s]')

    ax1 = fig.add_subplot(gs[1, 0]) # rows x cols
    cn.hist2d(fast['Z'][I], vresid, 
              bins=100, color=col, smooth=smooth, levels=levels,
              range=[redlim, residlim], ax=ax1,
              contour_kwargs=contour_kwargs, data_kwargs=data_kwargs)
    #ax1.scatter(fast['Z'][I], vresid, s=1)
    ax1.axhline(y=0, color='k', ls='-')
    ax1.set_xlim(redlim)
    ax1.set_ylim(residlim)
    ax1.set_ylabel(r'$\Delta\sigma$ (km/s)')
    ax1.set_xlabel('Redshift')

    ax2 = fig.add_subplot(gs[1, 1])
    cn.hist2d(fast['LOGMSTAR'][I], vresid, 
              bins=100, color=col, smooth=smooth, levels=levels,
              range=[mstarlim, residlim], ax=ax2,
              contour_kwargs=contour_kwargs, data_kwargs=data_kwargs)
    #ax2.scatter(fast['LOGMSTAR'][I], vresid, s=1)
    ax2.axhline(y=0, color='k', ls='-')
    ax2.set_xlim(mstarlim)
    ax2.set_ylim(residlim)
    ax2.set_yticklabels([])
    ax2.set_xlabel(r'$\log_{10} (M/M_{\odot})$')

    ax3 = fig.add_subplot(gs[1, 2])
    cn.hist2d(np.log10(fast['SNR_B'][I]), vresid, 
              bins=100, color=col, smooth=smooth, levels=levels,
              range=[snrlim, residlim], ax=ax3,
              contour_kwargs=contour_kwargs, data_kwargs=data_kwargs)
    #ax3.scatter(fast['SNR_B'][I], vresid, s=1)
    ax3.axhline(y=0, color='k', ls='-')
    #ax3.set_xscale('log')
    ax3.xaxis.set_major_formatter(major_formatter)    
    ax3.set_xlim(snrlim)
    ax3.set_ylim(residlim)
    ax3.set_yticklabels([])
    ax3.set_xlabel(r'$S/N_{b}$ (pixel$^{-1}$)')

    if png:
        pngfile = os.path.join(figdir, png)
        log.info('Writing {}'.format(pngfile))
        #fig.subplots_adjust(bottom=0.15, right=0.85, top=0.95)
        fig.tight_layout()
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def read_clustering():
    """Read the matched clustering files.

    """
    from fastspecfit.io import read_fastspecfit

    data = {}
    for targtype in ['BGS_ANY', 'LRG', 'ELG']:        
        fastfile = os.path.join(datadir, 'clustering', f'fastspec-clustering-{targtype}.fits')
        if not os.path.isfile(fastfile):
            log.info(f'{fastfile} not found.')
        else:
            fast, meta, _, _ = read_fastspecfit(fastfile)
            lssfile = os.path.join(datadir, 'clustering', f'lss-clustering-{targtype}.fits')
            lss = Table(fitsio.read(lssfile))
            log.info(f'Read {len(lss)} objects from {lssfile}')
            data[targtype] = {'fast': fast, 'meta': meta, 'lss': lss}
            
    return data     

def fig_mstar(overwrite=False, png=None):
    """Build the stellar mass figures."""

    sns, colors = plot_style(talk=True, font_scale=0.8)

    data = read_clustering()
    if not bool(data):
        return
        
    fig, ax = plt.subplots()
    ax.scatter(data['BGS_ANY']['fast']['Z'], data['BGS_ANY']['fast']['LOGMSTAR'], s=1)
    ax.scatter(data['LRG']['fast']['Z'], data['LRG']['fast']['LOGMSTAR'], s=1)
    ax.scatter(data['ELG']['fast']['Z'], data['ELG']['fast']['LOGMSTAR'], s=1)

    if png:
        pngfile = os.path.join(figdir, png)
        log.info('Writing {}'.format(pngfile))
        #fig.subplots_adjust(bottom=0.15, right=0.85, top=0.95)
        fig.tight_layout()
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_example_spectra(png=None):
    """Illustrate our emission-line measurements.

    """
    from scipy.ndimage import gaussian_filter
    from matplotlib.patches import Rectangle, ConnectionPatch
    from desispec.io import read_spectra
    from desispec.coaddition import coadd_cameras    
    from fastspecfit.io import read_fastspecfit
    from fastspecfit.util import C_LIGHT
    from fastspecfit.emlines import read_emlines
        
    sns, colors = plot_style(talk=True, font_scale=0.8)

    survey, program, healpix, targetid = 'sv1', 'dark', 8140, 39633560344201268

    exampledir = os.path.join(datadir, 'example-spectra')
    specfile = os.path.join(exampledir, f'coadd-{survey}-{program}-{healpix}-{targetid}.fits')
    fastfile = os.path.join(exampledir, f'fastspec-{survey}-{program}-{healpix}-{targetid}.fits')

    spec = read_spectra(specfile)
    coadd = coadd_cameras(spec)
    fast, meta, _, _, models = read_fastspecfit(fastfile, read_models=True)

    hdr = fitsio.read_header(fastfile, ext='MODELS')
    modelwave = hdr['CRVAL1'] + np.arange(hdr['NAXIS1']) * hdr['CDELT1']

    continuum = models[0, 0, :]
    smooth_continuum = models[0, 1, :]
    emlinemodel = models[0, 2, :]

    emlinewave = coadd.wave['brz']
    assert(np.all(np.isclose(modelwave, emlinewave)))
    
    specflux = coadd.flux['brz'][0, :]
    emlineflux = specflux - continuum - smooth_continuum
    specflux_nolines = specflux - emlinemodel

    #specflux = gaussian_filter(specflux, 2)
    #specflux_nolines = gaussian_filter(specflux_nolines, 2)

    linetable = read_emlines()

    nsigma = 3.
    redshift = fast['Z']

    linenames = ['OII_3729', 'OIII_5007', 'HALPHA', 'SII_6716']

    fig = plt.figure(figsize=(10, 8))
    gs = fig.add_gridspec(3, 4, height_ratios=[0.6, 0.2, 0.2]) # nrows, ncols

    specax = fig.add_subplot(gs[0, :])

    #specax.plot(emlinewave, gaussian_filter(specflux, 2))
    for icam, cam in enumerate(spec.bands):
        specax.plot(spec.wave[cam], gaussian_filter(spec.flux[cam].flat, 2))

    specax.margins(x=0)
    specax.set_ylabel(r'$F_{\lambda}\ (10^{-17}~{\rm erg}~{\rm s}^{-1}~{\rm cm}^{-2}~\AA^{-1})$')

    for iline, linename in enumerate(linenames):

        oneline = linetable[linetable['name'] == linename.lower()]
    
        linez = redshift + fast['{}_VSHIFT'.format(linename)][0] / C_LIGHT
        linezwave = oneline['restwave'] * (1 + linez)
        linesigma = fast['{}_SIGMA'.format(linename)][0]   # [km/s]
        amp = fast['{}_AMP'.format(linename)][0] 
        cont = fast['{}_CONT'.format(linename)][0]
        cont_sigma = 1. / np.sqrt(fast['{}_CONT_IVAR'.format(linename)][0])   # [km/s]

        linesigma_ang = linesigma * linezwave / C_LIGHT # [observed-frame Angstrom]
        linesigma_ang_window = linesigma_ang
    
        lineindx = np.where((emlinewave >= (linezwave - nsigma*linesigma_ang_window)) *
                            (emlinewave <= (linezwave + nsigma*linesigma_ang_window)))[0]
    
        indxlo = np.where((emlinewave > (linezwave - 10*linesigma_ang_window)) *
                          (emlinewave < (linezwave - 3.*linesigma_ang_window)))[0]
        indxhi = np.where((emlinewave < (linezwave + 10*linesigma_ang_window)) *
                          (emlinewave > (linezwave + 3.*linesigma_ang_window)))[0]
        indx = np.hstack((indxlo, indxhi))
    
        _indx = np.arange(indx[-1]-indx[0])+indx[0]

        plotindx = np.where((emlinewave >= (linezwave - 15*linesigma_ang_window)) *
                            (emlinewave <= (linezwave + 15*linesigma_ang_window)))[0]

        xx = fig.add_subplot(gs[1, iline])
        xx.plot(emlinewave[plotindx], emlineflux[plotindx])
        xx.plot(modelwave[plotindx], emlinemodel[plotindx])
        xx.axvline(x=emlinewave[lineindx[0]], color='blue', ls='--')
        xx.axvline(x=emlinewave[lineindx[-1]], color='blue', ls='--')
        xx.set_ylim(-0.5, np.max(emlinemodel[_indx])*1.2)
        xx.margins(0)
        xx.set_xticks([])

        xlim = xx.get_xlim()
        ylim = xx.get_ylim()

        xx.add_artist(ConnectionPatch(xyA=(xlim[0], ylim[1]), xyB=(xlim[0], cont-cont_sigma), 
                                      coordsA='data', coordsB='data', alpha=0.5,
                                      axesA=xx, axesB=specax, color='k'))
        xx.add_artist(ConnectionPatch(xyA=(xlim[1], ylim[1]), xyB=(xlim[1], cont-cont_sigma), 
                                      coordsA='data', coordsB='data', alpha=0.5,
                                      axesA=xx, axesB=specax, color='k'))
        specax.add_artist(Rectangle((xlim[0], cont-2*cont_sigma), np.ptp(xlim), amp,
                                    fill=False, color='k', alpha=0.5))

        # continuum plots
        xx = fig.add_subplot(gs[2, iline])
        xx.plot(emlinewave[plotindx], specflux_nolines[plotindx])
        xx.scatter(emlinewave[indxlo], specflux_nolines[indxlo], color='red', marker='s')
        xx.scatter(emlinewave[indxhi], specflux_nolines[indxhi], color='red', marker='s')
        xx.axhline(y=cont, color='k', ls='-')
        xx.axhline(y=cont+cont_sigma, color='k', ls='--')
        xx.axhline(y=cont-cont_sigma, color='k', ls='--')

    if png:
        pngfile = os.path.join(figdir, png)
        log.info('Writing {}'.format(pngfile))
        fig.subplots_adjust(left=0.11, bottom=0.1, right=0.95, top=0.95, hspace=0.25, wspace=0.25)
        #fig.tight_layout()
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def _smooth_continuum(wave, flux, ivar, redshift, medbin=150, 
                      smooth_window=50, smooth_step=10, maskkms_uv=3000.0, 
                      maskkms_balmer=1000.0, maskkms_narrow=200.0,
                      linetable=None, emlinesfile=None, linemask=None, png=None,
                      log=None, verbose=False):
    """Build a smooth, nonparametric continuum spectrum.

    Parameters
    ----------
    wave : :class:`numpy.ndarray` [npix]
        Observed-frame wavelength array.
    flux : :class:`numpy.ndarray` [npix]
        Spectrum corresponding to `wave`.
    ivar : :class:`numpy.ndarray` [npix]
        Inverse variance spectrum corresponding to `flux`.
    redshift : :class:`float`
        Object redshift.
    medbin : :class:`int`, optional, defaults to 150 pixels
        Width of the median-smoothing kernel in pixels; a magic number.
    smooth_window : :class:`int`, optional, defaults to 50 pixels
        Width of the sliding window used to compute the iteratively clipped
        statistics (mean, median, sigma); a magic number. Note: the nominal
        extraction width (0.8 A) and observed-frame wavelength range
        (3600-9800 A) corresponds to pixels that are 66-24 km/s. So
        `smooth_window` of 50 corresponds to 3300-1200 km/s, which is
        conservative for all but the broadest lines. A magic number. 
    smooth_step : :class:`int`, optional, defaults to 10 pixels
        Width of the step size when computing smoothed statistics; a magic
        number.
    maskkms_uv : :class:`float`, optional, defaults to 3000 km/s
        Masking width for UV emission lines. Pixels within +/-3*maskkms_uv
        are masked before median-smoothing.
    maskkms_balmer : :class:`float`, optional, defaults to 3000 km/s
        Like `maskkms_uv` but for Balmer lines.
    maskkms_narrow : :class:`float`, optional, defaults to 300 km/s
        Like `maskkms_uv` but for narrow, forbidden lines.
    linemask : :class:`numpy.ndarray` of type :class:`bool`, optional, defaults to `None`
        Boolean mask with the same number of pixels as `wave` where `True`
        means a pixel is (possibly) affected by an emission line
        (specifically a strong line which likely cannot be median-smoothed).
    png : :class:`str`, optional, defaults to `None`
        Generate a simple QA plot and write it out to this filename.

    Returns
    -------
    smooth :class:`numpy.ndarray` [npix]
        Smooth continuum spectrum which can be subtracted from `flux` in
        order to create a pure emission-line spectrum.
    smoothsigma :class:`numpy.ndarray` [npix]
        Smooth one-sigma uncertainty spectrum.

    """
    from numpy.lib.stride_tricks import sliding_window_view
    from scipy.ndimage import median_filter
    from scipy.stats import sigmaclip
    #from astropy.stats import sigma_clip

    if log is None:
        from desiutil.log import get_logger, DEBUG
        if verbose:
            log = get_logger(DEBUG)
        else:
            log = get_logger()

    if linetable is None:
        from fastspecfit.emlines import read_emlines        
        linetable = read_emlines(emlinesfile=emlinesfile)
        
    npix = len(wave)

    # If we're not given a linemask, make a conservative one.
    if linemask is None:
        linemask = np.zeros(npix, bool) # True = (possibly) affected by emission line

        nsig = 3

        # select just strong lines
        zlinewaves = linetable['restwave'] * (1 + redshift)
        inrange = (zlinewaves > np.min(wave)) * (zlinewaves < np.max(wave))
        if np.sum(inrange) > 0:
            linetable = linetable[inrange]
            linetable = linetable[linetable['amp'] >= 1]
            if len(linetable) > 0:
                for oneline in linetable:
                    zlinewave = oneline['restwave'] * (1 + redshift)
                    if oneline['isbroad']:
                        if oneline['isbalmer']:
                            sigma = maskkms_balmer
                        else:
                            sigma = maskkms_uv
                    else:
                        sigma = maskkms_narrow
                
                    sigma *= zlinewave / C_LIGHT # [km/s --> Angstrom]
                    I = (wave >= (zlinewave - nsig*sigma)) * (wave <= (zlinewave + nsig*sigma))
                    if len(I) > 0:
                        linemask[I] = True

        # Special: mask Ly-a (1215 A)
        zlinewave = 1215.0 * (1 + redshift)
        if (zlinewave > np.min(wave)) * (zlinewave < np.max(wave)):
            sigma = maskkms_uv * zlinewave / C_LIGHT # [km/s --> Angstrom]
            I = (wave >= (zlinewave - nsig*sigma)) * (wave <= (zlinewave + nsig*sigma))
            if len(I) > 0:
                linemask[I] = True

    if len(linemask) != npix:
        errmsg = 'Linemask must have the same number of pixels as the input spectrum.'
        log.critical(errmsg)
        raise ValueError(errmsg)

    # Build the smooth (line-free) continuum by computing statistics in a
    # sliding window, accounting for masked pixels and trying to be smart
    # about broad lines. See:
    #   https://stackoverflow.com/questions/41851044/python-median-filter-for-1d-numpy-array
    #   https://numpy.org/devdocs/reference/generated/numpy.lib.stride_tricks.sliding_window_view.html
    
    wave_win = sliding_window_view(wave, window_shape=smooth_window)
    flux_win = sliding_window_view(flux, window_shape=smooth_window)
    ivar_win = sliding_window_view(ivar, window_shape=smooth_window)
    noline_win = sliding_window_view(np.logical_not(linemask), window_shape=smooth_window)

    nminpix = 15

    smooth_wave, smooth_flux, smooth_sigma, smooth_mask = [], [], [], []
    for swave, sflux, sivar, noline in zip(wave_win[::smooth_step],
                                           flux_win[::smooth_step],
                                           ivar_win[::smooth_step],
                                           noline_win[::smooth_step]):

        # if there are fewer than XX good pixels after accounting for the
        # line-mask, skip this window.
        sflux = sflux[noline]
        if len(sflux) < nminpix:
            smooth_mask.append(True)
            continue
        swave = swave[noline]
        sivar = sivar[noline]

        cflux, _, _ = sigmaclip(sflux, low=2.0, high=2.0)
        if len(cflux) < nminpix:
            smooth_mask.append(True)
            continue

        # Toss out regions with too little good data.
        if np.sum(sivar > 0) < nminpix:
            smooth_mask.append(True)
            continue

        I = np.isin(sflux, cflux) # fragile?
        sig = np.std(cflux) # simple median and sigma
        mn = np.median(cflux)

        #if png and mn < -1:# and np.mean(swave[I]) > 7600:
        #    print(np.mean(swave[I]), mn)

        # One more check for crummy spectral regions.
        if mn == 0.0:
            smooth_mask.append(True)
            continue

        smooth_wave.append(np.mean(swave[I]))
        smooth_mask.append(False)

        ## astropy is too slow!!
        #cflux = sigma_clip(sflux, sigma=2.0, cenfunc='median', stdfunc='std', masked=False, grow=1.5)
        #if np.sum(np.isfinite(cflux)) < 10:
        #    smooth_mask.append(True)
        #    continue
        #I = np.isfinite(cflux) # should never be fully masked!
        #smooth_wave.append(np.mean(swave[I]))
        #smooth_mask.append(False)
        #sig = np.std(cflux[I])
        #mn = np.median(cflux[I])

        ## inverse-variance weighted mean and sigma
        #norm = np.sum(sivar[I])
        #mn = np.sum(sivar[I] * cflux[I]) / norm # weighted mean
        #sig = np.sqrt(np.sum(sivar[I] * (cflux[I] - mn)**2) / norm) # weighted sigma

        smooth_sigma.append(sig)
        smooth_flux.append(mn)

    smooth_mask = np.array(smooth_mask)
    smooth_wave = np.array(smooth_wave)
    smooth_sigma = np.array(smooth_sigma)
    smooth_flux = np.array(smooth_flux)

    # For debugging.
    if png:
        _smooth_wave = smooth_wave.copy()
        _smooth_flux = smooth_flux.copy()

    # corner case for very wacky spectra
    if len(smooth_flux) == 0:
        smooth_flux = flux
        smooth_sigma = flux * 0 + np.std(flux)
    else:
        smooth_flux = np.interp(wave, smooth_wave, smooth_flux)
        smooth_sigma = np.interp(wave, smooth_wave, smooth_sigma)

    smooth = median_filter(smooth_flux, medbin, mode='nearest')
    smoothsigma = median_filter(smooth_sigma, medbin, mode='nearest')

    Z = (flux == 0.0) * (ivar == 0.0)
    if np.sum(Z) > 0:
        smooth[Z] = 0.0

    # Optional QA.
    if png:
        import matplotlib.pyplot as plt

        minwave, maxwave = 5000, 9000
        I = (wave > minwave) * (wave < maxwave)

        fig, ax = plt.subplots(2, 1, figsize=(8, 10), sharex=True)
        ax[0].plot(wave[I], flux[I], alpha=0.5, color='gray')
        ax[0].scatter(wave[linemask], flux[linemask], s=10, marker='s', color='k', alpha=0.7)#, zorder=2)
        #ax[0].plot(wave, smooth, color='orange')
        ax[0].scatter(_smooth_wave, _smooth_flux, color='red', s=50, marker='s')
        #ax[0].scatter(_smooth_wave, _smooth_flux, color='orange', marker='s', ls='-', s=20)

        ax[1].plot(wave[I], flux[I] - smooth[I], color='gray', alpha=0.5)
        ax[1].axhline(y=0, color='k', lw=2)

        for xx in ax:
            xx.set_xlim(minwave, maxwave)
        #for xx in ax:
        #    xx.set_ylim(-2.5, 2)

        zlinewaves = linetable['restwave'] * (1 + redshift)
        linenames = linetable['name']
        inrange = np.where((zlinewaves > np.min(wave)) * (zlinewaves < np.max(wave)))[0]
        if len(inrange) > 0:
            for linename, zlinewave in zip(linenames[inrange], zlinewaves[inrange]):
                #print(linename, zlinewave)
                for xx in ax:
                    xx.axvline(x=zlinewave, color='gray')

        fig.savefig(png)

    return smooth, smoothsigma
    
def _smooth_continuum2(wave, flux, ivar, redshift, medbin=150, 
                       smooth_window=50, smooth_step=20, maskkms_uv=3000.0, 
                       maskkms_balmer=1000.0, maskkms_narrow=200.0,
                       linetable=None, emlinesfile=None, linemask=None, png=None,
                       log=None, verbose=False):
    """Build a smooth, nonparametric continuum spectrum.

    Parameters
    ----------
    wave : :class:`numpy.ndarray` [npix]
        Observed-frame wavelength array.
    flux : :class:`numpy.ndarray` [npix]
        Spectrum corresponding to `wave`.
    ivar : :class:`numpy.ndarray` [npix]
        Inverse variance spectrum corresponding to `flux`.
    redshift : :class:`float`
        Object redshift.
    medbin : :class:`int`, optional, defaults to 150 pixels
        Width of the median-smoothing kernel in pixels; a magic number.
    smooth_window : :class:`int`, optional, defaults to 50 pixels
        Width of the sliding window used to compute the iteratively clipped
        statistics (mean, median, sigma); a magic number. Note: the nominal
        extraction width (0.8 A) and observed-frame wavelength range
        (3600-9800 A) corresponds to pixels that are 66-24 km/s. So
        `smooth_window` of 50 corresponds to 3300-1200 km/s, which is
        conservative for all but the broadest lines. A magic number. 
    smooth_step : :class:`int`, optional, defaults to 10 pixels
        Width of the step size when computing smoothed statistics; a magic
        number.
    maskkms_uv : :class:`float`, optional, defaults to 3000 km/s
        Masking width for UV emission lines. Pixels within +/-3*maskkms_uv
        are masked before median-smoothing.
    maskkms_balmer : :class:`float`, optional, defaults to 3000 km/s
        Like `maskkms_uv` but for Balmer lines.
    maskkms_narrow : :class:`float`, optional, defaults to 300 km/s
        Like `maskkms_uv` but for narrow, forbidden lines.
    linemask : :class:`numpy.ndarray` of type :class:`bool`, optional, defaults to `None`
        Boolean mask with the same number of pixels as `wave` where `True`
        means a pixel is (possibly) affected by an emission line
        (specifically a strong line which likely cannot be median-smoothed).
    png : :class:`str`, optional, defaults to `None`
        Generate a simple QA plot and write it out to this filename.

    Returns
    -------
    smooth :class:`numpy.ndarray` [npix]
        Smooth continuum spectrum which can be subtracted from `flux` in
        order to create a pure emission-line spectrum.
    smoothsigma :class:`numpy.ndarray` [npix]
        Smooth one-sigma uncertainty spectrum.

    """
    from numpy.lib.stride_tricks import sliding_window_view
    from scipy.ndimage import median_filter
    from scipy.stats import sigmaclip
    #from astropy.stats import sigma_clip

    if log is None:
        from desiutil.log import get_logger, DEBUG
        if verbose:
            log = get_logger(DEBUG)
        else:
            log = get_logger()

    if linetable is None:
        from fastspecfit.emlines import read_emlines        
        linetable = read_emlines(emlinesfile=emlinesfile)
        
    npix = len(wave)

    # If we're not given a linemask, make a conservative one.
    if linemask is None:
        linemask = np.zeros(npix, bool) # True = (possibly) affected by emission line

        nsig = 3

        # select just strong lines
        zlinewaves = linetable['restwave'] * (1 + redshift)
        inrange = (zlinewaves > np.min(wave)) * (zlinewaves < np.max(wave))
        if np.sum(inrange) > 0:
            linetable = linetable[inrange]
            linetable = linetable[linetable['amp'] >= 1]
            if len(linetable) > 0:
                for oneline in linetable:
                    zlinewave = oneline['restwave'] * (1 + redshift)
                    if oneline['isbroad']:
                        if oneline['isbalmer']:
                            sigma = maskkms_balmer
                        else:
                            sigma = maskkms_uv
                    else:
                        sigma = maskkms_narrow
                
                    sigma *= zlinewave / C_LIGHT # [km/s --> Angstrom]
                    I = (wave >= (zlinewave - nsig*sigma)) * (wave <= (zlinewave + nsig*sigma))
                    if len(I) > 0:
                        linemask[I] = True

        # Special: mask Ly-a (1215 A)
        zlinewave = 1215.0 * (1 + redshift)
        if (zlinewave > np.min(wave)) * (zlinewave < np.max(wave)):
            sigma = maskkms_uv * zlinewave / C_LIGHT # [km/s --> Angstrom]
            I = (wave >= (zlinewave - nsig*sigma)) * (wave <= (zlinewave + nsig*sigma))
            if len(I) > 0:
                linemask[I] = True

    if len(linemask) != npix:
        errmsg = 'Linemask must have the same number of pixels as the input spectrum.'
        log.critical(errmsg)
        raise ValueError(errmsg)

    # Build the smooth (line-free) continuum by computing statistics in a
    # sliding window, accounting for masked pixels and trying to be smart
    # about broad lines. See:
    #   https://stackoverflow.com/questions/41851044/python-median-filter-for-1d-numpy-array
    #   https://numpy.org/devdocs/reference/generated/numpy.lib.stride_tricks.sliding_window_view.html
    
    wave_win = sliding_window_view(wave, window_shape=smooth_window)
    flux_win = sliding_window_view(flux, window_shape=smooth_window)
    ivar_win = sliding_window_view(ivar, window_shape=smooth_window)
    noline_win = sliding_window_view(np.logical_not(linemask), window_shape=smooth_window)

    nminpix = 15

    smooth_wave, smooth_flux, smooth_sigma, smooth_mask = [], [], [], []
    for swave, sflux, sivar, noline in zip(wave_win[::smooth_step],
                                           flux_win[::smooth_step],
                                           ivar_win[::smooth_step],
                                           noline_win[::smooth_step]):

        # if there are fewer than XX good pixels after accounting for the
        # line-mask, skip this window.
        sflux = sflux[noline]
        if len(sflux) < nminpix:
            smooth_mask.append(True)
            continue
        swave = swave[noline]
        sivar = sivar[noline]

        cflux, _, _ = sigmaclip(sflux, low=2.0, high=2.0)
        if len(cflux) < nminpix:
            smooth_mask.append(True)
            continue

        # Toss out regions with too little good data.
        if np.sum(sivar > 0) < nminpix:
            smooth_mask.append(True)
            continue

        I = np.isin(sflux, cflux) # fragile?
        sig = np.std(cflux) # simple median and sigma
        mn = np.median(cflux)

        #if png and mn < -1:# and np.mean(swave[I]) > 7600:
        #    print(np.mean(swave[I]), mn)

        # One more check for crummy spectral regions.
        if mn == 0.0:
            smooth_mask.append(True)
            continue

        smooth_wave.append(np.mean(swave[I]))
        smooth_mask.append(False)

        ## astropy is too slow!!
        #cflux = sigma_clip(sflux, sigma=2.0, cenfunc='median', stdfunc='std', masked=False, grow=1.5)
        #if np.sum(np.isfinite(cflux)) < 10:
        #    smooth_mask.append(True)
        #    continue
        #I = np.isfinite(cflux) # should never be fully masked!
        #smooth_wave.append(np.mean(swave[I]))
        #smooth_mask.append(False)
        #sig = np.std(cflux[I])
        #mn = np.median(cflux[I])

        ## inverse-variance weighted mean and sigma
        #norm = np.sum(sivar[I])
        #mn = np.sum(sivar[I] * cflux[I]) / norm # weighted mean
        #sig = np.sqrt(np.sum(sivar[I] * (cflux[I] - mn)**2) / norm) # weighted sigma

        smooth_sigma.append(sig)
        smooth_flux.append(mn)

    smooth_mask = np.array(smooth_mask)
    smooth_wave = np.array(smooth_wave)
    smooth_sigma = np.array(smooth_sigma)
    smooth_flux = np.array(smooth_flux)

    # For debugging.
    if png:
        _smooth_wave = smooth_wave.copy()
        _smooth_flux = smooth_flux.copy()

    # corner case for very wacky spectra
    if len(smooth_flux) == 0:
        smooth_flux = flux
        smooth_sigma = flux * 0 + np.std(flux)
    else:
        from scipy.interpolate import make_interp_spline
        srt = np.argsort(smooth_wave)
        bspl_flux = make_interp_spline(smooth_wave[srt], smooth_flux[srt], k=1)
        smooth_flux = bspl_flux(wave)

        bspl_sigma = make_interp_spline(smooth_wave[srt], smooth_sigma[srt], k=1)
        smooth_sigma = bspl_sigma(wave)
        #pdb.set_trace()
        #smooth_flux = np.interp(wave, smooth_wave, smooth_flux)
        #smooth_sigma = np.interp(wave, smooth_wave, smooth_sigma)

    if False:
        smooth = smooth_flux
        smoothsigma = smooth_sigma
    else:
        smooth = median_filter(smooth_flux, medbin, mode='nearest')
        smoothsigma = median_filter(smooth_sigma, medbin, mode='nearest')

    Z = (flux == 0.0) * (ivar == 0.0)
    if np.sum(Z) > 0:
        smooth[Z] = 0.0

    # Optional QA.
    if png:
        import matplotlib.pyplot as plt

        minwave, maxwave = wave.min(), wave.max() # 5000, 9000
        I = (wave > minwave) * (wave < maxwave)

        fig, ax = plt.subplots(2, 1, figsize=(8, 10), sharex=True)
        ax[0].plot(wave[I], flux[I], alpha=0.5, color='gray')
        ax[0].scatter(wave[linemask], flux[linemask], s=10, marker='s', color='k', alpha=0.7)#, zorder=2)
        ax[0].plot(wave, smooth, color='orange')
        #ax[0].scatter(_smooth_wave, _smooth_flux, color='red', s=5, marker='s')
        #ax[0].scatter(_smooth_wave, _smooth_flux, color='orange', marker='s', ls='-', s=20)

        ax[1].plot(wave[I], flux[I] - smooth[I], color='gray', alpha=0.5)
        ax[1].axhline(y=0, color='k', lw=2)

        for xx in ax:
            xx.set_xlim(minwave, maxwave)
        #for xx in ax:
        #    xx.set_ylim(-2.5, 2)

        zlinewaves = linetable['restwave'] * (1 + redshift)
        linenames = linetable['name']
        inrange = np.where((zlinewaves > np.min(wave)) * (zlinewaves < np.max(wave)))[0]
        if len(inrange) > 0:
            for linename, zlinewave in zip(linenames[inrange], zlinewaves[inrange]):
                #print(linename, zlinewave)
                for xx in ax:
                    xx.axvline(x=zlinewave, color='gray')

        fig.savefig(png)

    return smooth, smoothsigma
    
def smooth_continuum():

    from scipy.ndimage import gaussian_filter
    from desispec.io import read_spectra
    from desispec.coaddition import coadd_cameras    
    from fastspecfit.io import read_fastspecfit, DESISpectra
    #from fastspecfit.continuum import _smooth_continuum
    from fastspecfit.io import cache_templates, get_templates_filename
    from fastspecfit.continuum import ContinuumTools

    survey, program, healpix, targetid = 'sv1', 'dark', 7610, 39633483106093315

    exampledir = os.path.join(datadir, 'example-spectra')
    redfile = os.path.join(exampledir, f'redrock-{survey}-{program}-{healpix}-{targetid}.fits')
    specfile = os.path.join(exampledir, f'coadd-{survey}-{program}-{healpix}-{targetid}.fits')
    fastfile = os.path.join(exampledir, f'fastspec-{survey}-{program}-{healpix}-{targetid}.fits')

    Spec = DESISpectra()
    Spec.select(redfile)
    data = Spec.read_and_unpack()
    data = data[0]

    specwave = np.hstack(data['wave'])
    specflux = np.hstack(data['flux'])
    specivar = np.hstack(data['ivar']) * np.logical_not(np.hstack(data['linemask'])) # mask emission lines

    #spec = read_spectra(specfile)
    #coadd = coadd_cameras(spec)
    #wave = np.hstack([coadd.wave[cam] for cam in coadd.bands])
    #flux = np.hstack([coadd.flux[cam].flatten() for cam in coadd.bands])
    #ivar = np.hstack([coadd.ivar[cam].flatten() for cam in coadd.bands])

    fast, meta, _, _, models = read_fastspecfit(fastfile, read_models=True)

    redshift = fast['Z'][0]
    use_vdisp = fast['VDISP'][0]
    coeff = fast['COEFF'].flatten()

    #hdr = fitsio.read_header(fastfile, ext='MODELS')
    #modelwave = hdr['CRVAL1'] + np.arange(hdr['NAXIS1']) * hdr['CDELT1']
    #continuum = models[0, 0, :]
    #smooth_continuum = models[0, 1, :]
    #emlinemodel = models[0, 2, :]

    templates = get_templates_filename()
    templatecache = cache_templates(templates, mintemplatewave=450.0, maxtemplatewave=40e4)
    CTools = ContinuumTools(continuum_pixkms=templatecache['continuum_pixkms'],
                            pixkms_wavesplit=templatecache['pixkms_wavesplit'])

    input_templateflux_nolines = templatecache['templateflux_nolines']

    desitemplates_nolines, _ = CTools.templates2data(
        input_templateflux_nolines, templatecache['templatewave'], redshift=redshift,
        dluminosity=data['dluminosity'],
        specwave=data['wave'], specres=data['res'], specmask=data['mask'], 
        vdisp=use_vdisp, cameras=data['cameras'], stack_cameras=True, 
        synthphot=False)

    desimodel_nolines = desitemplates_nolines.dot(coeff)    

    residuals = specflux - desimodel_nolines
    linemask = np.hstack(data['linemask'])

    smooth, smoothsigma = _smooth_continuum2(specwave, residuals, specivar, redshift=redshift, 
                                             linemask=linemask, png='smooth.png')

    pdb.set_trace()

    minwave, maxwave = 8400, 8500
    I = (specwave > minwave) * (specwave < maxwave)

    #fig, ax = plt.subplots()
    #ax.plot(specwave, 1 / np.sqrt(specivar))
    #ax.plot(specwave, smoothsigma)
    #fig.tight_layout()
    #fig.savefig('smooth.png')

    fig, ax = plt.subplots()
    ax.plot(specwave, gaussian_filter(specflux, 0))
    ax.plot(specwave, gaussian_filter(desimodel_nolines, 0))
    ax.plot(specwave, gaussian_filter(desimodel_nolines+smooth, 0))
    ax.plot(specwave, gaussian_filter(smooth, 0))
    ax.set_ylim(-0.2, 1.5)
    fig.tight_layout()
    fig.savefig('smooth.png')

def main():

    import argparse    

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--vdisp', action='store_true', help='Velocity dispersion comparison.')
    parser.add_argument('--mstar', action='store_true', help='Stellar mass plots.')
    parser.add_argument('--broadline', action='store_true', help='Compare with Ragas broad-line fitting.')
    parser.add_argument('--compare-zouhu', action='store_true', help='Compare with the zouhu VAC.')    
    parser.add_argument('--example-spectra', action='store_true', help='Build the example spectra figures.')

    parser.add_argument('--smooth-continuum', action='store_true')

    parser.add_argument('--match-lss', action='store_true', help='Match to the LSS catalogs (no figures, just catalogs).')
    parser.add_argument('--build-example-spectra', action='store_true', help='Build example spectra (no figures, just catalogs).')

    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing QA files.')
    args = parser.parse_args()

    # testing
    if args.smooth_continuum:
        smooth_continuum()

    # data below here
    if args.build_example_spectra:
        build_example_spectra(overwrite=args.overwrite)

    if args.match_lss:
        match_lss(overwrite=args.overwrite)

    # figures below here
    if args.example_spectra:
        fig_example_spectra(png='example-emissionline.png')
        
    if args.compare_zouhu:
        compare_zouhu()

    if args.mstar:
        fig_mstar(png='mstar.png')

    if args.vdisp:
        fig_vdisp(overwrite=args.overwrite, png='ppxf-vdisp.png')

    if args.broadline:
        fig_broadline(overwrite=args.overwrite, png='broadline.png')

if __name__ == '__main__':
   main()

