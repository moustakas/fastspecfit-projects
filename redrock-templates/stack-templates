#!/usr/bin/env python

"""Generate templates from stacks.

time $HOME/code/desihub/fastspecfit-projects/redrock-templates/stack-templates --build-parent
time $HOME/code/desihub/fastspecfit-projects/redrock-templates/stack-templates --qa-parent
time $HOME/code/desihub/fastspecfit-projects/redrock-templates/stack-templates --build-stacks
time $HOME/code/desihub/fastspecfit-projects/redrock-templates/stack-templates --fastspec-stacks

"""
import os, time, pdb
import numpy as np
import fitsio
from glob import glob
from astropy.table import Table, Column, hstack, vstack, join
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

from fastspecfit.util import C_LIGHT, trapz_rebin

from desiutil.log import get_logger
log = get_logger()

import seaborn as sns
sns.set(context='talk', style='ticks', font_scale=0.9, palette='Set2')
#sns.set(context='talk', style='ticks', palette='deep', font_scale=font_scale)#, rc=rc)
colors = sns.color_palette()

desi_root = os.getenv('DESI_ROOT')
specprod_root = os.path.join(os.getenv('DESI_ROOT_READONLY'), 'spectro', 'redux')

projectdir = os.path.join(desi_root, 'users', 'ioannis', 'fastspecfit', 'redrock-templates')
datadir = os.path.join(projectdir, 'data')
stacksdir = os.path.join(projectdir, 'stacks')
qadir = os.path.join(stacksdir, 'qa')

def get_zlims(lss_specprod, targetclass=None):
    if lss_specprod == 'fuji':
        zlims = {'BGS': [0.01, 0.6], 'LRG': [0.4, 1.1], 'ELG': [0.6, 1.6]}
    elif lss_specprod == 'iron':
        zlims = {'BGS': [0.01, 0.5], 'LRG': [0.4, 1.1], 'ELG_LOPnotqso': [0.8, 1.6]}
    else:
        raise NotImplemented
    if targetclass:
        zlims = zlims[targetclass]
    return zlims


def stacking_bins(targetclass='LRG', verbose=False):

    # define the stacking limits and the number of bin *centers*

    if targetclass == 'LRG':
        zlim, nz = [0.4, 1.1], 7
        mstarlim, nmstar = [10.5, 12.], 6 # Mstar
        colorlim, ncolor = [-0.2, 1.8], 5 # r-W1
    elif targetclass == 'ELG':
        zlim, nz = [0.7, 1.5], 8
        mstarlim, nmstar = [8., 11.5], 8  # Mstar
        colorlim, ncolor = [-0.1, 0.7], 4 # g-r
    elif targetclass == 'BGS':
        zlim, nz = [0.05, 0.55], 10
        mstarlim, nmstar = [8., 12.], 6  # Mstar
        colorlim, ncolor = [0.0, 1.2], 6 # g-r
    else:
        raise NotImplemented
        
    dz = (zlim[1] - zlim[0]) / nz
    dmstar = (mstarlim[1] - mstarlim[0]) / nmstar
    dcolor = (colorlim[1] - colorlim[0]) / ncolor

    # build the array of (left) bin *edges*
    zgrid = np.arange(zlim[0], zlim[1], dz)
    mstargrid = np.arange(mstarlim[0], mstarlim[1], dmstar)
    colorgrid = np.arange(colorlim[0], colorlim[1], dcolor)

    nbins = len(zgrid) * len(mstargrid) * len(colorgrid)

    # pack into a table
    bins = Table()
    #bins.add_column(Column(name='TARGETCLASS', dtype='U3', length=nbins))
    bins.add_column(Column(name='IBIN', dtype=np.int32, length=nbins))
    #bins.add_column(Column(name='ISUBBIN', dtype=np.int16, length=nbins))
    bins.add_column(Column(name='NALLOBJ', dtype=np.int32, length=nbins))
    bins.add_column(Column(name='NOBJ', dtype=np.int32, length=nbins))
    bins.add_column(Column(name='SNR', dtype='f4', length=nbins))
    for col in ('ZOBJ', 'MSTAR', 'COLOR'):
        bins.add_column(Column(name=col, dtype='f4', length=nbins)) # mean bin center
        bins.add_column(Column(name=f'{col}MIN', dtype='f4', length=nbins))
        bins.add_column(Column(name=f'{col}MAX', dtype='f4', length=nbins))
        
    #bins['TARGETCLASS'] = targetclass
    bins['IBIN'] = np.arange(nbins, dtype=np.int32)

    ibin = 0
    for zmin in zgrid:
        for mstarmin in mstargrid:
            for colormin in colorgrid:
                for col, mmin, delt in zip(('ZOBJ', 'MSTAR', 'COLOR'),
                                           (zmin, mstarmin, colormin),
                                           (dz, dmstar, dcolor)):
                    bins[col][ibin] = mmin + delt / 2             # bin center
                    bins[f'{col}MIN'][ibin] = mmin        # left edge
                    bins[f'{col}MAX'][ibin] = mmin + delt # right edge
                ibin += 1

    if verbose:
        log.info(f'Number of {targetclass} bins = {bins}')

    return bins


def build_parent_sample(targetclass, specprod='iron', lss_specprod='fuji', 
                        zobj_minmax=None, mstar_minmax=None, color_minmax=None,
                        return_indices=False, outfile=None):
    """Read the output of redrock-templates --match-lss to build the sample.

    """
    from fastspecfit.io import read_fastspecfit, write_fastspecfit
    
    lsstype = 'clustering'

    outfile = os.path.join(stacksdir, f'parent-{targetclass}.fits')
    if targetclass == 'BGS':
        _targetclass = 'BGS_ANY'
    else:
        _targetclass = targetclass
    
    fastfile = os.path.join(datadir, f'fastspec-{specprod}-{lsstype}-{_targetclass}.fits')
    if not os.path.isfile(fastfile):
        log.info(f'{fastfile} not found.')
    else:
        fast, meta, _, _ = read_fastspecfit(fastfile)

    zmin, zmax = get_zlims(lss_specprod, targetclass=targetclass)

    iparent = (
        (meta['Z'] > zmin) * 
        (meta['Z'] < zmax) *
        (meta['SPECTYPE'] == 'GALAXY') *
        (fast['LOGMSTAR'] > 0) * 
        (meta['FLUX_G'] > 0) * 
        (meta['FLUX_R'] > 0) * 
        (meta['FLUX_Z'] > 0) * 
        (meta['FLUX_W1'] > 0) #*
        #(meta['DELTACHI2'] > deltachi2_cut) * 
        #(spec['CONTINUUM_CHI2'] < fastspec_chi2cut) *
        #(phot['CONTINUUM_CHI2'] < fastphot_chi2cut) 
        #(np.abs(spec['CONTINUUM_SMOOTHCORR_B']) < smoothcorr_cut) *
        #(np.abs(spec['CONTINUUM_SMOOTHCORR_R']) < smoothcorr_cut) *
        #(np.abs(spec['CONTINUUM_SMOOTHCORR_Z']) < smoothcorr_cut)
    )
    iselect = iparent

    #if zobj_minmax is not None and absmag_minmax is not None and color_minmax is not None:
    #
    #    props = SAMPLE_PROPERTIES[targetclass]
    #    absmagcol = 'ABSMAG_{}'.format(props['absmag_band'])
    #    color = phot['ABSMAG_{}'.format(props['color_band1'])] - phot['ABSMAG_{}'.format(props['color_band2'])]
    #    
    #    iselect = iparent * (
    #        (meta['Z'] > zobj_minmax[0]) * (meta['Z'] < zobj_minmax[1]) *
    #        (phot[absmagcol] > absmag_minmax[0]) * (phot[absmagcol] < absmag_minmax[1]) *
    #        (color > color_minmax[0]) * (color < color_minmax[1]) )
    #else:
    #    iselect = iparent

    log.info(f'Selecting a parent sample of {np.sum(iselect):,d}/{len(meta):,d} {targetclass.upper()}s.')

    # write out
    write_fastspecfit(fast[iselect], meta[iselect], outfile=outfile, verbose=True)


def qa_parent(targetclass, specprod='iron', lss_specprod='fuji'):
    """QA of the observed- and rest-frame photometry.

    """
    from fastspecfit.io import read_fastspecfit    
    from matplotlib.patches import Rectangle    
    from matplotlib.colors import LogNorm

    cmap = plt.cm.get_cmap('twilight')
    #cmap = plt.cm.get_cmap('RdYlBu')
    mincnt = 1

    #data = read_clustering(targetclass=targetclass, specprod=specprod,
    #                       lss_specprod=lss_specprod,
    #                       read_lss=False, trim_broad=False)
    #fast, meta, = data[targetclass]['fast'], data[targetclass]['meta']

    fastfile = os.path.join(stacksdir, f'parent-{targetclass}.fits')    
    fast, meta, _, _ = read_fastspecfit(fastfile)

    bins  = stacking_bins(targetclass, verbose=True)
    
    def bgs_obs(meta, png=None):
        robslim = (14, 21.0)
        grobslim = (-0.3, 2.5)
        rzobslim = (-0.5, 1.5)

        gmag = 22.5 - 2.5 * np.log10(meta['FLUX_G'])
        rmag = 22.5 - 2.5 * np.log10(meta['FLUX_R'])
        zmag = 22.5 - 2.5 * np.log10(meta['FLUX_Z'])

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5), sharey=True)

        ax1.hexbin(rmag-zmag, gmag-rmag,
                   mincnt=mincnt, bins='log', cmap=cmap,
                   #C=cat['weight'], reduce_C_function=np.sum
                   extent=np.hstack((rzobslim, grobslim)))
        ax1.set_xlabel(r'$(r - z)_{\rm obs}$')
        ax1.set_ylabel(r'$(g - r)_{\rm obs}$')
        ax1.set_xlim(rzobslim)
        ax1.set_ylim(grobslim)

        hb = ax2.hexbin(rmag, gmag-rmag, 
                        mincnt=mincnt, bins='log', cmap=cmap,
                        #C=cat['weight'], reduce_C_function=np.sum,
                        extent=np.hstack((robslim, grobslim)))
        ax2.set_xlabel(r'$r_{\rm obs}$')
        ax2.set_ylim(grobslim)
        ax2.set_xlim(robslim)

        cax = fig.add_axes([0.88, 0.12, 0.02, 0.83])
        formatter = ticker.LogFormatter(10, labelOnlyBase=False)
        fig.colorbar(hb, cax=cax, format=formatter, label='Number of Galaxies')

        for aa in (ax1, ax2):
            aa.grid(True)

        plt.subplots_adjust(left=0.12, top=0.95, right=0.85, bottom=0.19, wspace=0.07)

        if png:
            pngfile = os.path.join(qadir, png)
            log.info(f'Writing {pngfile}')
            fig.savefig(pngfile)
            plt.close()
            
    def bgs_rest(phot, bins=None, png=None):
        zlim = (-0.02, 0.62)
        mstarlim = (7., 12.5)
        grlim = (-0.25, 1.3)

        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(14, 10))

        ax1.hexbin(phot['Z'], phot['LOGMSTAR'], 
                   mincnt=mincnt, bins='log', cmap=cmap,
                   #C=cat['weight'], reduce_C_function=np.sum,
                   extent=np.hstack((zlim, mstarlim)))
        ax1.set_ylim(mstarlim)
        ax1.set_xlim(zlim)
        ax1.set_xlabel('Redshift')
        ax1.set_ylabel(r'$\log_{10}\,(M/M_{\odot})$')
        #ax1.set_ylabel(r'$M_{0.1r}$')
        #ax1.xaxis.set_major_locator(ticker.MultipleLocator(0.2))        

        if bins:
            dx, dy = bins['ZOBJMAX'][0]-bins['ZOBJMIN'][0], bins['MSTARMAX'][0]-bins['MSTARMIN'][0]
            [ax1.add_patch(Rectangle((xx, yy), dx, dy, facecolor='none', edgecolor='k'))
             for xx, yy in zip(bins['ZOBJMIN'], bins['MSTARMIN'])]

        ax2.hexbin(phot['Z'], phot['ABSMAG01_SDSS_G']-phot['ABSMAG01_SDSS_R'], 
                   mincnt=mincnt, bins='log', cmap=cmap,
                   #C=cat['weight'], reduce_C_function=np.sum,
                   extent=np.hstack((zlim, grlim)))
        ax2.set_xlim(zlim)
        ax2.set_ylim(grlim)
        ax2.set_xlabel('Redshift')
        ax2.set_ylabel(r'$^{0.1}(g - r)$')#, labelpad=-10)
        #ax2.xaxis.set_major_locator(ticker.MultipleLocator(0.2))        
        #ax2.yaxis.set_major_locator(ticker.MultipleLocator(0.5))        

        if bins:
            dx, dy = bins['ZOBJMAX'][0]-bins['ZOBJMIN'][0], bins['COLORMAX'][0]-bins['COLORMIN'][0]
            [ax2.add_patch(Rectangle((xx, yy), dx, dy, facecolor='none', edgecolor='k'))
             for xx, yy in zip(bins['ZOBJMIN'], bins['COLORMIN'])]

        hb = ax3.hexbin(phot['LOGMSTAR'], phot['ABSMAG01_SDSS_G']-phot['ABSMAG01_SDSS_R'], 
                        mincnt=mincnt, bins='log', cmap=cmap,
                        #C=cat['weight'], reduce_C_function=np.sum,
                        extent=np.hstack((mstarlim, grlim)))
        ax3.set_xlabel(r'$\log_{10}\,(M/M_{\odot})$')
        ax3.set_ylabel(r'$^{0.1}(g - r)$')#, labelpad=-10)
        ax3.set_xlim(mstarlim)
        ax3.set_ylim(grlim)
        #ax3.yaxis.set_major_locator(ticker.MultipleLocator(0.5))        

        if bins:
            dx, dy = bins['MSTARMAX'][0]-bins['MSTARMIN'][0], bins['COLORMAX'][0]-bins['COLORMIN'][0]
            [ax3.add_patch(Rectangle((xx, yy), dx, dy, facecolor='none', edgecolor='k'))
             for xx, yy in zip(bins['MSTARMIN'], bins['COLORMIN'])]
            
        ax4.axis('off')

        cax = fig.add_axes([0.49, 0.12, 0.02, 0.36])
        #cax = fig.add_axes([0.54, 0.4, 0.35, 0.03])
        formatter = ticker.LogFormatter(10, labelOnlyBase=False)
        fig.colorbar(hb, format=formatter, label='Number of Galaxies',
                     cax=cax)#, orientation='horizontal')

        for aa in (ax1, ax2, ax3):
            aa.grid(True)

        plt.subplots_adjust(left=0.1, top=0.95, wspace=0.3, hspace=0.3, right=0.88, bottom=0.13)

        if png:
            pngfile = os.path.join(qadir, png)
            log.info(f'Writing {pngfile}')
            fig.savefig(pngfile)
            plt.close()

    def elg_obs(meta, png=None):
        gobslim = (20., 24.)
        grobslim = (-1.2, 0.8)
        rzobslim = (-0.3, 2.3)

        gmag = 22.5 - 2.5 * np.log10(meta['FLUX_G'])
        rmag = 22.5 - 2.5 * np.log10(meta['FLUX_R'])
        zmag = 22.5 - 2.5 * np.log10(meta['FLUX_Z'])

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5), sharey=True)

        ax1.hexbin(rmag-zmag, gmag-rmag, 
                   mincnt=mincnt, bins='log', cmap=cmap,
                   #C=cat['weight'], reduce_C_function=np.sum,
                   extent=np.hstack((rzobslim, grobslim)))
        ax1.set_xlabel(r'$(r - z)_{\rm obs}$')
        ax1.set_ylabel(r'$(g - r)_{\rm obs}$')
        ax1.set_xlim(rzobslim)
        ax1.set_ylim(grobslim)

        hb = ax2.hexbin(gmag, gmag-rmag,
                        mincnt=mincnt, bins='log', cmap=cmap,
                        #C=cat['weight'], reduce_C_function=np.sum,
                        extent=np.hstack((gobslim, grobslim)))
        ax2.set_xlabel(r'$g_{\rm obs}$')
        ax2.set_ylim(grobslim)
        ax2.set_xlim(gobslim)
        ax1.yaxis.set_major_locator(ticker.MultipleLocator(0.5))
        
        cax = fig.add_axes([0.88, 0.12, 0.02, 0.83])
        formatter = ticker.LogFormatter(10, labelOnlyBase=False)
        fig.colorbar(hb, cax=cax, format=formatter, label='Number of Galaxies')

        for aa in (ax1, ax2):
            aa.grid(True)

        plt.subplots_adjust(left=0.12, top=0.95, right=0.85, bottom=0.19, wspace=0.07)

        if png:
            pngfile = os.path.join(qadir, png)
            log.info(f'Writing {pngfile}')
            fig.savefig(pngfile)
            plt.close()
            
    def elg_rest(phot, bins=None, png=None):
        zlim = (0.5, 1.7)
        mstarlim = (7., 12.5)
        grlim = (-0.3, 0.8)

        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(14, 10))

        ax1.hexbin(phot['Z'], phot['LOGMSTAR'], 
                   mincnt=mincnt, bins='log', cmap=cmap,
                   #C=cat['weight'], reduce_C_function=np.sum,
                   extent=np.hstack((zlim, mstarlim)))
        ax1.set_ylim(mstarlim)
        ax1.set_xlim(zlim)
        ax1.set_xlabel('Redshift')
        ax1.set_ylabel(r'$\log_{10}\,(M/M_{\odot})$')
        ax1.xaxis.set_major_locator(ticker.MultipleLocator(0.2))        

        if bins:
            dx, dy = bins['ZOBJMAX'][0]-bins['ZOBJMIN'][0], bins['MSTARMAX'][0]-bins['MSTARMIN'][0]
            [ax1.add_patch(Rectangle((xx, yy), dx, dy, facecolor='none', edgecolor='k'))
             for xx, yy in zip(bins['ZOBJMIN'], bins['MSTARMIN'])]

        ax2.hexbin(phot['Z'], phot['ABSMAG01_SDSS_G']-phot['ABSMAG01_SDSS_R'], 
                   mincnt=mincnt, bins='log', cmap=cmap,
                   #C=cat['weight'], reduce_C_function=np.sum,
                   extent=np.hstack((zlim, grlim)))
        ax2.set_xlim(zlim)
        ax2.set_ylim(grlim)
        ax2.set_xlabel('Redshift')
        ax2.set_ylabel(r'$^{0.1}(g - r)$', labelpad=-10)
        ax2.xaxis.set_major_locator(ticker.MultipleLocator(0.2))        
        ax2.yaxis.set_major_locator(ticker.MultipleLocator(0.2))

        if bins:
            dx, dy = bins['ZOBJMAX'][0]-bins['ZOBJMIN'][0], bins['COLORMAX'][0]-bins['COLORMIN'][0]
            [ax2.add_patch(Rectangle((xx, yy), dx, dy, facecolor='none', edgecolor='k'))
             for xx, yy in zip(bins['ZOBJMIN'], bins['COLORMIN'])]

        hb = ax3.hexbin(phot['LOGMSTAR'], phot['ABSMAG01_SDSS_G']-phot['ABSMAG01_SDSS_R'], 
                        mincnt=mincnt, bins='log', cmap=cmap,
                        #C=cat['weight'], reduce_C_function=np.sum,
                        extent=np.hstack((mstarlim, grlim)))
        ax3.set_xlabel(r'$\log_{10}\,(M/M_{\odot})$')
        ax3.set_ylabel(r'$^{0.1}(g - r)$', labelpad=-10)
        ax3.set_xlim(mstarlim)
        ax3.set_ylim(grlim)
        ax3.yaxis.set_major_locator(ticker.MultipleLocator(0.2))

        if bins:
            dx, dy = bins['MSTARMAX'][0]-bins['MSTARMIN'][0], bins['COLORMAX'][0]-bins['COLORMIN'][0]
            [ax3.add_patch(Rectangle((xx, yy), dx, dy, facecolor='none', edgecolor='k'))
             for xx, yy in zip(bins['MSTARMIN'], bins['COLORMIN'])]
            
        ax4.axis('off')

        cax = fig.add_axes([0.49, 0.12, 0.02, 0.36])
        #cax = fig.add_axes([0.54, 0.4, 0.35, 0.03])
        formatter = ticker.LogFormatter(10, labelOnlyBase=False)
        fig.colorbar(hb, format=formatter, label='Number of Galaxies',
                     cax=cax)#, orientation='horizontal')

        for aa in (ax1, ax2, ax3):
            aa.grid(True)

        plt.subplots_adjust(left=0.1, top=0.95, wspace=0.3, hspace=0.3, right=0.88, bottom=0.13)

        if png:
            pngfile = os.path.join(qadir, png)
            log.info(f'Writing {pngfile}')
            fig.savefig(pngfile)
            plt.close()

    def lrg_obs(meta, png=None):
        zobslim = (16, 22)
        W1obslim = (16, 20.5)
        grobslim = (0.0, 4)
        rzobslim = (0.0, 3)
        rW1obslim = (0.7, 4.5)
        zW1obslim = (0, 2.7)

        gmag = 22.5 - 2.5 * np.log10(meta['FLUX_G'])
        rmag = 22.5 - 2.5 * np.log10(meta['FLUX_R'])
        zmag = 22.5 - 2.5 * np.log10(meta['FLUX_Z'])
        W1mag = 22.5 - 2.5 * np.log10(meta['FLUX_W1'])

        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(14, 10))

        ax1.hexbin(rmag-W1mag, gmag-rmag, 
                   mincnt=mincnt, bins='log', cmap=cmap,
                   #C=cat['weight'], reduce_C_function=np.sum,
                   #norm=LogNorm(vmin=1, vmax=100),
                   extent=np.hstack((rW1obslim, grobslim)))
        ax1.set_xlabel(r'$(r - W1)_{\rm obs}$')
        ax1.set_ylabel(r'$(g - r)_{\rm obs}$')
        ax1.set_xlim(rW1obslim)
        ax1.set_ylim(grobslim)

        ax2.hexbin(zmag-W1mag, rmag-zmag, 
                   mincnt=mincnt, bins='log', cmap=cmap,
                   #C=cat['weight'], reduce_C_function=np.sum,
                   extent=np.hstack((zW1obslim, rzobslim)))

        ax2.set_ylabel(r'$(r - z)_{\rm obs}$')
        ax2.set_xlabel(r'$(z - W1)_{\rm obs}$')
        ax2.set_xlim(zW1obslim)
        ax2.set_ylim(rzobslim)
        ax2.xaxis.set_major_locator(ticker.MultipleLocator(1))
        ax2.yaxis.set_major_locator(ticker.MultipleLocator(1))
        
        ax3.hexbin(zmag, rmag-zmag, 
                   mincnt=mincnt, bins='log', cmap=cmap,
                   #C=cat['weight'], reduce_C_function=np.sum,
                   extent=np.hstack((zobslim, rzobslim)))
        ax3.set_ylabel(r'$(r - z)_{\rm obs}$')
        ax3.set_xlabel(r'$z_{\rm obs}$')
        ax3.set_xlim(zobslim)
        ax3.set_ylim(rzobslim)
        ax3.yaxis.set_major_locator(ticker.MultipleLocator(1))

        hb = ax4.hexbin(W1mag, zmag-W1mag,
                        mincnt=mincnt, bins='log', cmap=cmap,
                        #C=cat['weight'], reduce_C_function=np.sum,
                        extent=np.hstack((W1obslim, zW1obslim)))
        ax4.set_ylabel(r'$(z - W1)_{\rm obs}$')
        ax4.set_xlabel(r'$W1_{\rm obs}$')
        ax4.set_xlim(W1obslim)
        ax4.set_ylim(zW1obslim)
        ax4.yaxis.set_major_locator(ticker.MultipleLocator(1))

        cax = fig.add_axes([0.88, 0.12, 0.02, 0.83])
        formatter = ticker.LogFormatter(10, labelOnlyBase=False) 
        cb = fig.colorbar(hb, cax=cax, label='Number of Galaxies',
                          format=formatter)#, ticks=[1, 10, 50])

        for aa in (ax1, ax2, ax3, ax4):
            aa.grid(True)

        plt.subplots_adjust(left=0.1, top=0.95, wspace=0.25, hspace=0.32, right=0.85, bottom=0.13)

        if png:
            pngfile = os.path.join(qadir, png)
            log.info(f'Writing {pngfile}')
            fig.savefig(pngfile)
            plt.close()

    def lrg_rest(phot, bins=None, png=None):
        zlim = (0.3, 1.2)
        mstarlim = (10.25, 12.25)
        rW1lim = (-1., 2.8)

        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(14, 10))

        ax1.hexbin(phot['Z'], phot['LOGMSTAR'], 
                   mincnt=mincnt, bins='log', cmap=cmap,
                   #C=cat['weight'], reduce_C_function=np.sum,
                   extent=np.hstack((zlim, mstarlim)))
        ax1.set_ylim(mstarlim)
        ax1.set_xlim(zlim)
        ax1.set_xlabel('Redshift')
        ax1.set_ylabel(r'$\log_{10}\,(M/M_{\odot})$')
        ax1.yaxis.set_major_locator(ticker.MultipleLocator(0.5))
        
        if bins:
            dx, dy = bins['ZOBJMAX'][0]-bins['ZOBJMIN'][0], bins['MSTARMAX'][0]-bins['MSTARMIN'][0]
            [ax1.add_patch(Rectangle((xx, yy), dx, dy, facecolor='none', edgecolor='k'))
             for xx, yy in zip(bins['ZOBJMIN'], bins['MSTARMIN'])]

        ax2.hexbin(phot['Z'], phot['ABSMAG01_SDSS_R']-phot['ABSMAG01_W1'], 
                   mincnt=mincnt, bins='log', cmap=cmap,
                   #C=cat['weight'], reduce_C_function=np.sum,
                   extent=np.hstack((zlim, rW1lim)))
        ax2.set_xlabel('Redshift')
        ax2.set_ylabel(r'$^{0.1}(r - W1)$')
        ax2.set_ylim(rW1lim)
        ax2.set_xlim(zlim)

        if bins:
            dx, dy = bins['ZOBJMAX'][0]-bins['ZOBJMIN'][0], bins['COLORMAX'][0]-bins['COLORMIN'][0]
            [ax2.add_patch(Rectangle((xx, yy), dx, dy, facecolor='none', edgecolor='k'))
             for xx, yy in zip(bins['ZOBJMIN'], bins['COLORMIN'])]

        hb = ax3.hexbin(phot['LOGMSTAR'], phot['ABSMAG01_SDSS_R']-phot['ABSMAG01_W1'],
                        mincnt=mincnt, bins='log', cmap=cmap,
                        #C=cat['weight'], reduce_C_function=np.sum,
                        extent=np.hstack((mstarlim, rW1lim)))
        ax3.set_xlabel(r'$\log_{10}\,(M/M_{\odot})$')
        ax3.set_ylabel(r'$^{0.1}(r - W1)$')
        ax3.set_xlim(mstarlim)
        ax3.set_ylim(rW1lim)

        if bins:
            dx, dy = bins['MSTARMAX'][0]-bins['MSTARMIN'][0], bins['COLORMAX'][0]-bins['COLORMIN'][0]
            [ax3.add_patch(Rectangle((xx, yy), dx, dy, facecolor='none', edgecolor='k'))
             for xx, yy in zip(bins['MSTARMIN'], bins['COLORMIN'])]

        ax4.axis('off')
        
        cax = fig.add_axes([0.49, 0.12, 0.02, 0.36])
        formatter = ticker.LogFormatter(10, labelOnlyBase=False) 
        fig.colorbar(hb, cax=cax, format=formatter, label='Number of Galaxies')

        for aa in (ax1, ax2, ax3):
            aa.grid(True)

        plt.subplots_adjust(left=0.1, top=0.95, wspace=0.3, hspace=0.3, right=0.88, bottom=0.13)
        
        if png:
            pngfile = os.path.join(qadir, png)
            log.info(f'Writing {pngfile}')
            fig.savefig(pngfile)
            plt.close()
            
    # make the plots!
    png_obs = f'{targetclass}-stacks-obs.png'
    png_rest = f'{targetclass}-stacks-rest.png'
    png_rest_bins = f'{targetclass}-stacks-rest-bins.png'
    if targetclass == 'LRG':
        lrg_obs(meta, png=png_obs)
        lrg_rest(fast, png=png_rest)    
        lrg_rest(fast, bins=bins, png=png_rest_bins)
    elif targetclass == 'ELG':
        elg_obs(meta, png=png_obs)            
        elg_rest(fast, png=png_rest)    
        elg_rest(fast, bins=bins, png=png_rest_bins)
    elif targetclass == 'BGS':
        bgs_obs(meta, png=png_obs)
        bgs_rest(fast, png=png_rest)
        bgs_rest(fast, bins=bins, png=png_rest_bins)


def fastspec_stacks(targetclass='BGS', mp=1, select_broad=False):
    """Run fastspec on the stacks.

    fastqa /global/cfs/cdirs/desi/users/ioannis/fastspecfit/redrock-templates/stacks/fastspec-stacks-LRG.fits \
      --redrockfiles /global/cfs/cdirs/desi/users/ioannis/fastspecfit/redrock-templates/stacks/stacks-LRG.fits --ntargets 1 --firsttarget 30 -o ioannis/tmp --stackfit

    """
    from fastspecfit.fastspecfit import stackfit

    if select_broad:
        stackfile = os.path.join(stacksdir, f'stacks-{targetclass}-broad.fits')
        fastfile = os.path.join(stacksdir, f'fastspec-stacks-{targetclass}-broad.fits')
    else:
        stackfile = os.path.join(stacksdir, f'stacks-{targetclass}.fits')
        fastfile = os.path.join(stacksdir, f'fastspec-stacks-{targetclass}.fits')
    
    cmdargs = f'{stackfile} -o {fastfile} --mp {mp}'
    stackfit(args=cmdargs.split())


def stacks_in_bins(targetclass='BGS', minperbin=3, maxperbin=None, seed=1,
                   specprod='iron', lss_specprod='fuji', mp=1, select_broad=False,
                   normwave=None, verbose=False, overwrite=False):
    """Select objects in bins of rest-frame properties.

    fastphot_in_bins - also stack the fastphot continuum-fitting results
    
    """
    import warnings
    from desispec.spectra import stack as stack_Spectra
    from desispec.io.spectra import read_spectra
    from desigal import specutils
    from fastspecfit.io import read_fastspecfit

    rand = np.random.default_rng(seed=seed)

    # build the rest-frame wavelength vector
    zmin, zmax = get_zlims(lss_specprod, targetclass=targetclass)

    normwaves = {'BGS': [5475., 5525.], 'LRG': [4475., 4525.], 'ELG': [3475., 3525.]}
    norm_flux_window = normwaves[targetclass]

    # rest wavelength vector
    dwave = 0.4
    obswave_min, obswave_max = 3600., 9800.
    restwave = np.arange(obswave_min / (1. + zmax), obswave_max / (1. + zmin), dwave)
    npix = len(restwave)

    bins = stacking_bins(targetclass, verbose=False)
    nbins = len(bins)

    fastfile = os.path.join(stacksdir, f'parent-{targetclass}.fits')
    #fast, meta, _, _ = read_fastspecfit(fastfile)
    #meta = Table(fitsio.read(fastfile, 'METADATA', columns=['SURVEY', 'PROGRAM', 'HEALPIX', 'TARGETID', 'Z'))
    fast = Table(fitsio.read(fastfile, 'FASTSPEC', columns=['SURVEY', 'PROGRAM', 'HEALPIX', 'TARGETID', 'Z',
                                                            'LOGMSTAR', 'ABSMAG01_SDSS_G', 'ABSMAG01_SDSS_R',
                                                            'ABSMAG01_W1', 'BROAD_SIGMA', 'APERCORR']))

    survey, program = fast['SURVEY'][0], fast['PROGRAM'][0] # should be all the same

    if select_broad:
        stackfile = os.path.join(stacksdir, f'stacks-{targetclass}-broad.fits')
    else:
        stackfile = os.path.join(stacksdir, f'stacks-{targetclass}.fits')
        
    if os.path.isfile(fastfile) and not overwrite:
        log.info(f'Output file {stackfile} exists and --overwrite not set.')
        return

    # initialize the output metadata table
    outmeta = bins['IBIN', 'NALLOBJ', 'NOBJ']
    #outmeta['NOBJ'] = np.zeros(len(bins), int) 
    outmeta['STACKID'] = outmeta['IBIN']            # needed by FastSpecFit
    outmeta['Z'] = np.zeros(len(bins), 'f8')        # needed by FastSpecFit (should be all zeros)
    outmeta['ZMED'] = np.zeros(len(bins), 'f4')     # median redshift
    outmeta['LOGMSTAR'] = np.zeros(len(bins), 'f4') # median stellar mass
    outmeta['SNR'] = np.zeros(len(bins), 'f4')      # median S/N

    stackflux = np.zeros((nbins, npix))
    stackivar = np.zeros((nbins, npix))

    for ibin, bin in enumerate(bins):
        log.info(f'Working on bin {ibin+1}/{nbins}')
        if targetclass == 'BGS' or targetclass == 'ELG':
            I = ((fast['Z'] > bin['ZOBJMIN']) * (fast['Z'] < bin['ZOBJMAX']) *
                 (fast['LOGMSTAR'] > bin['MSTARMIN']) * (fast['LOGMSTAR'] < bin['MSTARMAX']) *
                 ((fast['ABSMAG01_SDSS_G']-fast['ABSMAG01_SDSS_R']) > bin['COLORMIN']) *
                 ((fast['ABSMAG01_SDSS_G']-fast['ABSMAG01_SDSS_R']) < bin['COLORMAX']))
        elif targetclass == 'LRG':
            I = ((fast['Z'] > bin['ZOBJMIN']) * (fast['Z'] < bin['ZOBJMAX']) *
                 (fast['LOGMSTAR'] > bin['MSTARMIN']) * (fast['LOGMSTAR'] < bin['MSTARMAX']) *
                 ((fast['ABSMAG01_SDSS_R']-fast['ABSMAG01_W1']) > bin['COLORMIN']) *
                 ((fast['ABSMAG01_SDSS_R']-fast['ABSMAG01_W1']) < bin['COLORMAX']))

        if select_broad:
            I *= (fast['BROAD_SIGMA'] > 0.)
        else:
            I *= (fast['BROAD_SIGMA'] == 0.)
    
        I = np.where(I)[0]

        outmeta['NALLOBJ'][ibin] = len(I)
        if len(I) < minperbin:
            log.info(f'Bin {ibin} has just {len(I)} objects; skipping.')
            continue
        
        if maxperbin is not None and len(I) > maxperbin:
            I = rand.choice(I, size=maxperbin, replace=False)

        outmeta['NOBJ'][ibin] = len(I)

        targetids = fast['TARGETID'][I].data
        redshifts = fast['Z'][I].data
        apercorr = fast['APERCORR'][I].data

        t0 = time.time()
        #log.info(f'Gathering ({len(I):,d}/{outmeta["NALLOBJ"][ibin]:,d} spectra.)')
        os.environ['DESI_LOGLEVEL'] = 'warning'
        spectra = specutils.get_spectra(targetids, release='iron', survey=survey,
                                        program=program, n_workers=mp, use_db=False,
                                        zcat_table=None)
        assert(np.all(spectra.target_ids() == targetids))
        os.environ['DESI_LOGLEVEL'] = 'info'
        log.info(f'Gathering {len(I):,d}/{outmeta["NALLOBJ"][ibin]:,d} spectra took {(time.time()-t0)/1.:.2f} sec.')

        t0 = time.time()
        with warnings.catch_warnings():
            warnings.filterwarnings('ignore')
            (flux, ivar), _ = specutils.stack.stack_spectra(spectra=spectra,
                                                            redshift=redshifts,
                                                            stack_redshift=0.,
                                                            norm_flux_window=norm_flux_window,
                                                            norm_method="flux-window", #"mean", "median", "flux-window"
                                                            resample_method="flux-cons",
                                                            stack_method="ivar-weighted-mean", #median , mean
                                                            output_wave_grid=restwave,
                                                            n_workers=mp,
                                                            #bootstrap=True, bootstrap_samples=50)#,
                                                            multiplication_factor=np.expand_dims(apercorr, axis=-1))
        log.info(f'Stacking {len(redshifts):,d} spectra took {(time.time()-t0)/1.:.2f} sec.')

        igood = np.where(np.isfinite(flux) * np.isfinite(ivar))[0]
        stackflux[ibin, igood] = flux[igood]
        stackivar[ibin, igood] = ivar[igood]

        outmeta['ZMED'][ibin] = np.median(fast['Z'][I])
        outmeta['LOGMSTAR'][ibin] = np.median(fast['LOGMSTAR'][I])
        outmeta['SNR'][ibin] = np.median(flux[igood] * np.sqrt(ivar[igood]))

    # trim to just the populated bins
    I = np.where(outmeta['NOBJ'] > 0)[0]
    stackflux = stackflux[I, :]
    stackivar = stackivar[I, :]
    outmeta = outmeta[I]

    log.info(f'Writing {len(outmeta):,d} stacked spectra to {stackfile}')
    specutils.stack.write_binned_stacks(stackfile, restwave, stackflux, stackivar,
                                        resolution=None, stackinfo=outmeta)

    
def build_redrock_templates(niter=10, ncomp=10, minwave=400., maxwave=1e4, dwave=0.2, nmf=False):
    """Build new templates using either PCA or NMF.

    """
    import redrock
    from astropy.io import fits
    from desispec.resolution import Resolution    
    from fastspecfit.io import cache_templates, get_templates_filename
    from fastspecfit.emlines import EMFitTools
    from fastspecfit.continuum import ContinuumTools    
    
    templatesfile = get_templates_filename()
    templatecache = cache_templates(templatesfile, log=log, mintemplatewave=minwave,
                                    maxtemplatewave=maxwave)
    templatewave = templatecache['templatewave']
    npix = len(templatewave)

    EMFit = EMFitTools()
    CTools = ContinuumTools(ignore_photometry=True)

    flux = []
    for targetclass in ['BGS', 'BGS-broad', 'LRG', 'ELG']:
        fastfile = os.path.join(stacksdir, f'fastspec-stacks-{targetclass}.fits')
        log.info(f'Reading {fastfile}')
        allfast = Table(fitsio.read(fastfile, 'FASTSPEC'))

        stackfile = os.path.join(stacksdir, f'stacks-{targetclass}.fits')
        allwave = fitsio.read(stackfile, 'WAVE')
        allflux = fitsio.read(stackfile, 'FLUX')

        for iobj, fast in enumerate(np.atleast_1d(allfast)):
            continuum, _ = CTools.templates2data(templatecache['templateflux_nolines'],
                                                 templatewave, redshift=0., synthphot=False,
                                                 vdisp=fast['VDISP'], coeff=fast['COEFF'])

            R = Resolution(np.ones((1, npix))) # Hack!
            emspectrum = EMFit.emlinemodel_bestfit([templatewave], [R], fast)[0]
            plt.clf() ; plt.plot(allwave, allflux[iobj, :], color='gray') ; plt.plot(templatewave, continuum+emspectrum, color='k', alpha=0.7) ; plt.savefig('/global/cfs/cdirs/desi/users/ioannis/tmp/junk.png')
            pdb.set_trace()
    
        #flux.append(fitsio.read(templatefile, 'FLUX'))#, rows=np.arange(10)))
        
        pdb.set_trace()
        
    flux = np.vstack(flux) # [ngal, nwave]
    ngal = flux.shape[0]

    if nmf:
        from nearly_nmf.nmf import fit_NMF
        rrmethod = 'NMF'
        pdb.set_trace()
        H, W = fit_NMF(X=flux, V=np.ones_like(flux), n_templates=ncomp)
    else:
        from empca import empca
        rrmethod = 'PCA'
        model = empca(flux, niter=niter, nvec=ncomp)
        
        empca_eigenvec = model.eigvec  # [ncomp, npix]
        empca_eigencoeff = model.coeff # [ngal, ncomp]
        empca_model = empca_eigencoeff.dot(empca_eigenvec)
    
    header = fits.Header()
    header['CRVAL1'] = (minwave, 'restframe starting wavelength [Angstroms]')
    header['CDELT1'] = dwave
    header['RRTYPE']   = 'GALAXY'
    header['RRSUBTYP'] = ''
    header['RRVER'] = redrock.__version__
    header['VERSION'] = ('TBD', 'Template version')
    header['RRIGM'] = 'Inoue14'
    header['RRMETHOD'] = rrmethod
    #header['INSPEC'] = os.environ['DESI_BASIS_TEMPLATES']
    #header['SEED'] = opts.seed
    header['EXTNAME'] = 'BASIS_VECTORS'
    
    hdus = fits.HDUList()
    hdus.append(fits.PrimaryHDU(empca_eigenvec, header=header))
    hdus.append(fits.ImageHDU(empca_eigencoeff, name='ARCHETYPE_COEFF'))
    hdus.writeto(rrtemplatefile, overwrite=True)
    log.info(f'Wrote {rrtemplatefile}')


def main():
    """Main wrapper."""

    import argparse

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--specprod', default='iron', help='Spectroscopic production.')
    parser.add_argument('--lss-specprod', default='fuji', help='Spectroscopic production used for the LSS catalogs.')
    parser.add_argument('--build-parent', action='store_true', help='Build the parent sample.')
    parser.add_argument('--qa-parent', action='store_true', help='QA of the parent sample.')

    parser.add_argument('--build-stacks', action='store_true', help='Build the stacks.')
    parser.add_argument('--fastspec-stacks', action='store_true', help='Run fastspec on the stacks.')

    parser.add_argument('--empca-templates', action='store_true', help='Run empca on the output of --parent-templates.')
    parser.add_argument('--nmf-templates', action='store_true', help='Run NMF on the output of --parent-templates.')

    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing QA files.')    
    args = parser.parse_args()

    # https://docs.nersc.gov/development/languages/python/parallel-python/#use-the-spawn-start-method
    if args.mp > 1 and 'NERSC_HOST' in os.environ:
        import multiprocessing
        multiprocessing.set_start_method('spawn')

    # build the parent sample
    if args.build_parent:
        for targetclass in ['BGS', 'LRG', 'ELG']:
            build_parent_sample(targetclass, specprod=args.specprod, lss_specprod=args.lss_specprod)

    if args.qa_parent:
        for targetclass in ['BGS', 'LRG', 'ELG']:
        #for targetclass in ['ELG']:
            qa_parent(targetclass, specprod=args.specprod, lss_specprod=args.lss_specprod)

    # build the stacks in bins of properties
    if args.build_stacks:
        #for targetclass in ['LRG']:
        #for targetclass, select_broad in zip(['BGS', 'BGS', 'LRG', 'ELG'], [True, False, False, False]):
        #for targetclass, select_broad in zip(['LRG', 'ELG'], [False, False]):
        for targetclass, select_broad in zip(['ELG'], [False]):
            stacks_in_bins(targetclass, specprod=args.specprod, lss_specprod=args.lss_specprod,
                           maxperbin=10, select_broad=select_broad, overwrite=args.overwrite)

    # run fastspec on the stacks
    if args.fastspec_stacks:
        for targetclass, select_broad in zip(['ELG'], [False]):
        #for targetclass, select_broad in zip(['BGS', 'BGS', 'LRG'], [True, False, False]):
        #for targetclass, select_broad in zip(['BGS', 'BGS', 'LRG', 'ELG'], [True, False, False, False]):
            fastspec_stacks(targetclass, select_broad=select_broad, mp=args.mp)

    # build the new PCA Redrock templates
    if args.empca_templates:
        build_redrock_templates()

    # build the new NMF Redrock templates
    if args.nmf_templates:
        build_redrock_templates(nmf=True)

if __name__ == '__main__':
    main()
    
