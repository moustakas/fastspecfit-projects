#!/usr/bin/env python

"""Build new Redrock templates.

Dependencies:
--desi/main
--fastspecfit/main
--empca
--setcoverpy

1. Run fastspec on the desihiz suprime/odin/clauds VI samples and, optionally, generate QA.
  salloc -N 1 -C cpu -A desi -t 04:00:00 --qos interactive
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --desihiz-fastspec --mp 64
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --desihiz-fastspec-qa --ntargets 2 --mp 2

2. Gather the desihiz fastspec results and apply some basic redshift cuts.
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --desihiz-gather-fastspec --mp 48

3. Build the BGS/LRG/ELG parent samples by matching against the LSS samples.
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --match-lss
    /global/cfs/cdirs/desi/spectro/fastspecfit/iron/v2.1/catalogs/fastspec-iron-sv3-{bright,dark}.fits
    /global/cfs/cdirs/desi/survey/catalogs/Y1/LSS/iron/LSScats/v1.1/unblinded/{BGS_ANY,LRG,ELG_LOPnotqso}_{NGC,SGC}_clustering.dat.fits

4. Make some parent QA:
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --parent-qa

5. Build the initial parent (FastSpecFit, rest-frame) templates:
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --desihiz-parent-templates
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --desimain-parent-templates

6. Build the empca (and NMF?) eigentemplates:
  salloc -N 1 -C cpu -A desi -t 00:20:00 --qos interactive
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --empca-templates
  [time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --nmf-templates]

7. Generate QA of the parent templates and the resulting empca eigentemplates:
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --template-qa

8. Gather the {specprod} (iron) Redrock results for the VI tiles and healpixels.
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --gather-specprod-results

9. Run Redrock with a few different priors:
  salloc -N 1 -C gpu --gpus-per-node=4 -A desi -t 04:00:00 --qos interactive
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --run-redrock

  For testing:
    salloc -N 1 -C gpu --gpus-per-node=4 -A desi -t 04:00:00 --qos interactive
    fastspecfit
    export RR_TEMPLATE_DIR=/global/cfs/cdirs/desi/users/ioannis/fastspecfit/redrock-templates/rrtemplates
    rrdesi -i /global/cfs/cdirs/desi/users/ioannis/fastspecfit/redrock-templates/redux/coadd-27247.fits \
      -o /global/cfs/cdirs/desi/users/ioannis/fastspecfit/redrock-templates/redux/redrock-27247.fits \
      -d /global/cfs/cdirs/desi/users/ioannis/fastspecfit/redrock-templates/redux/rrdetails-27247.h5 --gpu --max-gpuprocs=4 --mp 1

10. Gather the Redrock fitting results and build QA:
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --redshift-qa


11. Investigate outliers...
  fastspec /global/cfs/cdirs/desi/spectro/redux/iron/tiles/cumulative/80613/20210324/redrock-2-80613-thru20210324.fits --targetids 39633324615930329 -o fastspec.fits --input-  redshifts 1.9227369195305137
  fastqa fastspec.fits -o ioannis/tmp2

"""
import os, pdb
import numpy as np
import fitsio
from glob import glob
from astropy.table import Table, Column, hstack, vstack, join
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

from desitarget import geomask
from desiutil.log import get_logger
log = get_logger()

from fastspecfit.util import C_LIGHT
from fastspecfit.util import trapz_rebin

import seaborn as sns
sns.set(context='talk', style='ticks', font_scale=0.9, palette='Set2')
#sns.set(context='talk', style='ticks', palette='deep', font_scale=font_scale)#, rc=rc)
colors = sns.color_palette()

desi_root = os.getenv('DESI_ROOT')
projectdir = os.path.join(desi_root, 'users', 'ioannis', 'fastspecfit', 'redrock-templates')
templatedir = os.path.join(projectdir, 'rrtemplates')
fastdir = os.path.join(projectdir, 'fastspec')
datadir = os.path.join(projectdir, 'data')
qadir = os.path.join(projectdir, 'qa')

#tertiary26dir = os.path.join(os.getenv('DESI_ROOT'), 'users', 'raichoor', 'laelbg', 'daily', 'healpix', 'tertiary26-thru20230416-v2')

rrtemplatefile = os.path.join(templatedir, 'rrtemplate-galaxy.fits')

# redshift scan models / priors
zscan_priors = {
    '01': '-0.005,1.7,3e-4',
    '02': '-0.005,4.0,3e-4'
    }

zlims = {
    'BGS-zscan01':    [-0.15, 2.],
    'LRG-zscan01':    [-0.15, 2.],
    'ELG-zscan01':    [-0.15, 5.],
    'QSO-zscan01':    [-0.15, 5.],
    'desihiz-zscan01': [-0.15, 5.],
    'BGS-zscan02':    [-0.15, 4.],
    'LRG-zscan02':    [-0.15, 4.],
    'ELG-zscan02':    [-0.15, 5.],
    'QSO-zscan02':    [-0.15, 5.],
    'desihiz-zscan02': [-0.15, 5.],
    }

# See Lan+23 (Fig 7) and Raichoor+23 (Fig 12)
dchi2dict = {'BGS': 40., 'LRG': 15., 'ELG': 9., 'QSO': None, 'desihiz': 30.}

# from the desihiz project
desihizdir = os.path.join(desi_root, 'users', 'ioannis', 'desihiz')
fspecdirs = {
    'odin': desi_root+'/users/raichoor/laelbg/odin/v20231120/desi-odin.fits[SPECINFO]',
    'clauds': desi_root+'/users/raichoor/laelbg/clauds/v20231120/desi-clauds.fits[SPECINFO]',
    'suprime': desi_root+'/users/raichoor/laelbg/suprime/v20231120/desi-suprime.fits[SPECINFO]',
    }
fphotodirs = {
    'odin': desi_root+'/users/raichoor/laelbg/odin/v20231120/desi-odin.fits[PHOTINFO]',
    'clauds': desi_root+'/users/raichoor/laelbg/clauds/v20231120/desi-clauds.fits[PHOTV2INFO]',
    'suprime': desi_root+'/users/raichoor/laelbg/suprime/v20231120/desi-suprime.fits[PHOTV2INFO]',
    }
fphotofiles = {
    'odin': desihizdir+'/phot/odin-photoinfo.yaml',
    'clauds': desihizdir+'/phot/clauds-photoinfo.yaml',
    'suprime': desihizdir+'/phot/suprime-photoinfo.yaml',
    }

def get_zlims(lss_specprod, targtype=None):
    if lss_specprod == 'fuji':
        zlims = {'BGS_ANY': [0.01, 0.6], 'LRG': [0.4, 1.1], 'ELG': [0.6, 1.6]}
    elif lss_specprod == 'iron':
        zlims = {'BGS_ANY': [0.01, 0.5], 'LRG': [0.4, 1.1], 'ELG_LOPnotqso': [0.8, 1.6]}
    else:
        raise NotImplemented
    if targtype:
        zlims = zlims[targtype]
    return zlims


def get_version(specprod):
    ver = {'fuji': 'v3.2', 'guadalupe': 'v3.1', 'iron': 'v2.1'}
    return ver[specprod]    


def get_vacdir(specprod='fuji', version=None):

    if version is None:
        version = get_version(specprod)

    #if 'NERSC_HOST' in os.environ:
    #    vacdir = '/pscratch/sd/i/ioannis/fastspecfit/vac/data/'+specprod+'/catalogs' # to be updated
    #else:
    #vacdir = os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'fastspecfit', specprod, version, 'catalogs')
    vacdir = os.path.join(os.getenv('PSCRATCH'), 'fastspecfit', specprod, version, 'catalogs')
    log.info(f'VAC dir {vacdir}')

    return vacdir

#def read_vi_tertiary26():
#    """Read the tertiary26 LAE/LBG VI results.
#
#    """
#    from desimodel.footprint import radec2pix    
#        
#    vifile = os.path.join(os.getenv('DESI_ROOT'), 'users', 'ioannis', 'tertiary', 'deep-photometry', 'vi', 'FINAL_VI_Subaru_COSMOS.fits')
#    vi = Table(fitsio.read(vifile))
#    vi.rename_columns(['VI_Z_FINAL', 'VI_QUALITY_FINAL', 'VI_COMMENTS_FINAL'], ['VI_Z', 'VI_QUALITY', 'VI_COMMENTS'])
#    I = np.where(vi['VI_QUALITY'] >=3)[0]
#    #I = (vi['VI_QUALITY'] >=3) * (vi['TERTIARY_TARGET'] == 'LAE_SUBARU ') * (vi['VI_Z'] > 2.4)#1e-3)    
#    log.info(f'Trimming to {len(I):,d}/{len(vi):,d} VI redshifts in {vifile}')
#    vi = vi[I]
#
#    # Now read the 'merge' catalog to figure out which healpixels we care about.
#    mergefile = os.path.join(tertiary26dir, 'merge-tertiary26-thru20230416-v2.fits')
#    mm = Table(fitsio.read(mergefile))
#    log.info(f'Read {len(mm):,d} objects from {mergefile}')
#    mm['HEALPIX'] = radec2pix(nside=64, ra=mm['TARGET_RA'], dec=mm['TARGET_DEC'])
#
#    mm = mm[geomask.match_to(mm['TARGETID'], vi['TARGETID'])]
#    assert(np.all(mm['TARGETID'] == vi['TARGETID']))
#    vi['HEALPIX'] = mm['HEALPIX']
#
#    vi['SUFFIX'] = 'LAELBG'
#    vi['GOOD_LAELBG'] = np.ones(len(vi), bool)
#
#    # assign a spectral type
#    vi['VI_SPECTYPE'] = ['Interloper'] # default
#    
#    I = ['LBG' in comment.upper() for comment in vi['VI_COMMENTS']]
#    vi['VI_SPECTYPE'][I] = 'LBG'
#    
#    I = ['LAE' in comment.upper() for comment in vi['VI_COMMENTS']]
#    vi['VI_SPECTYPE'][I] = 'LAE'
#    
#    I = ['QSO' in comment.upper() for comment in vi['VI_COMMENTS']]
#    vi['VI_SPECTYPE'][I] = 'QSO'
#
#    #I = ['STAR' in comment.upper() for comment in vi['VI_COMMENTS']]
#    #vi['VI_SPECTYPE'][I] = 'STAR'
#    
#    #vi = join(mm, vi, keys='TARGETID')
#
#    return vi


def read_vi(quality=2.5):
    # see https://data.desi.lbl.gov/doc/releases/edr/vac/vi/
    from glob import glob
    #vifiles = glob('/global/cfs/cdirs/desi/public/edr/vac/edr/vi/v1.0/*.csv')
    allvi = []
    for targ in ['BGS', 'LRG', 'ELG', 'QSO']:
        vifile = f'/global/cfs/cdirs/desi/public/edr/vac/edr/vi/v1.0/EDR_VI_{targ}_v1.csv'
        vi = Table.read(vifile)
        vi['SUFFIX'] = targ # os.path.basename(vifile).replace('EDR_VI_', '').replace('_v1.csv', '')
        allvi.append(vi)
    allvi = vstack(allvi)
    I = np.where(allvi['VI_QUALITY'] >= quality)[0]
    log.info(f'Trimming to {len(I):,d}/{len(allvi):,d} VI redshifts.')
    allvi = allvi[I]

    _, uindx = np.unique(allvi['TARGETID'], return_index=True)
    log.info(f'Trimming to {len(uindx):,d}/{len(allvi):,d} unique targets.')
    allvi = allvi[uindx]
    
    return allvi


def parse_fphotodir(fphotodir):
    # parse the extension name, if any
    fphotoext = None
    photodir = os.path.dirname(fphotodir)
    photobase = os.path.basename(fphotodir)
    if '[' in photobase and ']' in photobase:
        try:
            fphotoext = photobase[photobase.find('[')+1:photobase.find(']')]
            fphotodir = os.path.join(photodir, photobase[:photobase.find('[')])
        except:
            pass
    return fphotodir, fphotoext        


def read_desihiz(selection='odin', targetids=None, vi_redshifts=False):

    fspecdir = fspecdirs[selection]
    fphotodir = fphotodirs[selection]

    fspecdir, fspecext = parse_fphotodir(fspecdir)
    fphotobasedir, fphotoext = parse_fphotodir(fphotodir)

    fphoto = Table(fitsio.read(fphotobasedir, ext=fphotoext))
    log.info(f'Read {len(fphoto):,d} objects from {fphotobasedir}')

    fspec = Table(fitsio.read(fspecdir, ext=fspecext))
    log.info(f'Read {len(fspec):,d} objects from {fspecdir}')
    assert(np.all(fspec['TARGETID'] == fphoto['TARGETID']))

    if targetids:
        I = np.where(np.isin(fspec['TARGETID'], np.array(','.split(targetids))))[0]
        log.info(f'Trimming to {len(I):,d} specified TARGETIDs.')
        fphoto = fphoto[I]
        fspec = fspec[I]

    if vi_redshifts:
        #I = np.where(np.isfinite(fspec['VI_Z']) * (fspec['VI_Z'] > 1e-3))[0]
        #log.info(f'Trimming to {len(I):,d} objects with VI_Z>0.001.')
        I = np.where(np.isfinite(fspec['VI_Z']) * (fspec['VI_Z'] > 1e-3) * (fspec['VI_QUALITY'] >= 3.))[0]
        log.info(f'Trimming to {len(I):,d} objects with VI_Z>0.001 and VI_QUALITY>=3.')
        fphoto = fphoto[I]
        fspec = fspec[I]

    return fphoto, fspec


def desihiz_fastspec(mp=1, vi_redshifts=True, nolog=False, overwrite=False):
    """Wrapper to run FastSpecFit on the DESI-II Odin, Suprime, and Clauds samples.

    """
    from desispec.parallel import stdouterr_redirected
    from fastspecfit.fastspecfit import fastspec as fast

    extname = 'FASTSPEC'
    prefix = 'fastspec'
    fits = 'fits.gz'
    if vi_redshifts:
        prefix += '-vi'

    for selection in ['suprime', 'odin', 'clauds']:
        fphoto, fspec = read_desihiz(selection=selection, vi_redshifts=vi_redshifts)
        fphotodir = fphotodirs[selection]    
        fphotofile = fphotofiles[selection]
    
        for coaddfile in sorted(set(fspec['COADDFN'])):
            redrockfile = coaddfile.replace('coadd-', 'redrock-')
            subdir = coaddfile.split('/')[-2]

            I = coaddfile == fspec['COADDFN']
            healpix = fspec['HEALPIX'][I][0]
            
            if vi_redshifts:
                targetids = ','.join(fspec['TARGETID'][I].astype(str))
                input_redshifts = ','.join(fspec['VI_Z'][I].astype(str))

            fastdir = os.path.join(projectdir, prefix, selection, subdir)
            if not os.path.isdir(fastdir):
                os.makedirs(fastdir, exist_ok=True)
            fastfile = os.path.join(fastdir, f'{prefix}-{healpix}.fits.gz')
    
            if not os.path.isfile(fastfile) or overwrite:
                cmdargs = f'{redrockfile} -o {fastfile} --mp {mp} --fphotodir={fphotodir} --fphotofile={fphotofile} --ignore-quasarnet'
                if vi_redshifts:
                    cmdargs += f' --targetids {targetids} --input-redshifts {input_redshifts}'
                log.info(f'fastspec {cmdargs}')
                if nolog:
                    fast(args=cmdargs.split())
                else:
                    logfile = fastfile.replace('.fits', '.log').replace('.gz', '')
                    with stdouterr_redirected(to=logfile, overwrite=True):
                        fast(args=cmdargs.split())
            else:
                log.info(f'Output file {fastfile} exists and --overwrite not set.')


def desihiz_fastspec_qa(mp=1, targetids=None, ntargets=None, vi_redshifts=True, overwrite=False):
    """Wrapper to generate FastSpecFit QA.

    """
    from fastspecfit.qa import fastqa

    extname = 'FASTSPEC'
    prefix = 'fastspec'
    fits = 'fits.gz'
    if vi_redshifts:
        prefix += '-vi'

    for selection in ['clauds']: #['suprime', 'odin', 'clauds']:
        qadir = os.path.join(projectdir, prefix, selection, 'qa')
        if not os.path.isdir(qadir):
            os.makedirs(qadir, exist_ok=True)

        fphoto, fspec = read_desihiz(selection=selection, vi_redshifts=vi_redshifts)
        fphotodir = fphotodirs[selection]    
        fphotofile = fphotofiles[selection]

        for coaddfile in sorted(set(fspec['COADDFN'])):
            redrockfile = coaddfile.replace('coadd-', 'redrock-')
            subdir = coaddfile.split('/')[-2]

            I = coaddfile == fspec['COADDFN']
            healpix = fspec['HEALPIX'][I][0]

            fastfile = os.path.join(projectdir, prefix, selection, subdir, f'{prefix}-{healpix}.fits.gz')
            cmdargs = f'{fastfile} --redrockfiles {redrockfile} --mp {mp} --fphotodir={fphotodir} --fphotofile={fphotofile} -o {qadir} --nsmoothspec 2'
            if ntargets or targetids:
                if targetids:
                    cmdargs += f' --targetids {targetids}'
                else:
                    cmdargs += f' --ntargets {ntargets}'
            if overwrite:
                cmdargs += ' --overwrite'
            log.info(f'fastqa {cmdargs}')
            fastqa(args=cmdargs.split())


def desihiz_gather_fastspec(mp=1, overwrite=False):
    """Gather the desihiz fastspec results."""
    from fastspecfit.io import read_fastspecfit, write_fastspecfit
    from fastspecfit.mpi import _domerge
    for selection in ['suprime', 'odin', 'clauds']:    
        mergefile = os.path.join(datadir, f'fastspec-vi-desihiz-{selection}.fits')
        if not os.path.isfile(mergefile) or overwrite:
            fastfiles = glob(os.path.join(projectdir, 'fastspec-vi', selection, '*', 'fastspec-vi-?????.fits.gz'))
            _domerge(fastfiles, extname='FASTSPEC', mergefile=mergefile, mp=mp)
        else:
            log.info(f'Output file {mergefile} exists; use --overwrite to, well, overwrite.')

    # Now merge the results after applying some basic redshift cuts.
    fastfile = os.path.join(datadir, 'fastspec-vi-desihiz.fits')    
    fast, meta = [], []
    for selection in ['suprime', 'odin', 'clauds']:
        mergefile = os.path.join(datadir, f'fastspec-vi-desihiz-{selection}.fits')
        allfast, allmeta, _, _ = read_fastspecfit(mergefile)
        allmeta['SELECTION'] = selection
        # trim to 2 < z < 4 and require a good stellar mass (non-zero continuum coefficients)
        I = (allfast['LOGMSTAR'] > 0.) * (allmeta['Z'] > 2.) * (allmeta['Z'] < 4.)
        fast.append(allfast[I])
        meta.append(allmeta[I])
    fast = vstack(fast)
    meta = vstack(meta)
    write_fastspecfit(fast, meta, outfile=fastfile, verbose=True)

    #dd = fitsio.read('/global/cfs/cdirs/desi/users/ioannis/fastspecfit/redrock-templates/data/fastspec-vi-desihiz.fits', 'METADATA')
    #plt.clf() ; _=plt.hist(dd['Z'], bins=100) ; plt.yscale('log') ; plt.savefig('/global/cfs/cdirs/desi/users/ioannis/tmp/junk.png')


def match_lss(specprod='iron', lss_specprod='fuji', overwrite=False):
    """Match to the clustering catalogs (full and clustering).

    https://desi.lbl.gov/trac/wiki/keyprojects/y1kp3/Y1details

    """
    from fastspecfit.io import read_fastspecfit
    from fastspecfit.io import write_fastspecfit

    vacdir = get_vacdir(specprod)

    # read the clustering catalogs
    if lss_specprod == 'fuji':
        lssdir = os.path.join(os.getenv('DESI_ROOT'), 'vac', 'edr', 'lss', 'v2.0', 'LSScats', 'clustering')
        north, south = 'N', 'S'
    elif lss_specprod == 'iron':
        #lssdir = os.path.join(os.getenv('DESI_ROOT'), 'vac', 'edr', 'lss', 'v2.0', 'LSScats')
        lssdir = '/global/cfs/cdirs/desi/survey/catalogs/Y1/LSS/iron/LSScats/v1.1/unblinded'
        north, south = 'NGC', 'SGC'
    else:
        raise NotImplemented

    zlims = get_zlims(lss_specprod)
    
    survey = 'sv3'
    
    for targtype in zlims.keys():
        log.info('##################################################')
        log.info(f'Working on {targtype}')
        if targtype == 'BGS_ANY':
            fastfile = os.path.join(vacdir, f'fastspec-{specprod}-{survey}-bright.fits')
            allfast, allmeta, _, _ = read_fastspecfit(fastfile)
        else:
            fastfile = os.path.join(vacdir, f'fastspec-{specprod}-{survey}-dark.fits')
            allfast, allmeta, _, _ = read_fastspecfit(fastfile)
        
        for lsstype in ['clustering']:
            log.info('--------------------')
            outfastfile = os.path.join(datadir, f'fastspec-{specprod}-{lsstype}-{targtype}.fits')
            outlssfile = os.path.join(datadir, f'lss-{lss_specprod}-{lsstype}-{targtype}.fits')
    
            if os.path.isfile(outfastfile) and os.path.isfile(outlssfile) and not overwrite:
                log.info(f'fastspecfit file {outfastfile} exists')
                log.info(f'LSS clustering file {outlssfile} exists')
            else:
                if lsstype == 'clustering':
                    lssNfile = os.path.join(lssdir, f'{targtype}_{north}_clustering.dat.fits')
                    lssSfile = os.path.join(lssdir, f'{targtype}_{south}_clustering.dat.fits')
                    lssN = fitsio.read(lssNfile)
                    lssS = fitsio.read(lssSfile)
                    alllss = Table(np.concatenate((lssN, lssS)))
                    log.info(f'Read {len(lssN):,d} objects from {lssNfile}')
                    log.info(f'Read {len(lssS):,d} objects from {lssSfile}')
                    log.info(f'  Total number of LSS {targtype}: {len(alllss):,d}')
                    del lssN, lssS
                    
                indx_fast, indx_lss = geomask.match(allfast['TARGETID'], alllss['TARGETID'])
                log.info(f'Matched {len(indx_fast):,d} LSS-fastspec objects.')
                fast = allfast[indx_fast]
                meta = allmeta[indx_fast]
                lss = alllss[indx_lss]
                assert(np.all(meta['TARGETID'] == lss['TARGETID']))

                ## Any missing objects are going to be because Z_TILE != Z_HP
                ## and Z_HP < 1e-3 but we trimmed those above.
                #miss = alllss[np.delete(np.arange(len(alllss)), indx_lss)]
                #try:
                #    assert(len(miss) == 0)
                #except:
                #    log.warning('Missing the following objects!')
                #    print(miss)

                # apply redshift cuts
                I = (meta['Z'] > zlims[targtype][0]) * (meta['Z'] < zlims[targtype][1]) * (fast['LOGMSTAR'] > 0.)
                log.info(f'Trimming to {np.sum(I):,d} objects with z={zlims[targtype][0]:.2f}-{zlims[targtype][1]:.2f} and LOGMSTAR>0.')
                fast = fast[I]
                meta = meta[I]
                lss = lss[I]

                #lss[np.abs(meta['Z'] - lss['Z']) > 0.01]['Z']
               
                write_fastspecfit(fast, meta, outfile=outfastfile, verbose=False)

                lss.write(outlssfile, overwrite=True)
                log.info(f'Wrote {len(lss):,d} objects to {outlssfile}')


def read_clustering(targetclass=['BGS_ANY', 'LRG', 'ELG'], specprod='iron',
                    lss_specprod='fuji', lsstype='clustering', read_lss=True,
                    trim_broad=True, rows=None):
    """Read the matched clustering files (from match_lss).

    """
    from fastspecfit.io import read_fastspecfit

    data = {}
    for targtype in np.atleast_1d(targetclass):
        fastfile = os.path.join(datadir, f'fastspec-{specprod}-{lsstype}-{targtype}.fits')
        if not os.path.isfile(fastfile):
            log.info(f'{fastfile} not found.')
        else:
            fast, meta, _, _ = read_fastspecfit(fastfile, rows=rows)
            if read_lss:
                lssfile = os.path.join(datadir, f'lss-{lss_specprod}-{lsstype}-{targtype}.fits')
                lss = Table(fitsio.read(lssfile, rows=rows))
                log.info(f'Read {len(lss):,d} objects from {lssfile}')
            else:
                lss = None

            if trim_broad:
                B = np.logical_or(fast['BROAD_SIGMA'] > 0, meta['SPECTYPE'] == 'QSO')
                log.info(f'Trimming {np.sum(B):,d}/{len(fast):,d} broad-line galaxies.')
                fast = fast[~B]
                meta = meta[~B]
                if lss is not None:
                    lss = lss[~B]
                
            data[targtype] = {'fast': fast, 'meta': meta, 'lss': lss}
            
    return data     


def parent_qa(specprod='iron',  lss_specprod='fuji'):
    """Build some QA of the parent sample."""

    import corner as cn
    from matplotlib import colors
    import matplotlib.patches as mpatches

    data = read_clustering(specprod=specprod, lss_specprod=lss_specprod, read_lss=False, trim_broad=True)

    cols = [colors.to_hex(col) for col in ['darkgreen', 'darkred', 'darkblue']]
    #cols = [colors.to_hex(col) for col in ['darkseagreen', 'orangered', 'dodgerblue']]

    levels = [0.5, 0.75, 0.95, 0.99]
    smooth = 1.5
    mstarlim = [6.5, 12.5]
    sfrlim = [-5, 4]
    redshiftlim = [-0.05, 1.7]
    vdisplim = [50., 475.]
    linewidthlim = [0, 350]

    hh = []
    fig, ax = plt.subplots(1, 2, figsize=(10, 5))
    for targtype, col, in zip(['BGS_ANY', 'LRG', 'ELG'][::-1], cols[::-1]):
        fast = data[targtype]['fast']
        meta = data[targtype]['meta']

        cn.hist2d(meta['Z'], fast['LOGMSTAR'], fill_contours=False,
                  range=[redshiftlim, mstarlim],
                  bins=50, color=col, smooth=smooth, levels=levels,
                  contour_kwargs={'colors': col, 'alpha': 0.8, 'linewidths': 1},
                  label=targtype, 
                  data_kwargs={'color': col, 'alpha': 0.5, 'ms': 2}, ax=ax[0])
        hh.append(mpatches.Patch(color=col, label=targtype, alpha=0.5))
    ax[0].set_xlabel('Redshift')
    ax[0].set_ylabel(r'$\log_{10}\ (M/M_{\odot})$')
    #ax[0].legend(handles=hh, fontsize=11)

    for targtype, col, in zip(['ELG', 'BGS_ANY', 'LRG'], [cols[2], cols[0], cols[1]]):
        fast = data[targtype]['fast']
        meta = data[targtype]['meta']
        I = fast['SFR'] > 0
        print(targtype, np.sum(I))

        cn.hist2d(fast['LOGMSTAR'][I], np.log10(fast['SFR'][I]), fill_contours=False,
                  range=[mstarlim, sfrlim],
                  bins=50, color=col, smooth=smooth, levels=levels,
                  contour_kwargs={'colors': col, 'alpha': 0.8, 'linewidths': 1},
                  label=targtype, 
                  data_kwargs={'color': col, 'alpha': 0.5, 'ms': 2}, ax=ax[1])
    ax[1].set_xlabel(r'$\log_{10}(M\ /\ M_{\odot})$')
    ax[1].set_ylabel(r'$\log_{10}(\mathrm{SFR}\ /\ M_{\odot}\ \mathrm{yr}^{-1})$')
    ax[1].legend(handles=hh, fontsize=11, loc='upper left')
    fig.tight_layout()
    pngfile = os.path.join(qadir, 'qa-parent-logmstar.png')
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')

    fig, ax = plt.subplots(1, 2, figsize=(10, 5))
    for targtype, col, in zip(['BGS_ANY', 'LRG'], cols[:3]):
        fast = data[targtype]['fast']
        meta = data[targtype]['meta']
        I = fast['VDISP_IVAR'] > 0
        ax[0].hist(fast['VDISP'][I], bins=30, color=col, range=vdisplim, alpha=0.5)#,
                   #edgecolor='k')#, histtype='stepfilled')
    ax[0].set_xlabel(r'$\sigma_{star}$ (km/s)')
    ax[0].set_ylabel('Number')

    for targtype, col, in zip(['ELG', 'BGS_ANY', 'LRG'], [cols[2], cols[0], cols[1]]):
        fast = data[targtype]['fast']
        meta = data[targtype]['meta']
        I = fast['NARROW_SIGMA'] > 0
        ax[1].hist(fast['NARROW_SIGMA'][I], bins=30, color=col, range=linewidthlim, alpha=0.5,
                   label=targtype)#, edgecolor=col)
    ax[1].set_xlabel(r'$\sigma_{line}$ (km/s)')
    ax[1].set_ylabel('Number')
    ax[1].legend(loc='upper right', fontsize=11)
    fig.tight_layout()
    pngfile = os.path.join(qadir, 'qa-parent-velwidth.png')
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')

    #fig, ax = plt.subplots(1, 3, figsize=(12, 3))
    #for targtype, xx, col in zip(['BGS_ANY', 'LRG', 'ELG'], ax.flat, cols):
    
    fig, xx = plt.subplots(figsize=(8, 6))
    for targtype, col in zip(['BGS_ANY', 'LRG', 'ELG'][::-1], cols[::-1]):
        fast = data[targtype]['fast']
        meta = data[targtype]['meta']
        zlim = (0, 1.6) # (np.min(fast['Z']), np.max(fast['Z']))
        #print(zlim)
        xx.hist(fast['Z'], bins=30, color=col, range=zlim, alpha=0.5,
                label=f'{targtype} (N={len(fast):,d})')
        #xx.hist(fast['Z'][B], bins=100, color='k', fill=True, range=zlim)
        #xx.set_yscale('log')
    xx.legend(loc='upper right', fontsize=11)
    xx.set_xlabel('Redshift')
    xx.set_ylabel('Number')
    #ax.flat[-1].axis('off')
    #ax[0].set_ylabel('Number')
    fig.tight_layout()
    pngfile = os.path.join(qadir, 'qa-parent-zhist.png')
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')


def qa_zhist(vi=True):
    """Redshift histogram.

    """
    from matplotlib import colors

    zcatfile = os.path.join(projectdir, f'zcat-newtemplates-desihiz-zscan02.fits')
    zcat = Table(fitsio.read(zcatfile))
    if vi:
        I = np.isfinite(zcat['VI_Z']) * (zcat['VI_QUALITY'] >= 3.)
    else:
        I = (zcat['ZWARN'] == 0) * (zcat['COADD_FIBERSTATUS'] == 0) * (zcat['DELTACHI2'] > dchi2dict['desihiz'])
    zcat = zcat[I]
    
    #vihiz = []
    #for selection in ['suprime', 'odin', 'clauds']:    
    #    _, _vihiz = read_desihiz(selection=selection)
    #    _vihiz['SELECTION'] = selection
    #    vihiz.append(_vihiz)
    #vihiz = vstack(vihiz)

    # VI - desihiz
    cols = np.array([colors.to_hex(col) for col in ['darkgreen', 'darkred', 'darkblue']])
    
    zlim = (-0.1, 3.8)
    
    fig, xx = plt.subplots(figsize=(8, 6))
    for selection, col in zip(['odin', 'clauds', 'suprime'], cols):
        I = np.where(zcat['SELECTION'] == selection)[0]
        if vi:
            xx.hist(zcat['VI_Z'][I], bins=100, color=col, range=zlim, alpha=0.5,
                    label=f'{selection} (N={len(I):,d})')
        else:
            xx.hist(zcat['Z'][I], bins=100, color=col, range=zlim, alpha=0.5,
                    label=f'{selection} (N={len(I):,d})')
    xx.legend(loc='upper left', fontsize=12)
    if vi:
        xx.set_xlabel('VI Redshift (Q>=3)')
    else:
        xx.set_xlabel('RR Redshift')
    xx.set_ylabel('Number')
    #xx.set_yscale('log')
    xx.margins(x=0)
    fig.tight_layout()

    if vi:
        pngfile = os.path.join(qadir, 'qa-desihiz-vi-zhist.png')
    else:
        pngfile = os.path.join(qadir, 'qa-desihiz-zhist.png')
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')

    pdb.set_trace()

    # VI/SV1 + desihiz
    vi = read_vi()

    cols = np.array([colors.to_hex(col) for col in ['darkgreen', 'darkred', 'darkblue', 'black', 'orange']])
    
    zlim = (0, 3.5)
    srt = [0, 2, 1, 3]
    
    fig, xx = plt.subplots(figsize=(8, 6))
    for targtype, col in zip(np.array(['BGS', 'LRG', 'ELG', 'QSO'])[srt], cols[:5][srt]):
    #for targtype, col in zip(['BGS', 'LRG', 'ELG', 'QSO'], cols[:5]):
        I = np.where(vi['SUFFIX'] == targtype)[0]
        xx.hist(vi['VI_Z'][I], bins=50, color=col, range=zlim, alpha=0.5,
                label=f'{targtype} (N={len(I):,d})')

    xx.hist(vihiz['VI_Z'], bins=50, color=cols[-1], range=zlim, alpha=0.5,
            label=f'LAE/LBG (N={len(vihiz):,d})')

    hh, ll = xx.get_legend_handles_labels()
    xx.legend([hh[ii] for ii in srt+[4,]], [ll[ii] for ii in srt+[4,]], loc='upper right', fontsize=11)
    #xx.legend(loc='upper right', fontsize=11)
    xx.set_xlabel('VI Redshift')
    xx.set_ylabel('Number')
    fig.tight_layout()
    pngfile = os.path.join(qadir, 'qa-vi-zhist.png')
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')

    
def build_emline_model(lineamps, linevshifts, linesigmas, linewaves, 
                       emlinewave, dlog10wave=None, redshift=0.0):

    if dlog10wave is None:
        dlog10wave = 5. / C_LIGHT / np.log(10) # equivalent to km/s

    pad = 5.

    # Cut to lines with non-zero amplitudes.
    I = lineamps > 0
    if np.count_nonzero(I) > 0:
        linevshifts = linevshifts[I]
        linesigmas = linesigmas[I]
        lineamps = lineamps[I]
        linewaves = linewaves[I]

        # demand at least 20 km/s for rendering the model
        if np.any(linesigmas) < 20.:
            linesigmas[linesigmas<20.] = 20.

        # line-width [log-10 Angstrom] and redshifted wavelength [log-10 Angstrom]
        log10sigmas = linesigmas / C_LIGHT / np.log(10) 
        linezwaves = np.log10(linewaves * (1. + redshift + linevshifts / C_LIGHT))

        log10wave = []
        for linezwave, log10sigma in zip(linezwaves, log10sigmas):
            log10wave.append(np.arange(linezwave - (5 * log10sigma), linezwave + (5 * log10sigma), dlog10wave))
        log10wave = np.hstack([np.log10(np.min(emlinewave)-pad), np.log10(np.max(emlinewave)+pad), ] + log10wave)
        S = np.argsort(log10wave)
        log10wave = log10wave[S]
        log10model = np.zeros_like(log10wave)
        
        for lineamp, linezwave, log10sigma in zip(lineamps, linezwaves, log10sigmas):
            J = np.abs(log10wave - linezwave) < (5 * log10sigma)
            log10model[J] += lineamp * np.exp(-0.5 * (log10wave[J]-linezwave)**2 / log10sigma**2)

    modelflux = np.hstack(log10model)
    emlinemodel = trapz_rebin(10**log10wave, modelflux, emlinewave)

    return emlinemodel


def read_ftemplates():
    
    from fastspecfit.io import cache_templates

    _ftemplatesdir = os.environ['FTEMPLATES_DIR']
    ftemplatesdir = os.path.join(os.getenv('PSCRATCH'), 'fastspecfit', 'templates')
    log.warning(f'Temporarily hacking FTEMPLATES_DIR to {ftemplatesdir}!')

    os.environ['FTEMPLATES_DIR'] = ftemplatesdir
    templatecache = cache_templates(templateversion='1.1.1', read_linefluxes=True)
    os.environ['FTEMPLATES_DIR'] = _ftemplatesdir

    return templatecache


def restframe_templates(fast, meta, outfile, minwave=400., maxwave=1.1e4, dwave=0.1):
    """Reconstruct the rest-frame templates.

    """
    from scipy.ndimage import gaussian_filter1d
    from fastspecfit.io import cache_templates
    from fastspecfit.continuum import PIXKMS_BLU

    ngal = len(meta)

    templatecache = read_ftemplates()
    info = templatecache['templateinfo']
    nsed = len(info)

    # note the 5-Angstrom pad
    I = np.where((templatecache['templatewave'] > (minwave-5)) * (templatecache['templatewave'] < (maxwave+5)))[0]
    templatewave = templatecache['templatewave'][I]
    templateflux = templatecache['templateflux'][I, :]
    templateflux_nolines = templatecache['templateflux_nolines'][I, :]
    npix = len(templatewave)

    J = np.where((templatecache['linewaves'] > minwave) * (templatecache['linewaves'] < maxwave))[0]
    linewaves = templatecache['linewaves'][J]
    linefluxes = templatecache['linefluxes'][J]
    del templatecache

    # generate template models on a grid of velocity dispersion; note that this
    # isn't quite right in the UV or beyond about a micron...
    vdispmin = 50.
    vdispmax = 350.
    dvdisp = 25.
    nvdisp = int(np.ceil((vdispmax - vdispmin) / dvdisp)) + 1
    vdisp_grid = np.linspace(vdispmin, vdispmax, nvdisp)

    vdispflux = []
    for sigma in vdisp_grid / PIXKMS_BLU:
        vdispflux.append(gaussian_filter1d(templateflux_nolines, sigma=sigma, axis=0))
    vdispflux = np.stack(vdispflux, axis=-1) # [npix,nvdispmodel,nvdisp]

    # now loop on each galaxy and build the best-fitting continuum using the
    # smoothed model closest to the measured velocity dispersion
    continuum = np.zeros((ngal, npix))
    I = np.argmin(np.abs(fast['VDISP'][:, np.newaxis] - vdisp_grid[np.newaxis, :]), axis=1)
    for ivdisp in set(I):
        J = np.where(ivdisp == I)[0]
        continuum[J, :] = fast['COEFF'][J].data.dot(vdispflux[:, :, ivdisp].T) # note: no line-emission

    # reconstruct the continuum-only templates
    #continuum = fast['COEFF'].data.dot(templateflux_nolines.T) # note: no line-emission
    templates_lowres = fast['COEFF'].data.dot(templateflux.T) # note: low-res line-emission

    ## convolve with the measured velocity dispersion
    #log.info('Convolving to the measured velocity dispersion.')
    #for igal in range(ngal):
    #    sigma = fast['VDISP'][igal] / PIXKMS_BLU # [pixels]
    #    continuum[igal, :] = gaussian_filter1d(continuum[igal, :], sigma=sigma, axis=0)

    # interpolate the models onto the new, desired wavelength grid
    _templatewave = np.arange(minwave, maxwave, dwave)
    _npix = len(_templatewave)
    _continuum = np.zeros((ngal, _npix))
    log.info('Interpolating onto the new wavelength grid.')
    for igal in range(ngal):
        _continuum[igal, :] = trapz_rebin(templatewave, continuum[igal, :], xnew=_templatewave)
        
    npix = _npix
    continuum = _continuum
    templatewave = _templatewave

    # build emission-line spectra on a grid of line-width; then, below, choose
    # the closest one to the measured line-width
    nline = len(linewaves)

    #linesigma_delta = 15. # 5.
    #nlinesigma = int(np.ceil((linesigma_max - linesigma_min) / linesigma_delta)) + 1
    nominal_sigma = 75. # [km/s]
    linesigma_min = 5.
    linesigma_max = 115.
    nlinesigma = 9
    linesigma_grid = np.linspace(linesigma_min, linesigma_max, nlinesigma)
    if not nominal_sigma in linesigma_grid:
        linesigma_grid = np.hstack((nominal_sigma, linesigma_grid))
        linesigma_grid = linesigma_grid[np.argsort(linesigma_grid)]
        nlinesigma = len(linesigma_grid)

    linevshifts = np.zeros_like(linewaves) # no velocity shifts
    linezwaves = linewaves * (1. + linevshifts / C_LIGHT)
    
    linemodels = np.zeros((nlinesigma, nsed, npix)) # [nsigma, nsed, npix]

    current_palette = sns.color_palette()
    sns.set_palette('rainbow', nlinesigma)#'Spectral')#'coolwarm')
    #linecolors = iter(sns.husl_palette(nlinesigma, l=0.3))
    linecolors = iter(sns.color_palette())
    fig, ax = plt.subplots()
    for isigma in range(nlinesigma):
        print(linesigma_grid[isigma])
        linesigmas = np.zeros(nline) + linesigma_grid[isigma]
        I = np.where(np.sum(linefluxes, axis=0) > 0)[0]
        for imodel in I:
            lineamps = C_LIGHT * linefluxes[:, imodel] / (np.sqrt(2 * np.pi) * linesigmas * linezwaves)
            emlinemodel = build_emline_model(lineamps, linevshifts, linesigmas,
                                             linewaves, emlinewave=templatewave)
            linemodels[isigma, imodel, :] = emlinemodel
            if info['av'][imodel] == 0. and info['zzsun'][imodel] == 0. and info['sfr'][imodel] > 0.:
                W = np.where((templatewave > (3728.483-12.)) * (templatewave < (3728.483+12)))[0]
                ax.plot(templatewave[W], emlinemodel[W]/np.max(emlinemodel[W]), lw=1,
                        color=next(linecolors),
                        label='{linesigma_grid[isigma]:.2f} km/s')
    ax.legend(fontsize=10, loc='upper left')
    ax.set_yticklabels([])
    ax.set_xlabel(r'Wavelength ($\AA$)')
    fig.tight_layout()    
    pngfile = os.path.join(qadir, 'qa-linewidth-grid.png')    
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')
    sns.set_palette(current_palette)
        
    # now build the emission-line spectra, choosing the linemodels model closest
    # to the measured line-width
    linespectra = np.zeros_like(continuum)
    for igal in range(ngal):
        if igal % 1000 == 0:
            log.info(f'Working on galaxy {igal} / {ngal}')

        # are any of the emission-line models used for this object?
        I = np.where((np.sum(linefluxes, axis=0) > 0) * (fast['COEFF'][igal] > 0))[0]
        if len(I) > 0:
            if fast['NARROW_SIGMA'][igal] > 0:
                linesigma = fast['NARROW_SIGMA'][igal]
            else:
                linesigma = nominal_sigma
            jsigma = np.argmin(np.abs(linesigma-linesigma_grid))

            emlinemodels = np.zeros((npix, nsed))
            for imodel in I:
                #print(igal, jsigma, imodel, linesigma, linesigma_grid[jsigma])
                emlinemodels[:, imodel] = linemodels[jsigma, imodel, :]

            linespectra[igal, :] = fast['COEFF'][igal].dot(emlinemodels.T)

            #if linesigma_grid[jsigma] > 150.:
            #    W = np.where((templatewave > 4800.) * (templatewave < 5100.))[0]                
            #    plt.plot(templatewave[W], continuum[igal, W] + linespectra[igal, W])
            #    plt.plot(templatewave[W], templates_lowres[igal, W])
            #    plt.plot(templatewave[W], linespectra[igal, W])
            #    plt.savefig('/global/cfs/cdirs/desi/users/ioannis/tmp2/junk.png')
    
    ## now generate the individual emission-line spectra but using the measured
    ## line-width (if any)
    #linespectra = np.zeros_like(continuum)
    #for igal in range(ngal):
    #    if igal % 20 == 0:
    #        log.info(f'Working on galaxy {igal} / {ngal}')
    #    
    #    if fast['NARROW_SIGMA'][igal] > 0:
    #        linesigmas = np.zeros(nline) + fast['NARROW_SIGMA'][igal]
    #    else:
    #        linesigmas = np.zeros(nline) + nominal_sigma
    #    #linesigmas = np.zeros(nline) + 500.
    #
    #    linezwaves = linewaves * (1. + linevshifts / C_LIGHT)
    #
    #    #lineamps = C_LIGHT * linefluxes / (np.sqrt(2 * np.pi) * linesigmas[:, np.newaxis] * linewaves[:, np.newaxis])
    #    emlinemodels = np.zeros_like(templateflux_nolines)
    #    I = np.where((np.sum(linefluxes, axis=0) > 0) * (fast['COEFF'][igal] > 0))[0]
    #    if len(I) > 0:
    #        for imodel in I:
    #            #print(igal, imodel)
    #            lineamps = C_LIGHT * linefluxes[:, imodel] / (np.sqrt(2 * np.pi) * linesigmas * linezwaves)
    #            emlinemodel = build_emline_model(lineamps, linevshifts, linesigmas,
    #                                             linewaves, emlinewave=templatewave)
    #            emlinemodels[:, imodel] = emlinemodel
    #            #plt.clf()
    #            #I = np.where((templatewave > 4800.) * (templatewave < 5100.))[0]                
    #            #plt.plot(templatewave[I], emlinemodel[I])
    #            #plt.savefig('/global/cfs/cdirs/desi/users/ioannis/tmp2/junk.png')
    #
    #    if np.max(emlinemodels) > 0:
    #        linespectra[igal, :] = fast['COEFF'][igal].dot(emlinemodels.T)
    #    #plt.clf()
    #    #I = np.where((templatewave > 4800.) * (templatewave < 5100.))[0]                
    #    #plt.plot(templatewave[I], continuum[igal, I] + linespectra[igal, I])
    #    #plt.plot(templatewave[I], templates_lowres[igal, I])
    #    ##plt.plot(templatewave[I], linespectra[igal, I])
    #    #plt.savefig('/global/cfs/cdirs/desi/users/ioannis/tmp2/junk.png')
        
    templates = continuum + linespectra

    # gather the output metadata
    metacols = ['TARGETID', 'SURVEY', 'PROGRAM', 'HEALPIX', 'RA', 'DEC', 'Z', 'ZWARN', 'DELTACHI2', 'SPECTYPE', 'Z_RR']
    outmeta = meta[metacols]

    fastcols = ['VDISP', 'AV', 'AGE', 'ZZSUN', 'LOGMSTAR', 'SFR', 'DN4000_MODEL', 'NARROW_Z',
                'BROAD_Z', 'UV_Z', 'NARROW_SIGMA', 'BROAD_SIGMA', 'UV_SIGMA']
    outmeta = hstack((outmeta, fast[fastcols]))
    outmeta['TEMPLATENORM'] = np.ones(len(outmeta), 'f4')

    # normalize at 5500 A
    for igal in range(ngal):
        norm = np.mean(templates[igal, :])
        #norm = np.interp(5500., templatewave, templates[igal, :])
        #if norm == 0:
        #    pdb.set_trace()
        outmeta['TEMPLATENORM'][igal] = norm
        templates[igal, :] /= norm
        templates_lowres[igal, :] /= norm
        continuum[igal, :] /= norm
        linespectra[igal, :] /= norm
    
    fitsio.write(outfile, templates.astype('f8'), clobber=True, extname='FLUX')
    fitsio.write(outfile, templatewave, extname='WAVE')
    fitsio.write(outfile, outmeta.as_array(), extname='METADATA')
    print(f'Wrote {outfile}')

    # optional QA of the first 10 models
    
    fig, ax = plt.subplots()
    #I = np.where((templatewave > 4800.) * (templatewave < 5100.))[0]
    #ax.plot(templatewave[I]/1e4, templates[igal, I], label='New model')
    #ax.plot(templatewave[I]/1e4, templates_lowres[igal, I], alpha=0.5, label='Fixed-res model')
    ##ax.plot(templatewave[I]/1e4, linespectra[igal, I])
    #ax.plot(templatewave[I]/1e4, continuum[igal, I], label='Continuum only')
    #ax.legend()
    for igal in range(10):
        ax.plot(templatewave/1e4, templatewave * templates[igal, :], alpha=0.5)
        #ax.plot(templatewave[I]/1e4, templates[igal, I], label='Custom', alpha=0.5)
        #ax.plot(templatewave[I]/1e4, templates_lowres[igal, I], label='FSPS', alpha=0.5)
    ax.set_yscale('log')
    ax.set_ylabel(r'Normalized $\lambda F_{\lambda}$')
    ax.set_xlabel(r'Rest-frame Wavelength ($\mu$m)')
    ax.set_xscale('log')
    ax.xaxis.set_major_formatter(ticker.FuncFormatter(lambda y, _: '{:g}'.format(y)))
    ax.margins(0)
    fig.tight_layout()
    pngfile = outfile.replace('.fits', '.png')
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')


def gather_specprod_results(specprod='iron', overwrite=False):
    """Wrapper to gather nominal Redrock results.

    """
    from desispec.validredshifts import validate

    # VI tiles
    zcatdir = os.path.join(projectdir, f'redux-{specprod}templates', 'vitiles')
    if not os.path.isdir(zcatdir):
        os.makedirs(zcatdir, exist_ok=True)

    vi = read_vi()
    for tileid in sorted(set(vi['TILEID'])):
        T = tileid == vi['TILEID']
        petals = vi['FIBER'][T] // 500
        for petal in sorted(set(petals)):
            P = petal == petals
            targetids = vi[T][P]['TARGETID'].data

            zcatfile = os.path.join(zcatdir, f'zcat-{specprod}-{petal}-{tileid}.fits')
            if not os.path.isfile(zcatfile) or overwrite:
                orig_redrockfile = glob(os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'redux', specprod, 'tiles',
                                                     'cumulative', str(tileid), '*', f'redrock-{petal}-{tileid}-thru*.fits'))[0]

                zcat = validate(orig_redrockfile, return_target_columns=True,
                                extra_columns=['TARGETID', 'Z', 'Z_RR', 'ZWARN', 'COADD_FIBERSTATUS', 'SPECTYPE', 'DELTACHI2'])
                zcat = zcat[geomask.match_to(zcat['TARGETID'], targetids)]
                assert(np.all(zcat['TARGETID'] == targetids))
                zcat.write(zcatfile, overwrite=True)
                log.info(f'Wrote {len(zcat)} objects to {zcatfile}')

    # desihiz healpixels
    for selection in ['suprime', 'odin', 'clauds']:
        fphoto, fspec = read_desihiz(selection=selection)
        for coaddfile in sorted(set(fspec['COADDFN'])):
            I = coaddfile == fspec['COADDFN']
            healpix = fspec['HEALPIX'][I][0]
            alltargetids = fspec['TARGETID'][I].data            

            redrockfile = coaddfile.replace('coadd-', 'redrock-')
            subdir = coaddfile.split('/')[-2]            

            zcatdir = os.path.join(projectdir, f'redux-{specprod}templates', 'desihiz', selection, subdir)
            if not os.path.isdir(zcatdir):
                os.makedirs(zcatdir, exist_ok=True)

            # validate the original redrock redshifts
            zcatfile = os.path.join(zcatdir, f'zcat-{healpix}.fits')
            if not os.path.isfile(zcatfile) or overwrite:
                zcat = validate(redrockfile, return_target_columns=True,
                                extra_columns=['TARGETID', 'Z', 'Z_RR', 'ZWARN', 'COADD_FIBERSTATUS', 'SPECTYPE', 'DELTACHI2'])
                zcat = zcat[geomask.match_to(zcat['TARGETID'], alltargetids)]
                assert(np.all(zcat['TARGETID'] == alltargetids))
                zcat.write(zcatfile, overwrite=True)
                log.info(f'Wrote {len(zcat)} objects to {zcatfile}')


def run_redrock_tiles(zscan_prior='01', specprod='iron', afterburners=True, rrdetails=False, overwrite=False):
    """Wrapper to run Redrock on the VI tiles.

    """
    from redrock.external.desi import rrdesi
    from desispec.io import read_spectra, write_spectra
    from desispec.util import runcmd
    from desispec.scripts import qsoqn, qsomgii, emlinefit
    from desispec.validredshifts import validate

    # set the redshift scan prior
    zscan_galaxy = zscan_priors[zscan_prior]

    outdir = os.path.join(projectdir, f'redux-newtemplates-zscan{zscan_prior}', 'vitiles')
    if not os.path.isdir(outdir):
        os.makedirs(outdir, exist_ok=True)

    vi = read_vi()
    for tileid in sorted(set(vi['TILEID'])):
        T = tileid == vi['TILEID']
        petals = vi['FIBER'][T] // 500
        for petal in sorted(set(petals)):
            P = petal == petals
            targetids = vi[T][P]['TARGETID'].data

            # copy the data so we can run the after-burners
            coaddfile = os.path.join(outdir, f'coadd-{petal}-{tileid}.fits')
            if not os.path.isfile(coaddfile) or overwrite:                
                orig_coaddfile = glob(os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'redux', specprod, 'tiles',
                                                   'cumulative', str(tileid), '*', f'coadd-{petal}-{tileid}-thru*.fits'))[0]
                spec = read_spectra(orig_coaddfile, targetids=targetids)
                assert(np.all(spec.target_ids() == targetids))
                log.info(f'Writing {len(targetids)} targets to {coaddfile}')
                write_spectra(coaddfile, spec)
                del spec
                
            redrockfile = os.path.join(outdir, f'redrock-{petal}-{tileid}.fits')
            rrdetailsfile = os.path.join(outdir, f'rrdetails-{petal}-{tileid}.h5')
            if not os.path.isfile(redrockfile) or overwrite:
                #cmd = f'-i {coaddfile} -o {redrockfile} -d {rrdetailsfile} --mp 1'
                #cmd = f'-i {coaddfile} -o {redrockfile} --mp 24'
                cmd = f'-i {coaddfile} -o {redrockfile} --gpu --max-gpuprocs=4 --mp 1'
                if rrdetails:
                    cmd += f' -d {rrdetailsfile}'
                if zscan_galaxy is not None:
                    cmd += f' --zscan-galaxy={zscan_galaxy}'
                log.info(f'rrdesi {cmd}')
                rrdesi(cmd.split())
            else:
                log.info(f'Skipping existing file {redrockfile}')

            if afterburners:
                for prefix, maincmd in zip(['qso_qn', 'qso_mgii', 'emline'], [qsoqn.main, qsomgii.main, emlinefit.main]):
                    outfile = os.path.join(outdir, f'{prefix}-{petal}-{tileid}.fits')
                    if not os.path.isfile(outfile) or overwrite:
                        cmd = f'desi_{prefix}_afterburner --coadd {coaddfile} --redrock {redrockfile} --output {outfile}'
                        if 'qso_' in prefix:
                            cmd += ' --target_selection all --save_target all'
                        log.info(f'{runcmd} {cmd}')
                        runcmd(maincmd, args=cmd.split()[1:], inputs=[coaddfile, redrockfile], outputs=[outfile])
                    else:
                        log.info(f'Skipping existing file {outfile}')

            # validate to create the summary catalog
            zcatfile = os.path.join(outdir, f'zcat-{petal}-{tileid}.fits')
            zcat = validate(redrockfile, return_target_columns=True, 
                            extra_columns=['TARGETID', 'Z', 'Z_RR', 'ZWARN', 'COADD_FIBERSTATUS', 'SPECTYPE', 'DELTACHI2'])
            zcat.write(zcatfile, overwrite=True)
            log.info(f'Wrote {len(zcat)} objects to {zcatfile}')


def run_redrock_desihiz(zscan_prior='02', afterburners=True, rrdetails=False, overwrite=False):
    """Wrapper to run Redrock on the VI healpixels.

    """
    from redrock.external.desi import rrdesi
    from desispec.io import read_spectra, write_spectra
    from desispec.util import runcmd
    from desispec.scripts import qsoqn, qsomgii, emlinefit
    from desispec.validredshifts import validate
    
    # set the redshift scan prior
    zscan_galaxy = zscan_priors[zscan_prior]

    for selection in ['suprime', 'odin', 'clauds']:
        baseoutdir = os.path.join(projectdir, f'redux-newtemplates-zscan{zscan_prior}', 'desihiz', selection)
        if not os.path.isdir(baseoutdir):
            os.makedirs(baseoutdir, exist_ok=True)
    
        fphoto, fspec = read_desihiz(selection=selection)
        for orig_coaddfile in sorted(set(fspec['COADDFN'])):
            log.info(f'Working on {orig_coaddfile}')
            
            I = orig_coaddfile == fspec['COADDFN']
            healpix = fspec['HEALPIX'][I][0]
            alltargetids = fspec['TARGETID'][I].data
    
            subdir = orig_coaddfile.split('/')[-2]
            outdir = os.path.join(baseoutdir, subdir)
            if not os.path.isdir(outdir):
                os.makedirs(outdir, exist_ok=True)
    
            # copy the data just in case we want to run the after-burners
            coaddfile = os.path.join(outdir, f'coadd-{healpix}.fits')
            if not os.path.isfile(coaddfile) or overwrite:
                spec = read_spectra(orig_coaddfile, targetids=alltargetids)
                assert(np.all(spec.target_ids() == alltargetids))
                log.info(f'Writing {len(alltargetids)} targets to {coaddfile}')
                write_spectra(coaddfile, spec)
                del spec

            redrockfile = os.path.join(outdir, f'redrock-{healpix}.fits')
            rrdetailsfile = os.path.join(outdir, f'rrdetails-{healpix}.h5')
            if not os.path.isfile(redrockfile) or overwrite:
                #cmd = f'-i {coaddfile} -o {redrockfile} --mp 24 --zscan-galaxy={zscan_galaxy}'
                cmd = f'-i {coaddfile} -o {redrockfile} --gpu --max-gpuprocs=4 --mp 1 --zscan-galaxy={zscan_galaxy}'
                if rrdetails:
                    cmd += f' -d {rrdetailsfile}'
                log.info(f'rrdesi {cmd}')
                rrdesi(cmd.split())
            else:
                log.info(f'Skipping existing file {redrockfile}')

            if afterburners:
                for prefix, maincmd in zip(['qso_qn', 'qso_mgii', 'emline'], [qsoqn.main, qsomgii.main, emlinefit.main]):
                    outfile = os.path.join(outdir, f'{prefix}-{healpix}.fits')
                    if not os.path.isfile(outfile) or overwrite:
                        cmd = f'desi_{prefix}_afterburner --coadd {coaddfile} --redrock {redrockfile} --output {outfile}'
                        if 'qso_' in prefix:
                            cmd += ' --target_selection all --save_target all'
                        log.info(f'{runcmd} {cmd}')
                        runcmd(maincmd, args=cmd.split()[1:], inputs=[coaddfile, redrockfile], outputs=[outfile])
                    else:
                        log.info(f'Skipping existing file {outfile}')

            # validate to create the summary catalog
            zcatfile = os.path.join(outdir, f'zcat-{healpix}.fits')
            zcat = validate(redrockfile, return_target_columns=True, 
                            extra_columns=['TARGETID', 'Z', 'Z_RR', 'ZWARN', 'COADD_FIBERSTATUS', 'SPECTYPE', 'DELTACHI2'])
            zcat.write(zcatfile, overwrite=True)
            log.info(f'Wrote {len(zcat)} objects to {zcatfile}')


def gather_redrock_results(specprod='iron', overwrite=False):
    """Merge the EDR redshift-fitting results with the VI results.

    """
    # Iron - VI tiles
    out_zcatfile = os.path.join(projectdir, f'zcat-{specprod}templates-vitiles.fits')
    if not os.path.isfile(out_zcatfile) or overwrite:
        vi = read_vi()
        zcatfiles = glob(os.path.join(projectdir, f'redux-{specprod}templates', 'vitiles', f'zcat-{specprod}-[0-9]-?????.fits'))
        zcat = vstack([Table(fitsio.read(zcatfile)) for zcatfile in zcatfiles])
        zcat = join(zcat, vi, keys='TARGETID')
        zcat.write(out_zcatfile, overwrite=True)
        log.info(f'Wrote {len(zcat):,d} objects to {out_zcatfile}')

    # Iron - desihiz healpixels
    out_zcatfile = os.path.join(projectdir, f'zcat-{specprod}templates-desihiz.fits')
    if not os.path.isfile(out_zcatfile) or overwrite:
        allzcat = []
        for selection in ['suprime', 'odin', 'clauds']:    
            _, vi = read_desihiz(selection=selection)
            zcatfiles = glob(os.path.join(projectdir, f'redux-{specprod}templates', 'desihiz', selection, '*', 'zcat-?????.fits'))
            zcat = vstack([Table(fitsio.read(zcatfile)) for zcatfile in zcatfiles])
            zcat = join(zcat, vi, keys='TARGETID')
            if np.all(zcat['COADD_FIBERSTATUS_1'] == zcat['COADD_FIBERSTATUS_2']):
                zcat.remove_column('COADD_FIBERSTATUS_2')
                zcat.rename_column('COADD_FIBERSTATUS_1', 'COADD_FIBERSTATUS')
            else:
                raise ValueError('Mismatch here')
            zcat['SELECTION'] = selection
            allzcat.append(zcat)
        allzcat = vstack(allzcat)
        allzcat.write(out_zcatfile, overwrite=True)
        log.info(f'Wrote {len(allzcat):,d} objects to {out_zcatfile}')

    # loop on all the redshift scans
    for zscan_prior in zscan_priors.keys():
        # new templates - VI tiles
        out_zcatfile = os.path.join(projectdir, f'zcat-newtemplates-vitiles-zscan{zscan_prior}.fits')
        if not os.path.isfile(out_zcatfile) or overwrite:
            zcatdir = os.path.join(projectdir, f'redux-newtemplates-zscan{zscan_prior}', 'vitiles')
            if os.path.isdir(zcatdir):
                vi = read_vi()
                zcatfiles = glob(os.path.join(zcatdir, f'zcat-[0-9]-?????.fits'))
                zcat = vstack([Table(fitsio.read(zcatfile)) for zcatfile in zcatfiles])
                zcat = join(zcat, vi, keys='TARGETID')
                zcat.write(out_zcatfile, overwrite=True)
                log.info(f'Wrote {len(zcat):,d} objects to {out_zcatfile}')

        # new templates - desihiz healpixels
        out_zcatfile = os.path.join(projectdir, f'zcat-newtemplates-desihiz-zscan{zscan_prior}.fits')
        if not os.path.isfile(out_zcatfile) or overwrite:
            zcatdir = os.path.join(projectdir, f'redux-newtemplates-zscan{zscan_prior}', 'desihiz')
            if os.path.isdir(zcatdir):
                allzcat = []
                for selection in ['suprime', 'odin', 'clauds']:    
                    _, vi = read_desihiz(selection=selection)
                    zcatfiles = glob(os.path.join(zcatdir, selection, '*', 'zcat-?????.fits'))
                    zcat = vstack([Table(fitsio.read(zcatfile)) for zcatfile in zcatfiles])
                    zcat = join(zcat, vi, keys='TARGETID')
                    if np.all(zcat['COADD_FIBERSTATUS_1'] == zcat['COADD_FIBERSTATUS_2']):
                        zcat.remove_column('COADD_FIBERSTATUS_2')
                        zcat.rename_column('COADD_FIBERSTATUS_1', 'COADD_FIBERSTATUS')
                    else:
                        raise ValueError('Mismatch here')
                    zcat['SELECTION'] = selection
                    allzcat.append(zcat)
                allzcat = vstack(allzcat)
                allzcat.write(out_zcatfile, overwrite=True)
                log.info(f'Wrote {len(allzcat):,d} objects to {out_zcatfile}')


def _zstats(z, ztrue, spectype=None):
    N = len(z)
    if N == 0:
        return N, np.array([]), ''
    dz = z - ztrue
    #Idoom = np.where(C_LIGHT * np.abs(dz) > 1e3)[0]
    Idoom = np.where((C_LIGHT * np.abs(dz) / (1. + ztrue)) > 1e3)[0]
    txt = [f'N={N}',
           f'M={len(Idoom)} ({100*len(Idoom)/N:.2f}%)'
           #f'N(|dv|>1000 km/s)={len(Idoom)} ({100*len(Idoom)/N:.1f} %)'
           ]
    if spectype:
        txt = [f'RR: {spectype}'] + txt
            
    return N, Idoom, txt


def qa_zcompleteness(specprod='iron'):
    """Redshift completeness results.

    """
    from matplotlib.lines import Line2D
    
    def zbins(targtype, dz=0.1, edges=False):
        zmin, zmax = zlims[targtype]
        if edges:
            bins = np.arange(zmin, zmax, dz) # bin left edges
        else:
            bins = np.arange(zmin, zmax, dz) + dz / 2 # bin centers
        return bins

    def dchi2bins(hist=False):
        mn, mx, dx = 0.5, 4.9, 0.2
        bins = np.arange(mn, mx, dx) # bin left edges
        bins = np.hstack((bins, np.max(bins) + dx)) # include right-most edge
        if hist:
            return bins
        else:
            return bins[1:]

    def dchi2hist(dchi2):
        bins = dchi2bins()
        hist, _ = np.histogram(dchi2, bins=dchi2bins(hist=True))
        return bins, hist

    def _makeplot(cats, labels, targtype, targclass, dvcut=1e3):

        dchi2cut = dchi2dict[targtype]

        sns.set_palette('Set2')
        colors1 = sns.color_palette('muted')
        colors2 = sns.color_palette('dark')
        colors1 = np.array([colors1[3], colors1[0], colors1[2], colors1[1]])[:len(cats)]
        colors2 = np.array([colors2[3], colors2[0], colors2[2], colors2[1]])[:len(cats)]

        fig, ax = plt.subplots(figsize=(8, 6))
        for cat, col1, col2, label in zip(cats, colors1, colors2, labels):
            # redshift success
            G = (C_LIGHT * np.abs(cat['Z_RR'] - cat['VI_Z']) / (1. + cat['VI_Z'])) < dvcut # good
            H = ~G # bad
            bins, numer = dchi2hist(np.log10(cat['DELTACHI2'][G]))
            _, denom = dchi2hist(np.log10(cat['DELTACHI2']))
            cnumer = np.cumsum(numer)
            cdenom = np.cumsum(denom)
            frac = np.zeros_like(bins)
            W = denom > 0
            if np.any(W):
                #frac = cnumer[W] / cdenom[W]
                frac[W] = numer[W] / denom[W]
                #print(label, bins[W], frac)
                ax.plot(bins[W], frac[W], color=col1, ls='-', lw=3,
                        label=f'{label} (N={len(cat):,d})')#, marker=marker)
                        #label=f'{label}: Redshift Success')#, marker=marker)
            # cumulative fraction with <deltach2
            frac = 1 - np.cumsum(denom) / len(cat)
            ax.plot(bins, frac, color=col2, ls='--', lw=3)#, label=r'{}: $F(>\Delta\chi^2)$'.format(label))#, marker=marker)
                
        ax.axhline(y=1, color='k', lw=1, ls='-', alpha=0.5)
        if dchi2cut is not None:
            ax.axvline(x=np.log10(dchi2cut), color='k', ls='-', lw=1, alpha=0.5)
        ax.set_ylim(0, 1.25)
        ax.set_xlim(0.5, 5)
        ax.margins(x=0)
        ax.set_xlabel(r'$\log_{10} (\Delta\chi^2)$')
        ax.set_ylabel('Fraction')
        #txt = [targclass, f'N={len(new)}']
        #ax.text(0.96, 0.96, '\n'.join(txt), va='top', ha='right',
        #        transform=ax.transAxes, fontsize=12)#, bbox=bbox)
        if dchi2cut is not None:
            xytext = (0.6, 1.06)
            if np.log10(dchi2cut) < 1.18:
                xytext = (1.5, 1.06)
            ax.annotate(r'$\Delta\chi^2='+f'{dchi2cut:.0f}$', xy=(np.log10(dchi2cut), 1.02), xytext=xytext,
                        xycoords='data', arrowprops=dict(alpha=0.5, facecolor='black', lw=1, shrink=0.001),
                        va='bottom', ha='left', fontsize=12)

        #srt = [1, 3, 0, 2]
        hh, ll = ax.get_legend_handles_labels()
        leg1 = ax.legend(hh, ll, fontsize=12, loc='upper right', bbox_to_anchor=(0.4, 0., 0.5, 0.5))
        #ax.legend([hh[ii] for ii in srt], [ll[ii] for ii in srt], fontsize=10, loc='lower right')
        #ax.legend(fontsize=10)
        ax.add_artist(leg1)

        leg2 = ax.legend([Line2D([0], [0], ls='--', color='k', lw=2),
                          Line2D([0], [0], color='k', ls='-', lw=2)],
                          [r'Completeness: Fraction$(>\Delta\chi^2)$', r'Success: $|\Delta z|/(1+z)<{:.0f}$ km/s'.format(dvcut)],
                          fontsize=10, loc='upper right')
        ax.add_artist(leg2)
        
        #twin_ax = ax.twinx()
        #twin_ax.set_ylabel('Sample Completeness Fraction')
        #twin_ax.set_ylim(0, 1.1)
    
        fig.tight_layout()
        pngfile = os.path.join(qadir, f'qa-dchi2cut-{targclass}.png')
        fig.savefig(pngfile)
        log.info(f'Wrote {pngfile}')

    # zscan02 - desihiz healpixels
    zscan = 'zscan02'
    #zcatfile = os.path.join(projectdir, f'zcat-{specprod}templates-desihiz.fits')
    #zcat_old = Table(fitsio.read(zcatfile))
    #zcat_old['LAE-LBG'] = np.ones(len(zcat_old), bool)
    #log.info(f'Read {len(zcat_old)} objects from {zcatfile}')
    #old = zcat_old[zcat_old['LAE-LBG'] * (zcat_old['ZWARN'] == 0) * (zcat_old['COADD_FIBERSTATUS'] == 0)]

    zcatfile = os.path.join(projectdir, f'zcat-newtemplates-desihiz-{zscan}.fits')
    zcat = Table(fitsio.read(zcatfile))
    log.info(f'Read {len(zcat)} objects from {zcatfile}')
    cats = []
    for selection in ['odin', 'clauds', 'suprime']:
        I = ((zcat['SELECTION'] == selection) * (zcat['ZWARN'] == 0) * (zcat['COADD_FIBERSTATUS'] == 0) *
             np.isfinite(zcat['VI_Z']) * (zcat['VI_Z'] > 1e-3) * (zcat['VI_QUALITY'] >= 3.))
        cats.append(zcat[I])
    _makeplot(cats, labels=['odin', 'clauds', 'suprime'], targtype='desihiz', targclass='desihiz')#, dvcut=250.)

    return

    # zscan01 - VI tiles
    zcatfile = os.path.join(projectdir, f'zcat-{specprod}.fits')
    zcat_old = Table(fitsio.read(zcatfile))
    log.info(f'Read {len(zcat_old)} objects from {zcatfile}')
    
    zcatfile = os.path.join(projectdir, f'zcat-{specprod}-zscan01.fits')
    zcat_new = Table(fitsio.read(zcatfile))
    log.info(f'Read {len(zcat_new)} objects from {zcatfile}')
    assert(np.all(zcat_old['TARGETID'] == zcat_new['TARGETID']))
    
    targtypes = ['BGS', 'BGS', 'LRG', 'ELG', 'QSO']
    targclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO']
    for targtype, targclass in zip(targtypes, targclasses):
        old = zcat_old[zcat_old[targclass] * (zcat_old['ZWARN'] == 0) * (zcat_old['COADD_FIBERSTATUS'] == 0)]
        new = zcat_new[zcat_new[targclass] * (zcat_new['ZWARN'] == 0) * (zcat_new['COADD_FIBERSTATUS'] == 0)]
        _makeplot(old, new, targtype, targclass)
        
def qa_zvz(specprod='iron'):
    """Redshift vs redshift fitting results.

    """
    # make the plots
    sns.set(context='talk', style='ticks', font_scale=0.7, palette='Set2')

    def _plot_onerow(rowaxes, cat, targtype, remove_xticklabels=False, ylabel=None, desihiz=False):

        if desihiz:
            dchi2cut = dchi2dict['desihiz']
        else:
            dchi2cut = dchi2dict[targtype]
            
        zwarn = (cat['ZWARN'] == 0)
        coadd_fiberstatus = (cat['COADD_FIBERSTATUS'] == 0)
        I = np.where(coadd_fiberstatus * zwarn)[0]
        
        if dchi2cut is not None:
            J = np.where(coadd_fiberstatus * zwarn * (cat['DELTACHI2'] > dchi2cut))[0]
            dchi2txt = [r'$\Delta\chi^2>{:.1f}$'.format(dchi2cut)]
        else:
            J = I
            dchi2txt = [r'No $\Delta\chi^2$ cut']

        goodcat = cat[J]
        cat = cat[I]

        bbox = dict(boxstyle='round', facecolor='lightgray', alpha=0.8)
        
        if desihiz:
            vi_spectypes = np.array(['LBG', 'LAE', 'QSO', 'Interloper'])
            vi_colors = np.array(['tomato', 'purple', 'dodgerblue', 'forestgreen'])
            vi_facecolors = np.array(['red', 'purple', 'blue', 'darkgreen'])
            vi_markers = np.array(['s', 'o', '^', 'x'])
        else:
            vi_spectypes = np.array(['GALAXY', 'QSO', 'STAR'])
            vi_colors = np.array(['tomato', 'dodgerblue', 'forestgreen'])
            vi_facecolors = np.array(['red', 'blue', 'darkgreen'])
            vi_markers = np.array(['s', 'o', 'x'])

        for ixx, (xx, plotcat, spectype) in enumerate(zip(rowaxes,
                                                          [cat, goodcat, goodcat, goodcat, goodcat],
                                                          [None, None, 'GALAXY', 'QSO', 'STAR'])):
            if spectype is not None:
                S = np.where(plotcat['SPECTYPE'] == spectype)[0]
            else:
                S = np.arange(len(plotcat))

            N, Idoom, statstxt = _zstats(plotcat['Z_RR'][S], plotcat['VI_Z'][S])#, spectype=spectype)
            if spectype and len(S) > 0:
                #print('#####', spectype)
                if 'VI_SPECTYPE' in plotcat.colnames:                
                    #print(plotcat[S][Idoom]['Z_RR', 'VI_Z', 'ZWARN', 'SPECTYPE', 'VI_SPECTYPE', 'DELTACHI2'])
                    pass
                else:
                    #print(plotcat[S][Idoom]['Z_RR', 'VI_Z', 'ZWARN', 'SPECTYPE', 'DELTACHI2'])
                    pass

            if spectype == 'STAR' and len(S) > 0:
                zmax = 1.5 * C_LIGHT * np.max(np.abs(plotcat['Z_RR'][S]))
                if 'VI_SPECTYPE' in plotcat.colnames:
                    nsort = np.argsort([np.sum(plotcat['VI_SPECTYPE'][S] == vi_spectype) for vi_spectype in vi_spectypes])[::-1]
                    for vi_spectype, vi_color in zip(vi_spectypes[nsort], vi_colors[nsort]):
                        V = np.where(plotcat['VI_SPECTYPE'][S] == vi_spectype)[0]
                        #print(vi_spectype, len(V))
                        if len(V) > 0:
                            xx.hist(C_LIGHT * plotcat['Z_RR'][S][V], bins=10, range=(-zmax, +zmax),
                                    color=vi_color)
                else:
                    xx.hist(C_LIGHT * plotcat['Z_RR'][S], bins=10, range=(-zmax, +zmax))
                
                xx.set_xlim(-zmax*1.1, +zmax*1.1)
                xx.set_yticklabels([])
                xx_twin = xx.twinx()
                xx_twin.set_yticklabels([])
                xx_twin.set_ylabel('Number')
                if not remove_xticklabels:
                    xx.set_xlabel('RR Redshift [km/s]')
                txt = dchi2txt + [f'RR: {spectype}']
                xx.text(0.06, 0.96, '\n'.join(txt), va='top', ha='left',
                        transform=xx.transAxes, fontsize=9, bbox=bbox)
                xx.text(0.96, 0.06, f'N={len(S)}', va='bottom', ha='right',
                        transform=xx.transAxes, fontsize=9, bbox=bbox)
            else:
                if 'VI_SPECTYPE' in plotcat.colnames:
                    nsort = np.argsort([np.sum(plotcat['VI_SPECTYPE'][S] == vi_spectype) for vi_spectype in vi_spectypes])[::-1]
                    for vi_spectype, vi_color, vi_facecolor, vi_marker in zip(vi_spectypes[nsort], vi_colors[nsort], vi_facecolors[nsort], vi_markers[nsort]):
                        V = np.where(plotcat['VI_SPECTYPE'][S] == vi_spectype)[0]
                        #print(vi_spectype, len(V))
                        if len(V) > 0:
                            xx.scatter(plotcat['VI_Z'][S][V], plotcat['Z_RR'][S][V], s=20, alpha=0.7,
                                       color=vi_color, marker=vi_marker, facecolor=vi_facecolor,
                                       label=f'VI: {vi_spectype}')
                else:
                    xx.scatter(plotcat['VI_Z'][S], plotcat['Z_RR'][S], s=20, alpha=0.7,
                               facecolor='blue', color='dodgerblue', marker='s')
    
                if ixx == 0:
                    #txt = ['zwarn==0', 'coadd_fiberstatus==0']
                    txt = ['All (no warnings)']
                    extratxt = [f'N(zwarn!=0): {np.sum(~zwarn)}', f'N(coadd_fiberstatus)!=0: {np.sum(~coadd_fiberstatus)}']
                else:
                    txt = dchi2txt
                    extratxt = None
                    xx.set_yticklabels([])
                if spectype:
                    txt = dchi2txt + [f'RR: {spectype}']
    
                xx.text(0.06, 0.96, '\n'.join(txt), va='top', ha='left',
                        transform=xx.transAxes, fontsize=9, bbox=bbox)
                if extratxt:
                    xx.text(0.06, 0.86, '\n'.join(extratxt), va='top', ha='left',
                            transform=xx.transAxes, fontsize=7, bbox=bbox)
                    
                xx.text(0.96, 0.06, '\n'.join(statstxt), va='bottom', ha='right',
                        transform=xx.transAxes, fontsize=9, bbox=bbox)

            if ixx == len(rowaxes)-1:
                hh, ll = rowaxes[0].get_legend_handles_labels()                
                xx.legend(hh, ll, loc='upper right', fontsize=7)

        if remove_xticklabels:
            for xx in rowaxes:
                xx.set_xticklabels([])
                
        if ylabel:
            rowaxes[0].set_ylabel(ylabel)

    def _plot_allrows(old, new, targtype, zscan, targclass=None, desihiz=False):
        fig, axes = plt.subplots(2, 5, figsize=(14, 6))#, sharex=True, sharey=True)

        if desihiz:
            ylabel = 'Redshift [new templates]'
        else:
            ylabel = 'Redshift [Iron]'

        # top row - old templates
        _plot_onerow(axes[0, :], old, targtype, remove_xticklabels=True, ylabel=ylabel, desihiz=desihiz)

        # bottom row - new templates
        _plot_onerow(axes[1, :], new, targtype, ylabel='Redshift [New]', desihiz=desihiz)

        if desihiz:
            zlim = zlims[f'desihiz-{zscan}']
        else:
            zlim = zlims[f'{targtype}-{zscan}']
            
        for xx in axes[:, :-1].flat:
            xx.set_xlim(zlim)
            xx.set_ylim(zlim)
            xx.plot(zlim, zlim, color='k', lw=1, alpha=0.5, zorder=0)

        if targtype == 'desihiz':
            axes[-1, -1].set_xticklabels([])            

        if targtype == 'desihiz':
            Qcut = '3' # higher cut
        else:
            Qcut = '2.5'

        # x-label
        llpos = axes[-1, 0].get_position()
        lrpos = axes[-1, -2].get_position()
        xpos = (lrpos.x1 - llpos.x0) / 2 + llpos.x0
        ypos = llpos.y0 - 0.07
        fig.text(xpos, ypos, f'Redshift [VI; Q>{Qcut}]', ha='center', va='center')
            
        # title
        ulpos = axes[0, 0].get_position()
        urpos = axes[0, -1].get_position()
        xpos = (urpos.x1 - llpos.x0) / 2 + llpos.x0
        ypos = ulpos.y1 + 0.06
        fig.text(xpos, ypos, f'{targclass}', ha='center', va='center')
            
        fig.subplots_adjust(bottom=0.13, left=0.07, right=0.95, top=0.9, wspace=0.1, hspace=0.1)
        pngfile = os.path.join(qadir, f'zvz-{zscan}-{targclass}.png')
        fig.savefig(pngfile)
        log.info(f'Wrote {pngfile}')

    def _plot_all_targetclass(cats, targtypes, targclasses, zscan, pngfile, desihiz=False):

        ncat = len(cats)

        if desihiz:
            ylabel = 'RR Redshift'
        else:
            ylabel = 'Redshift [Iron]'

        fig, axes = plt.subplots(len(cats), 5, figsize=(14, len(cats)*3))

        for ii in range(ncat):
            remxlabels = ii < ncat-1
            _plot_onerow(axes[ii, :], cats[ii], targtypes[ii], remove_xticklabels=remxlabels,
                         ylabel=f'{targclasses[ii]}\n {ylabel}', desihiz=desihiz)
            if desihiz:
                zlim = zlims[f'desihiz-{zscan}']
            else:
                zlim = zlims[f'{targtype}-{zscan}']

            for xx in axes[ii, :-1].flat:
                xx.set_xlim(zlim)
                xx.set_ylim(zlim)
                xx.plot(zlim, zlim, color='k', lw=1, alpha=0.5, zorder=0)

        if desihiz:
            Qcut = '3'
        else:
            Qcut = '2.5'

        # x-label
        llpos = axes[-1, 0].get_position()
        lrpos = axes[-1, -2].get_position()
        xpos = (lrpos.x1 - llpos.x0) / 2 + llpos.x0
        ypos = llpos.y0 - 0.07 # 0.05
        fig.text(xpos, ypos, f'Redshift [VI; Q>{Qcut}]', ha='center', va='center')
            
        fig.subplots_adjust(bottom=0.1, left=0.07, right=0.95, top=0.95, wspace=0.1, hspace=0.1)
        fig.savefig(pngfile)
        log.info(f'Wrote {pngfile}')

    # zscan02 - VI healpixels
    zscan = 'zscan02'

    pngfile = os.path.join(qadir, f'zvz-{zscan}-desihiz.png')
    select = ['suprime', 'odin', 'clauds']
    zcatfile = os.path.join(projectdir, f'zcat-newtemplates-desihiz-{zscan}.fits')    
    #zcatfile = os.path.join(projectdir, f'zcat-{specprod}templates-desihiz.fits')
    zcat = Table(fitsio.read(zcatfile))
    log.info(f'Read {len(zcat)} objects from {zcatfile}')
    zcat.rename_column('VI_SPECTYPE', 'VI_SPECTYPE_ORIG')
    zcat['VI_SPECTYPE'] = ['Interloper'] # default
    I = ['LBG' in comment.upper() or 'LBG' in otype.upper() for comment, otype in zip(zcat['VI_COMMENTS'], zcat['VI_SPECTYPE_ORIG'])]
    zcat['VI_SPECTYPE'][I] = 'LBG'
    I = ['LAE' in comment.upper() or 'LAE' in otype.upper() for comment, otype in zip(zcat['VI_COMMENTS'], zcat['VI_SPECTYPE_ORIG'])]
    zcat['VI_SPECTYPE'][I] = 'LAE'
    I = ['QSO' in comment.upper() or 'QSO' in otype.upper() for comment, otype in zip(zcat['VI_COMMENTS'], zcat['VI_SPECTYPE_ORIG'])]
    zcat['VI_SPECTYPE'][I] = 'QSO'
    cats = []
    for selection in select:
        I = ((zcat['SELECTION'] == selection) * #(zcat['ZWARN'] == 0) * (zcat['COADD_FIBERSTATUS'] == 0) *
             np.isfinite(zcat['VI_Z']) * (zcat['VI_Z'] > 1e-3) * (zcat['VI_QUALITY'] >= 3.))
        cats.append(zcat[I])
    _plot_all_targetclass(cats, select, select, zscan='zscan02', pngfile=pngfile, desihiz=True)

    return

    #zscan = 'zscan02'
    #zcatfile = os.path.join(projectdir, f'zcat-{specprod}templates-desihiz.fits')
    #zcat_old = Table(fitsio.read(zcatfile))
    #log.info(f'Read {len(zcat_old)} objects from {zcatfile}')
    #
    #zcatfile = os.path.join(projectdir, f'zcat-newtemplates-desihiz-{zscan}.fits')    
    #zcat_new = Table(fitsio.read(zcatfile))
    #zcat_new['LAE-LBG'] = np.ones(len(zcat_new), bool)
    #log.info(f'Read {len(zcat_new)} objects from {zcatfile}')
    #assert(np.all(zcat_old['TARGETID'] == zcat_new['TARGETID']))
    #
    #targtypes = ['desihiz']
    #targclasses = ['desihiz']
    #for targtype, targclass in zip(targtypes, targclasses):
    #    I = zcat_new[targclass]
    #    _plot_allrows(zcat_old[I], zcat_new[I], targtype=targtype, zscan=zscan, targclass=targclass)

    # zscan01,zscan02 - VI tiles, all targets
    for zscan in ['zscan01', 'zscan02']:
        pngfile = os.path.join(qadir, f'zvz-{zscan}-all.png')
        zcatfile = os.path.join(projectdir, f'zcat-{specprod}-{zscan}.fits')
        zcat_new = Table(fitsio.read(zcatfile))
        log.info(f'Read {len(zcat_new)} objects from {zcatfile}')
    
        targtypes = ['BGS', 'BGS', 'LRG', 'ELG', 'QSO']
        targclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO']
        cats = [zcat_new[zcat_new[targclass]] for targclass in targclasses]
        # hard-code zscan here so we get consistent redshift limits.
        _plot_all_targetclass(cats, targtypes, targclasses, zscan='zscan02', pngfile=pngfile) 

    # zscan01 - VI tiles
    zscan = 'zscan01'
    zcatfile = os.path.join(projectdir, f'zcat-{specprod}.fits')
    zcat_old = Table(fitsio.read(zcatfile))
    log.info(f'Read {len(zcat_old)} objects from {zcatfile}')

    zcatfile = os.path.join(projectdir, f'zcat-{specprod}-{zscan}.fits')
    zcat_new = Table(fitsio.read(zcatfile))
    log.info(f'Read {len(zcat_new)} objects from {zcatfile}')
    assert(np.all(zcat_old['TARGETID'] == zcat_new['TARGETID']))

    targtypes = ['BGS', 'BGS', 'LRG', 'ELG', 'QSO']
    targclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO']
    for targtype, targclass in zip(targtypes, targclasses):
        I = zcat_new[targclass]
        _plot_allrows(zcat_old[I], zcat_new[I], targtype=targtype, zscan=zscan, targclass=targclass)

    # zscan02 - VI tiles
    zscan = 'zscan02'
    zcatfile = os.path.join(projectdir, f'zcat-{specprod}.fits')
    zcat_old = Table(fitsio.read(zcatfile))
    log.info(f'Read {len(zcat_old)} objects from {zcatfile}')

    zcatfile = os.path.join(projectdir, f'zcat-{specprod}-{zscan}.fits')
    zcat_new = Table(fitsio.read(zcatfile))
    log.info(f'Read {len(zcat_new)} objects from {zcatfile}')
    assert(np.all(zcat_old['TARGETID'] == zcat_new['TARGETID']))

    targtypes = ['BGS', 'BGS', 'LRG', 'ELG', 'QSO']
    targclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO']
    for targtype, targclass in zip(targtypes, targclasses):
        I = zcat_new[targclass]
        _plot_allrows(zcat_old[I], zcat_new[I], targtype=targtype, zscan=zscan, targclass=targclass)


def build_redrock_templates(specprod='iron', niter=10, ncomp=10, minwave=400., dwave=0.2, nmf=False):
    """Build new templates."""

    import redrock
    from astropy.io import fits

    flux = []
    for targtype in ['BGS_ANY', 'LRG', 'ELG']:
        templatefile = os.path.join(datadir, f'ftemplates-{specprod}-{targtype}.fits')
        log.info(f'Reading {templatefile}')
        flux.append(fitsio.read(templatefile, 'FLUX'))#, rows=np.arange(10)))

    # add desihiz
    templatefile = os.path.join(datadir, 'ftemplates-vi-desihiz.fits')
    log.info(f'Reading {templatefile}')
    flux.append(fitsio.read(templatefile, 'FLUX'))#, rows=np.arange(10)))
        
    flux = np.vstack(flux) # [ngal, nwave]
    ngal = flux.shape[0]

    if nmf:
        from nearly_nmf.nmf import fit_NMF
        pdb.set_trace()
        H, W = fit_NMF(X=flux, V=np.ones_like(flux), n_templates=ncomp)
    else:
        from empca import empca
        model = empca(flux, niter=niter, nvec=ncomp)
        
        empca_eigenvec = model.eigvec  # [ncomp, npix]
        empca_eigencoeff = model.coeff # [ngal, ncomp]
        empca_model = empca_eigencoeff.dot(empca_eigenvec)
    
    header = fits.Header()
    header['CRVAL1'] = (minwave, 'restframe starting wavelength [Angstroms]')
    header['CDELT1'] = dwave
    header['RRTYPE']   = 'GALAXY'
    header['RRSUBTYP'] = ''
    header['RRVER'] = redrock.__version__
    header['VERSION'] = ('TBD', 'Template version')
    #header['INSPEC'] = os.environ['DESI_BASIS_TEMPLATES']
    #header['SEED'] = opts.seed
    header['EXTNAME'] = 'BASIS_VECTORS'
    
    hdus = fits.HDUList()
    hdus.append(fits.PrimaryHDU(empca_eigenvec, header=header))
    hdus.append(fits.ImageHDU(empca_eigencoeff, name='ARCHETYPE_COEFF'))
    hdus.writeto(rrtemplatefile, overwrite=True)
    log.info(f'Wrote {rrtemplatefile}')
    

def qa_redrock_templates(ncomp=10):
    """QA of the new redrock templates.

    """
    # read the rrtemplate-galaxy models
    #from redrock.templates import Template
    #rrtemp = Template(rrtemplatefile)

    hdr = fitsio.read_header(rrtemplatefile, ext='BASIS_VECTORS')
    ncomp = hdr['NAXIS2']
    wave = np.arange(hdr['NAXIS1']) * hdr['CDELT1'] + hdr['CRVAL1']

    empca_eigenvec = fitsio.read(rrtemplatefile, ext='BASIS_VECTORS')     # H matrix - [ncomp, npix]
    empca_eigencoeff = fitsio.read(rrtemplatefile, ext='ARCHETYPE_COEFF') # W matrix - [ngal, ncomp]
    empca_model = empca_eigencoeff.dot(empca_eigenvec) # [ngal, npix]

    if False:
        specprod = 'iron'
        flux = []
        for targtype in ['BGS_ANY', 'LRG', 'ELG']:
            templatefile = os.path.join(datadir, f'ftemplates-{specprod}-{targtype}.fits')
            log.info(f'Reading {templatefile}')
            flux.append(fitsio.read(templatefile, 'FLUX'))
        flux = np.vstack(flux) # [ngal, nwave]

        fig, ax = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(10, 8))
        for igal, xx in enumerate(ax.flat):
            xx.plot(wave, flux[igal, :])
            xx.plot(wave, empca_model[igal, :], color='red', alpha=0.5, lw=1)
            xx.set_yscale('log')
        fig.tight_layout()
        pngfile = os.path.join(qadir, f'qa-empca-models.png')
        fig.savefig(pngfile)
        log.info(f'Wrote {pngfile}')

    pngfile = os.path.join(qadir, 'rrtemplate-galaxy.png')

    #from speclite import filters
    #filt = filters.load_filters('decam2014-g', 'decam2014-r')
    #padflux, padwave = filt.pad_spectrum(nmf_eigenvec, wave, axis=0, method='edge')
    #mags = filt.get_ab_magnitudes(padflux, padwave) # speclite.filters wants an [nmodel,npix] array
    #gr = mags['decam2014-g'] - mags['decam2014-r']
    #srt = np.argsort(gr)

    ylim = np.percentile(empca_eigenvec, [0.1, 99.9])

    fig, ax = plt.subplots()#figsize=(8, 5))
    I = np.arange(len(wave))
    #I = np.where((wave > 3727-20) * (wave < 3727+20))[0]
    #I = np.where(wave < 900.)[0]

    current_palette = sns.color_palette()
    sns.set_palette('coolwarm', empca_eigenvec.shape[0])
    colors = iter(sns.color_palette())

    # plot in reverse order, so the most important templates are on top
    for ic in range(ncomp-1, -1, -1):
    #for ic in range(ncomp):
        yplot = empca_eigenvec[ic, I] / np.std(empca_eigenvec[ic, I])
        ax.plot(wave[I], yplot, alpha=0.9, color=next(colors), lw=1)
    #for ii, ic in enumerate(srt):
        #I = np.where(empca_eigenvec[ic, :] > 0)[0]
        #ax.plot(wave[I]/1e4, empca_eigenvec[ic, I] + ii)
    #ax.set_ylim(ylim) # -0.01, 0.01)
    ax.set_ylim(-6, 6)#7.5, 7.5)
    #ax.set_xlim(3727-20, 3727+20)
    #ax.set_yticklabels([])
    ax.set_xlabel(r'Rest-frame Wavelength ($\AA$)')
    ax.set_ylabel(r'$F\ /\ \sigma_{F}$')
    #ax.set_ylabel(r'Normalized Flux (+offsets)')
    ax.margins(x=0)
    #ax.set_xscale('log')
    #ax.xaxis.set_major_formatter(ticker.FuncFormatter(lambda y, _: '{:g}'.format(y)))
    fig.tight_layout()
    fig.savefig(pngfile)
    log.info(f'Wrote {pngfile}')
    sns.set_palette(current_palette)

def qa_fastspecfit(specprod='iron'):
    """QA of the FastSpecFit fitting results."""
    
    from desispec.io.spectra import read_spectra
    from desispec.coaddition import coadd_cameras    
    from desispec.resolution import Resolution
    from desispec.interpolation import resample_flux
    from redrock.templates import Template
    from fastspecfit.io import read_fastspecfit

    # read the rrtemplate-galaxy models
    rrtemp = Template(rrtemplatefile)
    
    #hdr = fitsio.read_header(rrtemplatefile, ext='BASIS_VECTORS')
    #ncomp = hdr['NAXIS2']
    #rrwave = np.arange(hdr['NAXIS1']) * hdr['CDELT1'] + hdr['CRVAL1']
    #rreigenflux = fitsio.read(rrtemplatefile, ext='BASIS_VECTORS')     # H matrix - [ncomp, npix]

    # read the fastspec results
    
    iron_fastfiles = sorted(glob(os.path.join(fastdir, f'fastspec-{specprod}-*.fits.gz')))
    for iron_fastfile in iron_fastfiles:
        new_fastfile = iron_fastfile.replace(specprod, 'new')

        newfast, newmeta, _, _, newmodels = read_fastspecfit(new_fastfile, read_models=True)
        ironfast, ironmeta, _, _, ironmodels = read_fastspecfit(iron_fastfile, read_models=True)

        petal, tileid = str(newmeta['FIBER'][0] // 500), str(newmeta['TILEID'][0])
        coaddfile = os.path.join(reduxdir, f'coadd-{petal}-{tileid}.fits')
        redrockfile = os.path.join(reduxdir, f'redrock-{petal}-{tileid}.fits')

        spec = read_spectra(coaddfile, targetids=ironmeta['TARGETID'].data)
        coadd_spec = coadd_cameras(spec)
        log.info(f'Read {spec.num_targets} targets from {coaddfile}')
        
        zbest = Table(fitsio.read(redrockfile, 'REDSHIFTS'))
        zbest = zbest[geomask.match_to(zbest['TARGETID'], ironmeta['TARGETID'])]
        assert(np.all(zbest['TARGETID'] == ironmeta['TARGETID']))
        assert(np.all(zbest['TARGETID'] == newmeta['TARGETID']))
        log.info(f'Read {len(zbest)} targets from {redrockfile}')

        igal = 0

        wave = coadd_spec.wave['brz']
        flux = coadd_spec.flux['brz'][igal, :]
        R = Resolution(coadd_spec.resolution_data['brz'][igal])

        # resample and convolve
        rrwave = rrtemp.wave * (1 + zbest['Z'][igal])
        rrflux = R.dot(resample_flux(wave, rrtemp.flux.T.dot(zbest['COEFF'][igal]), rrwave))

        fig, ax = plt.subplots()
        ax.plot(wave, flux)
        ax.plot(wave, rrflux, color='red')
        ax.set_xlim(3600, 9800)
        ax.set_ylim(np.min(flux), np.max(flux))
        pngfile = os.path.join(qadir, f'qa-fastspec.png')
        fig.savefig(pngfile)
        log.info(f'Wrote {pngfile}')

        pdb.set_trace()

def main():
    """Main wrapper."""

    import argparse

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--desihiz-fastspec', action='store_true', help='Run fastspec on the desihiz sample.')
    parser.add_argument('--desihiz-fastspec-qa', action='store_true', help='Generate QA from the desihiz sample.')
    parser.add_argument('--desihiz-gather-fastspec', action='store_true', help='Gather the desihiz fastspec results.')

    parser.add_argument('--match-lss', action='store_true', help='Match to the LSS catalogs (no figures, just catalogs).')

    parser.add_argument('--parent-qa', action='store_true', help='QA of the parent sample.')
    parser.add_argument('--desihiz-parent-templates', action='store_true', help='Build the parent desihiz rest-frame templates.')
    parser.add_argument('--desimain-parent-templates', action='store_true', help='Build the parent desimain rest-frame templates.')

    parser.add_argument('--empca-templates', action='store_true', help='Run empca on the output of --parent-templates.')
    parser.add_argument('--nmf-templates', action='store_true', help='Run NMF on the output of --parent-templates.')
    parser.add_argument('--template-qa', action='store_true', help='Template QA.')
    parser.add_argument('--gather-specprod-results', action='store_true', help='Gather the specprod Redrock results for the VI tiles/healpixels.')
    parser.add_argument('--run-redrock', action='store_true', help='Run Redrock on the VI tiles/healpixels.')
    parser.add_argument('--redshift-qa', action='store_true', help='Redshift QA.')
    parser.add_argument('--run-fastspecfit', action='store_true', help='Run FastSpecFit on the RedRock outliers.')
    parser.add_argument('--fastspecfit-qa', action='store_true', help='FastSpecFit QA.')

    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')
    parser.add_argument('--minwave', type=float, default=400., help='Minimum template wavelength (Angstrom).')
    parser.add_argument('--maxwave', type=float, default=1.1e4, help='Maximum template wavelength (Angstrom).')
    parser.add_argument('--dwave', type=float, default=0.2, help='Template wavelength spacing (Angstrom).')
    parser.add_argument('--niter', type=int, default=10, help='Number of PCA iterations.')
    parser.add_argument('--ncomp', type=int, default=10, help='Number of PCA components.')
    parser.add_argument('--ntargets', type=int, help='Number of targets to process.')
    parser.add_argument('--targetids', type=str, default=None, help='Comma-separated list of TARGETIDs to process.')    
    parser.add_argument('--nolog', action='store_true', help='Do not write a log (useful for debugging).')
    
    parser.add_argument('--specprod', default='iron', help='Spectroscopic production.')
    parser.add_argument('--lss-specprod', default='fuji', help='Spectroscopic production used for the LSS catalogs.')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing QA files.')    
    args = parser.parse_args()

    # https://docs.nersc.gov/development/languages/python/parallel-python/#use-the-spawn-start-method
    if args.mp > 1 and 'NERSC_HOST' in os.environ:
        import multiprocessing
        multiprocessing.set_start_method('spawn')

    rand = np.random.RandomState(seed=1)

    # run fastspec on the VId desihiz sample.
    if args.desihiz_fastspec:
        desihiz_fastspec(vi_redshifts=True, nolog=args.nolog, mp=args.mp, overwrite=args.overwrite)

    if args.desihiz_fastspec_qa:
        desihiz_fastspec_qa(vi_redshifts=True, ntargets=args.ntargets, targetids=args.targetids,
                            mp=args.mp, overwrite=args.overwrite)

    # gather the desihiz fastspec results
    if args.desihiz_gather_fastspec:
        desihiz_gather_fastspec(mp=args.mp, overwrite=args.overwrite)

    # build the parent samples
    if args.match_lss:
        match_lss(specprod=args.specprod, lss_specprod=args.lss_specprod, overwrite=args.overwrite)

    if args.parent_qa:
        parent_qa(specprod=args.specprod, lss_specprod=args.lss_specprod)

    # build the rest-frame templates - desihiz
    if args.desihiz_parent_templates:
        from fastspecfit.io import read_fastspecfit
        fast, meta = [], []
        for selection, nrows in zip(['suprime', 'odin', 'clauds'], [500, 500, 500]):
            fastfile = os.path.join(datadir, f'fastspec-vi-desihiz-{selection}.fits')
            allfast, allmeta, _, _ = read_fastspecfit(fastfile)

            I = (allfast['LOGMSTAR'] > 0.) * (allmeta['Z'] > 2.) * (allmeta['Z'] < 4.)
            allfast = allfast[I]
            allmeta = allmeta[I]

            I = rand.choice(len(allmeta), size=nrows, replace=False)
            fast.append(allfast[I])
            meta.append(allmeta[I])

        fast = vstack(fast)
        meta = vstack(meta)
    
        outfile = os.path.join(datadir, f'ftemplates-vi-desihiz.fits')            
        restframe_templates(fast, meta, outfile, minwave=args.minwave,
                            maxwave=args.maxwave, dwave=args.dwave)
        
    # build the rest-frame templates - desi-main
    if args.desimain_parent_templates:
        for targtype, nrows in zip(['BGS_ANY', 'LRG', 'ELG'], [10000, 5000, 5000]):
            data = read_clustering(targetclass=targtype, read_lss=True, trim_broad=True)#, rows=np.arange(10))
            fast, meta, lss = data[targtype]['fast'], data[targtype]['meta'], data[targtype]['lss']
            del data
            weight = lss['WEIGHT'] / np.sum(lss['WEIGHT'])
            I = rand.choice(len(meta), size=nrows, p=weight, replace=False)

            outfile = os.path.join(datadir, f'ftemplates-{args.specprod}-{targtype}.fits')            
            restframe_templates(fast[I], meta[I], outfile, minwave=args.minwave,
                                maxwave=args.maxwave, dwave=args.dwave)

    if args.empca_templates:
        # build the new PCA / redrock templates
        build_redrock_templates(specprod=args.specprod, niter=args.niter, ncomp=args.ncomp,
                                minwave=args.minwave, dwave=args.dwave)

    if args.nmf_templates:
        # build the new NMF Redrock templates
        build_redrock_templates(specprod=args.specprod, niter=args.niter, ncomp=args.ncomp,
                                minwave=args.minwave, dwave=args.dwave, nmf=True)

    if args.template_qa:
        qa_redrock_templates(ncomp=args.ncomp)

        pdb.set_trace()
    
        # 4-panel SED figure
        pngfile = os.path.join(qadir, f'ftemplates-{args.specprod}.png')

        current_palette = sns.color_palette()
        sns.set_palette('rainbow')#'Spectral')#'coolwarm')
        #sns.set(context='talk', style='ticks', font_scale=0.6)#, rc=rc)
        nplot = 30

        fig = plt.figure(figsize=(10, 8))
        gs = fig.add_gridspec(nrows=4, ncols=4)#, height_ratios=[1, 0.5])

        def _makeplot(xx, targtype, wavelims=None, xlabel=False, ylabel=False, zoom=False, zoomlabel=None):
            templatefile = os.path.join(datadir, f'ftemplates-{args.specprod}-{targtype}.fits')
            templatewave = fitsio.read(templatefile, 'WAVE')
            if wavelims is not None:
                W = np.where((templatewave > wavelims[0]) * (templatewave < wavelims[1]))[0]
            else:
                W = np.arange(len(templatewave))
            flux = fitsio.read(templatefile, 'FLUX')
            meta = fitsio.read(templatefile, 'METADATA')
            I = rand.choice(len(meta), size=nplot, replace=False)
            ylim = [np.min(templatewave[np.newaxis, :][:, W] * flux[I, :][:, W]),
                    np.max(templatewave[np.newaxis, :][:, W] * flux[I, :][:, W])]
            for igal in I:
                if zoom:
                    xx.plot(templatewave[W], templatewave[W] * flux[igal, W], alpha=0.5, lw=1, color='gray')
                else:
                    xx.plot(templatewave[W], templatewave[W] * flux[igal, W], alpha=0.5, lw=1, color='gray')
            if zoom:
                xx.set_ylim(ylim[0], ylim[1]*1.5)
            else:
                xx.set_ylim(ylim)
            #xx.set_ylim(1, np.max(templatewave[W] * flux[I, :][:, W]))
            xx.set_yscale('log')
            xx.set_yticklabels([])
            xx.margins(x=0)
            if zoom:
                xx.set_xticklabels([])
                if zoomlabel:
                    xx.text(0.05, 0.92, zoomlabel, ha='left', va='top', transform=xx.transAxes, fontsize=10)
            else:
                xx.set_xscale('log')
                if ylabel:
                    xx.set_ylabel(r'Normalized $\lambda F_{\lambda}$')
                if xlabel:
                    xx.set_xlabel(r'Rest-frame Wavelength ($\AA$)')
                    xx.xaxis.set_major_formatter(ticker.FuncFormatter(lambda y, _: '{:g}'.format(y)))
                else:
                    xx.set_xticklabels([])
                xx.text(0.05, 0.95, f'{targtype.replace("_ANY", "")}', ha='left', va='top', transform=xx.transAxes)
                xx.text(0.94, 0.11, r'$\langle z\rangle={:.2f}$'.format(np.median(meta['Z'])), 
                        ha='right', va='center', transform=xx.transAxes)

        xx = fig.add_subplot(gs[:2, :2]) # rows x cols
        _makeplot(xx, 'BGS_ANY', wavelims=None, ylabel=True)
        
        xx = fig.add_subplot(gs[:2, 2:]) # rows x cols
        _makeplot(xx, 'LRG', wavelims=None)
        
        xx = fig.add_subplot(gs[2:, :2]) # rows x cols
        _makeplot(xx, 'ELG', wavelims=None, ylabel=True, xlabel=True)

        xx = fig.add_subplot(gs[2, 2]) # rows x cols
        _makeplot(xx, 'ELG', wavelims=[1215.67-12, 1215.67+12], zoom=True, zoomlabel=r'Ly$\alpha$')

        xx = fig.add_subplot(gs[2, 3]) # rows x cols
        _makeplot(xx, 'ELG', wavelims=[3728.483-12, 3728.483+12], zoom=True, zoomlabel=r'[OII] $\lambda\lambda3726,29$')

        xx = fig.add_subplot(gs[3, 2]) # rows x cols
        _makeplot(xx, 'ELG', wavelims=[5008.238-12, 5008.238+12], zoom=True, zoomlabel=r'[O III] $\lambda5007$')
        
        xx = fig.add_subplot(gs[3, 3]) # rows x cols
        _makeplot(xx, 'ELG', wavelims=[6564.613-12, 6564.613+12], zoom=True, zoomlabel=r'H$\alpha$')
        
        fig.tight_layout()
        fig.savefig(pngfile)
        log.info(f'Wrote {pngfile}')

        sns.set_palette(current_palette)

    if args.gather_specprod_results:
        gather_specprod_results(specprod=args.specprod, overwrite=args.overwrite)

    if args.run_redrock:
        os.environ['RR_TEMPLATE_DIR'] = templatedir # note!

        # desihiz VI healpixels
        run_redrock_desihiz(zscan_prior='02', overwrite=args.overwrite)

        # Run Redrock on the VI tiles with a redshift scan to z=1.7 and to z=4.
        #run_redrock_tiles(zscan_prior='01', specprod=args.specprod, overwrite=args.overwrite) 
        run_redrock_tiles(zscan_prior='02', specprod=args.specprod, overwrite=args.overwrite)

    if args.redshift_qa:
        # Gather the EDR redshift-fitting results with the VI results and then
        # make some plots.
        gather_redrock_results(specprod=args.specprod, overwrite=args.overwrite)

        # QA - redshift vs redshift results
        qa_zvz(specprod=args.specprod)

        # QA - redshift completeness results
        qa_zcompleteness(specprod=args.specprod)

        # QA - redshift distribution of the VI healpixels.
        qa_zhist(vi=False)
        pdb.set_trace()
        
        qa_zhist(vi=True)

    if args.run_fastspecfit:
        from fastspecfit.fastspecfit import fastspec

        gather_redrock_results(specprod=args.specprod, overwrite=args.overwrite)        

        # temporary hack
        merge = merge[merge['BGS_BRIGHT']]
        merge_new = merge_new[merge_new['BGS_BRIGHT']]

        # trim to just spectype==GALAXY with the new models
        I = merge_new['SPECTYPE'] == 'GALAXY'
        merge = merge[I]
        merge_new = merge_new[I]

        # tiles
        _, Idoom, _ = _zstats(merge_new['Z_RR'], merge_new['VI_Z'])
        for tileid in sorted(set(merge_new['TILEID'][Idoom])):
            if tileid == 999999:
                continue
            I = tileid == merge_new['TILEID'][Idoom]
            oldcat = merge[Idoom][I]
            newcat = merge_new[Idoom][I]
            assert(np.all(newcat['TARGETID'] == oldcat['TARGETID']))

            petals = newcat['FIBER'] // 500
            for petal in sorted(set(petals)):
                P = petal == petals
                redrockfile = os.path.join(reduxdir, f'redrock-{petal}-{tileid}.fits')
                new_fastfile = os.path.join(fastdir, f'fastspec-new-{petal}-{tileid}.fits.gz')
                old_fastfile = os.path.join(fastdir, f'fastspec-{args.specprod}-{petal}-{tileid}.fits.gz')

                targetids = ','.join(newcat['TARGETID'][P].astype(str))
                input_redshifts = ','.join(oldcat['Z_RR'][P].astype(str))

                # iron templates
                cmdargs = f'{redrockfile} -o {old_fastfile} --targetids {targetids} --ignore-quasarnet --mp {args.mp} --input-redshifts {input_redshifts}'
                log.info(f'fastspec {cmdargs}')
                fastspec(args=cmdargs.split())

                # new templates
                cmdargs = f'{redrockfile} -o {new_fastfile} --targetids {targetids} --ignore-quasarnet --mp {args.mp}'
                log.info(f'fastspec {cmdargs}')
                fastspec(args=cmdargs.split())

    if args.fastspecfit_qa:
        # QA of the FastSpecFit fitting results.
        qa_fastspecfit(specprod=args.specprod)

if __name__ == '__main__':
    main()

