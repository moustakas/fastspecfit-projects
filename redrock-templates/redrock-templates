#!/usr/bin/env python

"""Build new Redrock templates.

Dependencies:
--desi/main
--fastspecfit/main
--redrock/fastspec-pca-templates
--empca
--setcoverpy

1. Build the parent sample:
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --match-lss
    /global/cfs/cdirs/desi/spectro/fastspecfit/iron/v2.0/catalogs/fastspec-iron-sv3-{bright,dark}.fits
    /global/cfs/cdirs/desi/vac/edr/lss/v2.0/LSScats/clustering/{BGS_ANY,LRG,ELG}_{N,S}_clustering.dat.fits

2. Make some parent QA:
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --parent-qa

3. Build the parent (FastSpecFit, rest-frame) templates:
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --parent-templates

4. Build the empca eigentemplates:
  salloc -N 1 -C cpu -A desi -t 00:20:00 --qos interactive
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --empca-templates

5. Generate QA of the parent templates and the resulting empca eigentemplates:
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --template-qa

6. Run Redrock
  salloc -N 4 -C gpu --gpus-per-node=4 -A desi -t 04:00:00 --qos interactive
  time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates --run-redrock

  salloc -N 4 -C cpu -A desi -t 04:00:00 --qos interactive
  srun -N 4 --ntasks 16 ./redrock-templates.sh

  For testing:
    rrdesi -i /global/cfs/cdirs/desi/users/ioannis/fastspecfit/redrock-templates/redux/coadd-27247.fits \
      -o /global/cfs/cdirs/desi/users/ioannis/fastspecfit/redrock-templates/redux/redrock-27247.fits \
      -d /global/cfs/cdirs/desi/users/ioannis/fastspecfit/redrock-templates/redux/rrdetails-27247.h5 --gpu --max-gpuprocs=4 --mp 1

7. Investigate outliers...

fastspec /global/cfs/cdirs/desi/spectro/redux/iron/tiles/cumulative/80613/20210324/redrock-2-80613-thru20210324.fits --targetids 39633324615930329 -o fastspec.fits --input-redshifts 1.9227369195305137
fastqa fastspec.fits -o ioannis/tmp2

"""
import os, pdb
import numpy as np
import fitsio
from glob import glob
from astropy.table import Table, hstack, vstack, join
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

from desitarget import geomask
from desiutil.log import get_logger
log = get_logger()

from fastspecfit.util import C_LIGHT
from fastspecfit.util import trapz_rebin

import seaborn as sns
sns.set(context='talk', style='ticks', font_scale=0.9, palette='Set2')

templatedir = os.path.join(os.getenv('DESI_ROOT'), 'users', 'ioannis', 'fastspecfit', 'redrock-templates')
reduxdir = os.path.join(templatedir, 'redux')
datadir = os.path.join(templatedir, 'data')
qadir = os.path.join(templatedir, 'qa')

tertiary26dir = os.path.join(os.getenv('DESI_ROOT'), 'users', 'raichoor', 'laelbg', 'daily', 'healpix', 'tertiary26-thru20230416-v2')

def get_version(specprod):
    ver = {'fuji': 'v3.0', 'guadalupe': 'v3.0', 'iron': 'v2.0'}
    return ver[specprod]    

def get_vacdir(specprod='fuji', version=None):

    if version is None:
        version = get_version(specprod)

    #if 'NERSC_HOST' in os.environ:
    #    vacdir = '/pscratch/sd/i/ioannis/fastspecfit/vac/data/'+specprod+'/catalogs' # to be updated
    #else:
    vacdir = os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'fastspecfit', specprod, version, 'catalogs')
    log.info(f'VAC dir {vacdir}')

    return vacdir



def read_vi_tertiary26():
    """Read the tertiary26 LAE/LBG VI results.

    """
    from desimodel.footprint import radec2pix    
        
    vifile = os.path.join(os.getenv('DESI_ROOT'), 'users', 'ioannis', 'tertiary', 'deep-photometry', 'vi', 'FINAL_VI_Subaru_COSMOS.fits')
    vi = Table(fitsio.read(vifile))
    vi.rename_columns(['VI_Z_FINAL', 'VI_QUALITY_FINAL', 'VI_COMMENTS_FINAL'], ['VI_Z', 'VI_QUALITY', 'VI_COMMENTS'])
    I = np.where(vi['VI_QUALITY'] >=3)[0]
    #I = (vi['VI_QUALITY'] >=3) * (vi['TERTIARY_TARGET'] == 'LAE_SUBARU ') * (vi['VI_Z'] > 2.4)#1e-3)    
    log.info(f'Trimming to {len(I):,d}/{len(vi):,d} VI redshifts in {vifile}')
    vi = vi[I]

    # Now read the 'merge' catalog to figure out which healpixels we care about.
    mergefile = os.path.join(tertiary26dir, 'merge-tertiary26-thru20230416-v2.fits')
    mm = Table(fitsio.read(mergefile))
    log.info(f'Read {len(mm):,d} objects from {mergefile}')
    mm['HEALPIX'] = radec2pix(nside=64, ra=mm['TARGET_RA'], dec=mm['TARGET_DEC'])

    mm = mm[geomask.match_to(mm['TARGETID'], vi['TARGETID'])]
    assert(np.all(mm['TARGETID'] == vi['TARGETID']))
    vi['HEALPIX'] = mm['HEALPIX']

    #vi = join(mm, vi, keys='TARGETID')

    return vi

def read_vi(quality=2.5):
    # see https://data.desi.lbl.gov/doc/releases/edr/vac/vi/
    from glob import glob
    #vifiles = glob('/global/cfs/cdirs/desi/public/edr/vac/edr/vi/v1.0/*.csv')
    allvi = []
    for targ in ['BGS', 'LRG', 'ELG', 'QSO']:
        vifile = f'/global/cfs/cdirs/desi/public/edr/vac/edr/vi/v1.0/EDR_VI_{targ}_v1.csv'
        vi = Table.read(vifile)
        vi['SUFFIX'] = targ # os.path.basename(vifile).replace('EDR_VI_', '').replace('_v1.csv', '')
        allvi.append(vi)
    allvi = vstack(allvi)
    I = np.where(allvi['VI_QUALITY'] >= quality)[0]
    log.info(f'Trimming to {len(I):,d}/{len(allvi):,d} VI redshifts.')
    allvi = allvi[I]

    _, uindx = np.unique(allvi['TARGETID'], return_index=True)
    log.info(f'Trimming to {len(uindx):,d}/{len(allvi):,d} unique targets.')
    allvi = allvi[uindx]
    
    return allvi

def match_lss(specprod='iron', overwrite=False):
    """Match to the clustering catalogs (full and clustering).

    https://desi.lbl.gov/trac/wiki/keyprojects/y1kp3/Y1details

    """
    from fastspecfit.io import read_fastspecfit
    from fastspecfit.io import write_fastspecfit

    vacdir = get_vacdir(specprod)

    # read the clustering catalogs
    if specprod == 'fuji':
        lssdir = os.path.join(os.getenv('DESI_ROOT'), 'vac', 'edr', 'lss', 'v2.0', 'LSScats')
    elif specprod == 'iron':
        lssdir = os.path.join(os.getenv('DESI_ROOT'), 'vac', 'edr', 'lss', 'v2.0', 'LSScats')
        #lssdir = '/global/cfs/cdirs/desi/survey/catalogs/Y1/LSS/iron/LSScats/v0.6/'
    else:
        raise NotImplemented
    # redshift limits / cuts
    zlims = {'BGS_ANY': [0.01, 0.6], 'LRG': [0.4, 1.1], 'ELG': [0.6, 1.6]}
    
    for targtype in ['BGS_ANY', 'LRG', 'ELG']:
        log.info('##################################################')
        log.info(f'Working on {targtype}')
        if targtype == 'BGS_ANY':
            sv3file = os.path.join(vacdir, f'fastspec-{specprod}-sv3-bright.fits')
            allfast, allmeta, _, _ = read_fastspecfit(sv3file)
        else:
            sv3file = os.path.join(vacdir, f'fastspec-{specprod}-sv3-dark.fits')
            allfast, allmeta, _, _ = read_fastspecfit(sv3file)
        
        for lsstype in ['clustering']:
            log.info('--------------------')
            outfastfile = os.path.join(datadir, f'fastspec-{specprod}-{lsstype}-{targtype}.fits')
            outlssfile = os.path.join(datadir, f'lss-{specprod}-{lsstype}-{targtype}.fits')
    
            if os.path.isfile(outfastfile) and os.path.isfile(outlssfile) and not overwrite:
                log.info(f'fastspecfit file {outfastfile} exists')
                log.info(f'LSS clustering file {outlssfile} exists')
            else:
                if lsstype == 'clustering':
                    lssNfile = os.path.join(lssdir, 'clustering', f'{targtype}_N_clustering.dat.fits')
                    lssSfile = os.path.join(lssdir, 'clustering', f'{targtype}_S_clustering.dat.fits')
                    lssN = fitsio.read(lssNfile)
                    lssS = fitsio.read(lssSfile)
                    alllss = Table(np.concatenate((lssN, lssS)))
                    log.info(f'Read {len(lssN):,d} objects from {lssNfile}')
                    log.info(f'Read {len(lssS):,d} objects from {lssSfile}')
                    log.info(f'  Total number of LSS {targtype}: {len(alllss):,d}')
                    del lssN, lssS
                    
                indx_fast, indx_lss = geomask.match(allfast['TARGETID'], alllss['TARGETID'])
                fast = allfast[indx_fast]
                meta = allmeta[indx_fast]
                lss = alllss[indx_lss]
                assert(np.all(meta['TARGETID'] == lss['TARGETID']))

                ## Any missing objects are going to be because Z_TILE != Z_HP
                ## and Z_HP < 1e-3 but we trimmed those above.
                #miss = alllss[np.delete(np.arange(len(alllss)), indx_lss)]
                #try:
                #    assert(len(miss) == 0)
                #except:
                #    log.warning('Missing the following objects!')
                #    print(miss)

                # apply redshift cuts
                I = (meta['Z'] > zlims[targtype][0]) * (meta['Z'] < zlims[targtype][1])
                log.info(f'Trimming to {np.sum(I):,d} objects with z={zlims[targtype][0]:.2f}-{zlims[targtype][1]:.2f}.')
                fast = fast[I]
                meta = meta[I]
                lss = lss[I]
               
                write_fastspecfit(fast, meta, outfile=outfastfile, verbose=False)

                lss.write(outlssfile, overwrite=True)
                log.info(f'Wrote {len(lss):,d} objects to {outlssfile}')


def read_clustering(targetclass=['BGS_ANY', 'LRG', 'ELG'], specprod='iron',
                    lsstype='clustering', read_lss=True, trim_broad=True,
                    rows=None):
    """Read the matched clustering files (from match_lss).

    """
    from fastspecfit.io import read_fastspecfit

    data = {}
    for targtype in np.atleast_1d(targetclass):
        fastfile = os.path.join(datadir, f'fastspec-{specprod}-{lsstype}-{targtype}.fits')
        if not os.path.isfile(fastfile):
            log.info(f'{fastfile} not found.')
        else:
            fast, meta, _, _ = read_fastspecfit(fastfile, rows=rows)
            if read_lss:
                lssfile = os.path.join(datadir, f'lss-{specprod}-{lsstype}-{targtype}.fits')
                lss = Table(fitsio.read(lssfile, rows=rows))
                log.info(f'Read {len(lss):,d} objects from {lssfile}')
            else:
                lss = None

            if trim_broad:
                B = np.logical_or(fast['BROAD_SIGMA'] > 0, meta['SPECTYPE'] == 'QSO')
                log.info(f'Trimming {np.sum(B):,d}/{len(fast):,d} broad-line galaxies.')
                fast = fast[~B]
                meta = meta[~B]
                if lss is not None:
                    lss = lss[~B]
                
            data[targtype] = {'fast': fast, 'meta': meta, 'lss': lss}
            
    return data     

def parent_qa(specprod='iron'):
    """Build some QA of the parent sample."""

    import corner as cn
    from matplotlib import colors
    import matplotlib.patches as mpatches

    data = read_clustering(specprod=specprod, read_lss=False, trim_broad=True)

    cols = [colors.to_hex(col) for col in ['darkgreen', 'darkred', 'darkblue']]
    #cols = [colors.to_hex(col) for col in ['darkseagreen', 'orangered', 'dodgerblue']]

    levels = [0.5, 0.75, 0.95, 0.99]
    smooth = 1.5
    mstarlim = [6.5, 12.5]
    sfrlim = [-5, 4]
    redshiftlim = [-0.05, 1.7]
    vdisplim = [50, 350]
    linewidthlim = [0, 350]

    hh = []
    fig, ax = plt.subplots(1, 2, figsize=(10, 5))
    for targtype, col, in zip(['BGS_ANY', 'LRG', 'ELG'][::-1], cols[::-1]):
        fast = data[targtype]['fast']
        meta = data[targtype]['meta']

        cn.hist2d(meta['Z'], fast['LOGMSTAR'], fill_contours=False,
                  range=[redshiftlim, mstarlim],
                  bins=50, color=col, smooth=smooth, levels=levels,
                  contour_kwargs={'colors': col, 'alpha': 0.8, 'linewidths': 1},
                  label=targtype, 
                  data_kwargs={'color': col, 'alpha': 0.5, 'ms': 2}, ax=ax[0])
        hh.append(mpatches.Patch(color=col, label=targtype, alpha=0.5))
    ax[0].set_xlabel('Redshift')
    ax[0].set_ylabel(r'$\log_{10}\ (M/M_{\odot})$')
    #ax[0].legend(handles=hh, fontsize=11)

    for targtype, col, in zip(['ELG', 'BGS_ANY', 'LRG'], [cols[2], cols[0], cols[1]]):
        fast = data[targtype]['fast']
        meta = data[targtype]['meta']
        I = fast['SFR'] > 0
        print(targtype, np.sum(I))

        cn.hist2d(fast['LOGMSTAR'][I], np.log10(fast['SFR'][I]), fill_contours=False,
                  range=[mstarlim, sfrlim],
                  bins=50, color=col, smooth=smooth, levels=levels,
                  contour_kwargs={'colors': col, 'alpha': 0.8, 'linewidths': 1},
                  label=targtype, 
                  data_kwargs={'color': col, 'alpha': 0.5, 'ms': 2}, ax=ax[1])
    ax[1].set_xlabel(r'$\log_{10}(M\ /\ M_{\odot})$')
    ax[1].set_ylabel(r'$\log_{10}(\mathrm{SFR}\ /\ M_{\odot}\ \mathrm{yr}^{-1})$')
    ax[1].legend(handles=hh, fontsize=11, loc='upper left')
    fig.tight_layout()
    pngfile = os.path.join(qadir, 'qa-parent-logmstar.png')
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')

    fig, ax = plt.subplots(1, 2, figsize=(10, 5))
    for targtype, col, in zip(['BGS_ANY', 'LRG'], cols[:3]):
        fast = data[targtype]['fast']
        meta = data[targtype]['meta']
        I = fast['VDISP_IVAR'] > 0
        ax[0].hist(fast['VDISP'][I], bins=30, color=col, range=vdisplim, alpha=0.5)#,
                   #edgecolor='k')#, histtype='stepfilled')
    ax[0].set_xlabel(r'$\sigma_{star}$ (km/s)')
    ax[0].set_ylabel('Number')

    for targtype, col, in zip(['ELG', 'BGS_ANY', 'LRG'], [cols[2], cols[0], cols[1]]):
        fast = data[targtype]['fast']
        meta = data[targtype]['meta']
        I = fast['NARROW_SIGMA'] > 0
        ax[1].hist(fast['NARROW_SIGMA'][I], bins=30, color=col, range=linewidthlim, alpha=0.5,
                   label=targtype)#, edgecolor=col)
    ax[1].set_xlabel(r'$\sigma_{line}$ (km/s)')
    ax[1].set_ylabel('Number')
    ax[1].legend(loc='upper right', fontsize=11)
    fig.tight_layout()
    pngfile = os.path.join(qadir, 'qa-parent-velwidth.png')
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')

    #fig, ax = plt.subplots(1, 3, figsize=(12, 3))
    #for targtype, xx, col in zip(['BGS_ANY', 'LRG', 'ELG'], ax.flat, cols):
    
    fig, xx = plt.subplots(figsize=(8, 6))
    for targtype, col in zip(['BGS_ANY', 'LRG', 'ELG'][::-1], cols[::-1]):
        fast = data[targtype]['fast']
        meta = data[targtype]['meta']
        zlim = (0, 1.6) # (np.min(fast['Z']), np.max(fast['Z']))
        #print(zlim)
        xx.hist(fast['Z'], bins=30, color=col, range=zlim, alpha=0.5,
                label=f'{targtype} (N={len(fast):,d})')
        #xx.hist(fast['Z'][B], bins=100, color='k', fill=True, range=zlim)
        #xx.set_yscale('log')
    xx.legend(loc='upper right', fontsize=11)
    xx.set_xlabel('Redshift')
    xx.set_ylabel('Number')
    #ax.flat[-1].axis('off')
    #ax[0].set_ylabel('Number')
    fig.tight_layout()
    pngfile = os.path.join(qadir, 'qa-parent-zhist.png')
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')
        
def build_emline_model(lineamps, linevshifts, linesigmas, linewaves, 
                       emlinewave, dlog10wave=None, redshift=0.0):

    if dlog10wave is None:
        dlog10wave = 5. / C_LIGHT / np.log(10) # equivalent to km/s

    pad = 5.

    # Cut to lines with non-zero amplitudes.
    I = lineamps > 0
    if np.count_nonzero(I) > 0:
        linevshifts = linevshifts[I]
        linesigmas = linesigmas[I]
        lineamps = lineamps[I]
        linewaves = linewaves[I]

        # demand at least 20 km/s for rendering the model
        if np.any(linesigmas) < 20.:
            linesigmas[linesigmas<20.] = 20.

        # line-width [log-10 Angstrom] and redshifted wavelength [log-10 Angstrom]
        log10sigmas = linesigmas / C_LIGHT / np.log(10) 
        linezwaves = np.log10(linewaves * (1. + redshift + linevshifts / C_LIGHT))

        log10wave = []
        for linezwave, log10sigma in zip(linezwaves, log10sigmas):
            log10wave.append(np.arange(linezwave - (5 * log10sigma), linezwave + (5 * log10sigma), dlog10wave))
        log10wave = np.hstack([np.log10(np.min(emlinewave)-pad), np.log10(np.max(emlinewave)+pad), ] + log10wave)
        S = np.argsort(log10wave)
        log10wave = log10wave[S]
        log10model = np.zeros_like(log10wave)
        
        for lineamp, linezwave, log10sigma in zip(lineamps, linezwaves, log10sigmas):
            J = np.abs(log10wave - linezwave) < (5 * log10sigma)
            log10model[J] += lineamp * np.exp(-0.5 * (log10wave[J]-linezwave)**2 / log10sigma**2)

    modelflux = np.hstack(log10model)
    emlinemodel = trapz_rebin(10**log10wave, modelflux, emlinewave)

    return emlinemodel

def read_ftemplates():
    
    from fastspecfit.io import cache_templates

    _ftemplatesdir = os.environ['FTEMPLATES_DIR']
    ftemplatesdir = os.path.join(os.getenv('PSCRATCH'), 'fastspecfit', 'templates')
    log.warning(f'Temporarily hacking FTEMPLATES_DIR to {ftemplatesdir}!')

    os.environ['FTEMPLATES_DIR'] = ftemplatesdir
    templatecache = cache_templates(templateversion='1.1.1', read_linefluxes=True)
    os.environ['FTEMPLATES_DIR'] = _ftemplatesdir

    return templatecache


def restframe_templates(fast, meta, outfile, minwave=400., maxwave=1.1e4, dwave=0.1):
    """Reconstruct the rest-frame templates.

    """
    from scipy.ndimage import gaussian_filter1d
    from fastspecfit.io import cache_templates
    from fastspecfit.continuum import PIXKMS_BLU

    ngal = len(meta)

    templatecache = read_ftemplates()
    info = templatecache['templateinfo']
    nsed = len(info)

    # note the 5-Angstrom pad
    I = np.where((templatecache['templatewave'] > (minwave-5)) * (templatecache['templatewave'] < (maxwave+5)))[0]
    templatewave = templatecache['templatewave'][I]
    templateflux = templatecache['templateflux'][I, :]
    templateflux_nolines = templatecache['templateflux_nolines'][I, :]
    npix = len(templatewave)

    J = np.where((templatecache['linewaves'] > minwave) * (templatecache['linewaves'] < maxwave))[0]
    linewaves = templatecache['linewaves'][J]
    linefluxes = templatecache['linefluxes'][J]
    del templatecache

    # generate template models on a grid of velocity dispersion; note that this
    # isn't quite right in the UV or beyond about a micron...
    vdispmin = 50.
    vdispmax = 350.
    dvdisp = 25.
    nvdisp = int(np.ceil((vdispmax - vdispmin) / dvdisp)) + 1
    vdisp_grid = np.linspace(vdispmin, vdispmax, nvdisp)

    vdispflux = []
    for sigma in vdisp_grid / PIXKMS_BLU:
        vdispflux.append(gaussian_filter1d(templateflux_nolines, sigma=sigma, axis=0))
    vdispflux = np.stack(vdispflux, axis=-1) # [npix,nvdispmodel,nvdisp]

    # now loop on each galaxy and build the best-fitting continuum using the
    # smoothed model closest to the measured velocity dispersion
    continuum = np.zeros((ngal, npix))
    I = np.argmin(np.abs(fast['VDISP'][:, np.newaxis] - vdisp_grid[np.newaxis, :]), axis=1)
    for ivdisp in set(I):
        J = np.where(ivdisp == I)[0]
        continuum[J, :] = fast['COEFF'][J].data.dot(vdispflux[:, :, ivdisp].T) # note: no line-emission

    # reconstruct the continuum-only templates
    #continuum = fast['COEFF'].data.dot(templateflux_nolines.T) # note: no line-emission
    templates_lowres = fast['COEFF'].data.dot(templateflux.T) # note: low-res line-emission

    ## convolve with the measured velocity dispersion
    #log.info('Convolving to the measured velocity dispersion.')
    #for igal in range(ngal):
    #    sigma = fast['VDISP'][igal] / PIXKMS_BLU # [pixels]
    #    continuum[igal, :] = gaussian_filter1d(continuum[igal, :], sigma=sigma, axis=0)

    # interpolate the models onto the new, desired wavelength grid
    _templatewave = np.arange(minwave, maxwave, dwave)
    _npix = len(_templatewave)
    _continuum = np.zeros((ngal, _npix))
    log.info('Interpolating onto the new wavelength grid.')
    for igal in range(ngal):
        _continuum[igal, :] = trapz_rebin(templatewave, continuum[igal, :], xnew=_templatewave)
        
    npix = _npix
    continuum = _continuum
    templatewave = _templatewave

    # build emission-line spectra on a grid of line-width; then, below, choose
    # the closest one to the measured line-width
    nline = len(linewaves)

    #linesigma_delta = 15. # 5.
    #nlinesigma = int(np.ceil((linesigma_max - linesigma_min) / linesigma_delta)) + 1
    nominal_sigma = 75. # [km/s]
    linesigma_min = 5.
    linesigma_max = 115.
    nlinesigma = 9
    linesigma_grid = np.linspace(linesigma_min, linesigma_max, nlinesigma)
    if not nominal_sigma in linesigma_grid:
        linesigma_grid = np.hstack((nominal_sigma, linesigma_grid))
        linesigma_grid = linesigma_grid[np.argsort(linesigma_grid)]
        nlinesigma = len(linesigma_grid)

    linevshifts = np.zeros_like(linewaves) # no velocity shifts
    linezwaves = linewaves * (1. + linevshifts / C_LIGHT)
    
    linemodels = np.zeros((nlinesigma, nsed, npix)) # [nsigma, nsed, npix]

    current_palette = sns.color_palette()
    sns.set_palette('rainbow', nlinesigma)#'Spectral')#'coolwarm')
    #linecolors = iter(sns.husl_palette(nlinesigma, l=0.3))
    linecolors = iter(sns.color_palette())
    fig, ax = plt.subplots()
    for isigma in range(nlinesigma):
        print(linesigma_grid[isigma])
        linesigmas = np.zeros(nline) + linesigma_grid[isigma]
        I = np.where(np.sum(linefluxes, axis=0) > 0)[0]
        for imodel in I:
            lineamps = C_LIGHT * linefluxes[:, imodel] / (np.sqrt(2 * np.pi) * linesigmas * linezwaves)
            emlinemodel = build_emline_model(lineamps, linevshifts, linesigmas,
                                             linewaves, emlinewave=templatewave)
            linemodels[isigma, imodel, :] = emlinemodel
            if info['av'][imodel] == 0. and info['zzsun'][imodel] == 0. and info['sfr'][imodel] > 0.:
                W = np.where((templatewave > (3728.483-12.)) * (templatewave < (3728.483+12)))[0]
                ax.plot(templatewave[W], emlinemodel[W]/np.max(emlinemodel[W]), lw=1,
                        color=next(linecolors),
                        label='{:.2f} km/s'.format(linesigma_grid[isigma]))
    ax.legend(fontsize=10, loc='upper left')
    ax.set_yticklabels([])
    ax.set_xlabel(r'Wavelength ($\AA$)')
    fig.tight_layout()    
    pngfile = os.path.join(qadir, 'qa-linewidth-grid.png')    
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')
    sns.set_palette(current_palette)
        
    # now build the emission-line spectra, choosing the linemodels model closest
    # to the measured line-width
    linespectra = np.zeros_like(continuum)
    for igal in range(ngal):
        if igal % 1000 == 0:
            log.info(f'Working on galaxy {igal} / {ngal}')

        # are any of the emission-line models used for this object?
        I = np.where((np.sum(linefluxes, axis=0) > 0) * (fast['COEFF'][igal] > 0))[0]
        if len(I) > 0:
            if fast['NARROW_SIGMA'][igal] > 0:
                linesigma = fast['NARROW_SIGMA'][igal]
            else:
                linesigma = nominal_sigma
            jsigma = np.argmin(np.abs(linesigma-linesigma_grid))

            emlinemodels = np.zeros((npix, nsed))
            for imodel in I:
                #print(igal, jsigma, imodel, linesigma, linesigma_grid[jsigma])
                emlinemodels[:, imodel] = linemodels[jsigma, imodel, :]

            linespectra[igal, :] = fast['COEFF'][igal].dot(emlinemodels.T)

            #if linesigma_grid[jsigma] > 150.:
            #    W = np.where((templatewave > 4800.) * (templatewave < 5100.))[0]                
            #    plt.plot(templatewave[W], continuum[igal, W] + linespectra[igal, W])
            #    plt.plot(templatewave[W], templates_lowres[igal, W])
            #    plt.plot(templatewave[W], linespectra[igal, W])
            #    plt.savefig('/global/cfs/cdirs/desi/users/ioannis/tmp2/junk.png')
    
    ## now generate the individual emission-line spectra but using the measured
    ## line-width (if any)
    #linespectra = np.zeros_like(continuum)
    #for igal in range(ngal):
    #    if igal % 20 == 0:
    #        log.info(f'Working on galaxy {igal} / {ngal}')
    #    
    #    if fast['NARROW_SIGMA'][igal] > 0:
    #        linesigmas = np.zeros(nline) + fast['NARROW_SIGMA'][igal]
    #    else:
    #        linesigmas = np.zeros(nline) + nominal_sigma
    #    #linesigmas = np.zeros(nline) + 500.
    #
    #    linezwaves = linewaves * (1. + linevshifts / C_LIGHT)
    #
    #    #lineamps = C_LIGHT * linefluxes / (np.sqrt(2 * np.pi) * linesigmas[:, np.newaxis] * linewaves[:, np.newaxis])
    #    emlinemodels = np.zeros_like(templateflux_nolines)
    #    I = np.where((np.sum(linefluxes, axis=0) > 0) * (fast['COEFF'][igal] > 0))[0]
    #    if len(I) > 0:
    #        for imodel in I:
    #            #print(igal, imodel)
    #            lineamps = C_LIGHT * linefluxes[:, imodel] / (np.sqrt(2 * np.pi) * linesigmas * linezwaves)
    #            emlinemodel = build_emline_model(lineamps, linevshifts, linesigmas,
    #                                             linewaves, emlinewave=templatewave)
    #            emlinemodels[:, imodel] = emlinemodel
    #            #plt.clf()
    #            #I = np.where((templatewave > 4800.) * (templatewave < 5100.))[0]                
    #            #plt.plot(templatewave[I], emlinemodel[I])
    #            #plt.savefig('/global/cfs/cdirs/desi/users/ioannis/tmp2/junk.png')
    #
    #    if np.max(emlinemodels) > 0:
    #        linespectra[igal, :] = fast['COEFF'][igal].dot(emlinemodels.T)
    #    #plt.clf()
    #    #I = np.where((templatewave > 4800.) * (templatewave < 5100.))[0]                
    #    #plt.plot(templatewave[I], continuum[igal, I] + linespectra[igal, I])
    #    #plt.plot(templatewave[I], templates_lowres[igal, I])
    #    ##plt.plot(templatewave[I], linespectra[igal, I])
    #    #plt.savefig('/global/cfs/cdirs/desi/users/ioannis/tmp2/junk.png')
        
    templates = continuum + linespectra

    # gather the output metadata
    metacols = ['TARGETID', 'SURVEY', 'PROGRAM', 'HEALPIX', 'RA', 'DEC', 'Z', 'ZWARN', 'DELTACHI2', 'SPECTYPE', 'Z_RR']
    outmeta = meta[metacols]

    fastcols = ['VDISP', 'AV', 'AGE', 'ZZSUN', 'LOGMSTAR', 'SFR', 'DN4000_MODEL', 'NARROW_Z',
                'BROAD_Z', 'UV_Z', 'NARROW_SIGMA', 'BROAD_SIGMA', 'UV_SIGMA']
    outmeta = hstack((outmeta, fast[fastcols]))
    outmeta['TEMPLATENORM'] = np.ones(len(outmeta), 'f4')

    # normalize at 5500 A
    for igal in range(ngal):
        #norm = np.median(templates[igal, :])
        norm = np.interp(5500., templatewave, templates[igal, :])
        outmeta['TEMPLATENORM'][igal] = norm
        templates[igal, :] /= norm
        templates_lowres[igal, :] /= norm
        continuum[igal, :] /= norm
        linespectra[igal, :] /= norm
    
    fitsio.write(outfile, templates.astype('f8'), clobber=True, extname='FLUX')
    fitsio.write(outfile, templatewave, extname='WAVE')
    fitsio.write(outfile, outmeta.as_array(), extname='METADATA')
    print(f'Wrote {outfile}')

    # optional QA of the first 10 models
    
    fig, ax = plt.subplots()
    #I = np.where((templatewave > 4800.) * (templatewave < 5100.))[0]
    #ax.plot(templatewave[I]/1e4, templates[igal, I], label='New model')
    #ax.plot(templatewave[I]/1e4, templates_lowres[igal, I], alpha=0.5, label='Fixed-res model')
    ##ax.plot(templatewave[I]/1e4, linespectra[igal, I])
    #ax.plot(templatewave[I]/1e4, continuum[igal, I], label='Continuum only')
    #ax.legend()
    for igal in range(10):
        ax.plot(templatewave/1e4, templatewave * templates[igal, :], alpha=0.5)
        #ax.plot(templatewave[I]/1e4, templates[igal, I], label='Custom', alpha=0.5)
        #ax.plot(templatewave[I]/1e4, templates_lowres[igal, I], label='FSPS', alpha=0.5)
    ax.set_yscale('log')
    ax.set_ylabel(r'Normalized $\lambda F_{\lambda}$')
    ax.set_xlabel(r'Rest-frame Wavelength ($\mu$m)')
    ax.set_xscale('log')
    ax.xaxis.set_major_formatter(ticker.FuncFormatter(lambda y, _: '{:g}'.format(y)))
    ax.margins(0)
    fig.tight_layout()
    pngfile = outfile.replace('.fits', '.png')
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')

def run_redrock(vi, specprod='iron', run_tiles=False, overwrite=False):
    """Wrapper to run Redrock on tiles / healpixels.

    """
    from redrock.external.desi import rrdesi, write_zbest
    from desispec.io import read_spectra, write_spectra
    from desispec.util import runcmd
    from desispec.validredshifts import validate
    from desispec.scripts import qsoqn, qsomgii, emlinefit

    if run_tiles:
        for tileid in sorted(set(vi['TILEID'])):
            T = tileid == vi['TILEID']
            petals = vi['FIBER'][T] // 500
            for petal in sorted(set(petals)):
                P = petal == petals
                targetids = vi[T][P]['TARGETID'].data
    
                # copy the data so we can run the after-burners
                coaddfile = os.path.join(reduxdir, f'coadd-{petal}-{tileid}.fits')
                if not os.path.isfile(coaddfile) or overwrite:                
                    orig_coaddfile = glob(os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'redux', specprod, 'tiles',
                                                       'cumulative', str(tileid), '*', f'coadd-{petal}-{tileid}-thru*.fits'))[0]
                    spec = read_spectra(orig_coaddfile, targetids=targetids)
                    assert(np.all(spec.target_ids() == targetids))
                    log.info(f'Writing {len(targetids)} targets to {coaddfile}')
                    write_spectra(coaddfile, spec)
                    del spec
                    
                # copy over the original redrock results
                zcatfile = os.path.join(reduxdir, f'zcat-{specprod}-{petal}-{tileid}.fits')
                if not os.path.isfile(zcatfile) or overwrite:
                    orig_redrockfile = glob(os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'redux', specprod, 'tiles',
                                                         'cumulative', str(tileid), '*', f'redrock-{petal}-{tileid}-thru*.fits'))[0]
    
                    zcat = validate(orig_redrockfile, return_target_columns=True,
                                    extra_columns=['TARGETID', 'Z', 'ZWARN', 'COADD_FIBERSTATUS', 'SPECTYPE', 'DELTACHI2'])
                    zcat = zcat[geomask.match_to(zcat['TARGETID'], targetids)]
                    assert(np.all(zcat['TARGETID'] == targetids))
                    zcat.write(zcatfile, overwrite=True)
                    log.info(f'Wrote {len(zcat)} objects to {zcatfile}')
    
                redrockfile = os.path.join(reduxdir, f'redrock-{petal}-{tileid}.fits')
                rrdetailsfile = os.path.join(reduxdir, f'rrdetails-{petal}-{tileid}.h5')
                if not os.path.isfile(redrockfile) or overwrite:
                    #cmd = f'-i {coaddfile} -o {redrockfile} -d {rrdetailsfile} --mp 1'
                    cmd = f'-i {coaddfile} -o {redrockfile} -d {rrdetailsfile} --gpu --max-gpuprocs=4 --mp 1'
                    log.info(f'rrdesi {cmd}')
                    rrdesi(cmd.split())
                else:
                    log.info(f'Skipping existing file {redrockfile}')
    
                for prefix, maincmd in zip(['qso_qn', 'qso_mgii', 'emline'], [qsoqn.main, qsomgii.main, emlinefit.main]):
                    outfile = os.path.join(reduxdir, f'{prefix}-{petal}-{tileid}.fits')
                    if not os.path.isfile(outfile) or overwrite:
                        cmd = f'desi_{prefix}_afterburner --coadd {coaddfile} --redrock {redrockfile} --output {outfile}'
                        if 'qso_' in prefix:
                            cmd += ' --target_selection all --save_target all'
                        log.info(f'{runcmd} {cmd}')
                        runcmd(maincmd, args=cmd.split()[1:], inputs=[coaddfile, redrockfile], outputs=[outfile])
                    else:
                        log.info(f'Skipping existing file {outfile}')
    else:
        for healpix in sorted(set(vi['HEALPIX'])):
            H = healpix == vi['HEALPIX']
            targetids = vi[H]['TARGETID'].data
    
            # copy the data so we can run the after-burners
            coaddfile = os.path.join(reduxdir, f'coadd-{healpix}.fits')
            if not os.path.isfile(coaddfile) or overwrite:
                orig_coaddfile = os.path.join(tertiary26dir, f'coadd-{healpix}.fits')
                spec = read_spectra(orig_coaddfile, targetids=targetids)
                assert(np.all(spec.target_ids() == targetids))
                log.info(f'Writing {len(targetids)} targets to {coaddfile}')
                write_spectra(coaddfile, spec)
                del spec
    
            # validate the original redrock redshifts
            zcatfile = os.path.join(reduxdir, f'zcat-tertiary26-{healpix}.fits')
            if not os.path.isfile(zcatfile) or overwrite:
                orig_redrockfile = os.path.join(tertiary26dir, f'redrock-{healpix}.fits')
    
                zcat = validate(orig_redrockfile, return_target_columns=True,
                                extra_columns=['TARGETID', 'Z', 'ZWARN', 'COADD_FIBERSTATUS', 'SPECTYPE', 'DELTACHI2'])
                zcat = zcat[geomask.match_to(zcat['TARGETID'], targetids)]
                assert(np.all(zcat['TARGETID'] == targetids))
                zcat.write(zcatfile, overwrite=True)
                log.info(f'Wrote {len(zcat)} objects to {zcatfile}')
    
            redrockfile = os.path.join(reduxdir, f'redrock-{healpix}.fits')
            rrdetailsfile = os.path.join(reduxdir, f'rrdetails-{healpix}.h5')
            if not os.path.isfile(redrockfile) or overwrite:
                #cmd = f'-i {coaddfile} -o {redrockfile} -d {rrdetailsfile} --mp 1'
                cmd = f'-i {coaddfile} -o {redrockfile} -d {rrdetailsfile} --gpu --max-gpuprocs=4 --mp 1'
                log.info(f'rrdesi {cmd}')
                rrdesi(cmd.split())
            else:
                log.info(f'Skipping existing file {redrockfile}')
    
            for prefix, maincmd in zip(['qso_qn', 'qso_mgii', 'emline'], [qsoqn.main, qsomgii.main, emlinefit.main]):
                outfile = os.path.join(reduxdir, f'{prefix}-{healpix}.fits')
                if not os.path.isfile(outfile) or overwrite:
                    cmd = f'desi_{prefix}_afterburner --coadd {coaddfile} --redrock {redrockfile} --output {outfile}'
                    if 'qso_' in prefix:
                        cmd += ' --target_selection all --save_target all'
                    log.info(f'{runcmd} {cmd}')
                    runcmd(maincmd, args=cmd.split()[1:], inputs=[coaddfile, redrockfile], outputs=[outfile])
                else:
                    log.info(f'Skipping existing file {outfile}')


def main():
    """Main wrapper."""

    import argparse

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--match-lss', action='store_true', help='Match to the LSS catalogs (no figures, just catalogs).')
    parser.add_argument('--parent-qa', action='store_true', help='QA of the parent sample.')
    parser.add_argument('--parent-templates', action='store_true', help='Build the parent rest-frame templates.')
    parser.add_argument('--empca-templates', action='store_true', help='Run empca on the output of --parent-templates.')
    parser.add_argument('--template-qa', action='store_true', help='Template QA.')
    parser.add_argument('--run-redrock', action='store_true', help='Run Redrock on the VI tiles/healpixels.')
    parser.add_argument('--redshift-qa', action='store_true', help='Redshift QA.')

    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')
    parser.add_argument('--minwave', type=float, default=400., help='Minimum template wavelength (Angstrom).')
    parser.add_argument('--maxwave', type=float, default=1.1e4, help='Maximum template wavelength (Angstrom).')
    parser.add_argument('--dwave', type=float, default=0.1, help='Template wavelength spacing (Angstrom).')
    parser.add_argument('--niter', type=int, default=10, help='Number of PCA iterations.')
    parser.add_argument('--ncomp', type=int, default=10, help='Number of PCA components.')

    parser.add_argument('--specprod', default='iron', help='Spectroscopic production.')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing QA files.')    
    args = parser.parse_args()

    rand = np.random.RandomState(seed=1)

    empca_outfile = os.path.join(templatedir, 'rrtemplate-galaxy.fits')

    # build the parent samples
    if args.match_lss:
        match_lss(specprod=args.specprod, overwrite=args.overwrite)

    if args.parent_qa:
        parent_qa(specprod=args.specprod)

    # build the rest-frame templates
    if args.parent_templates:
        for targtype, nrows in zip(['BGS_ANY', 'LRG', 'ELG'], [10000, 5000, 5000]):
            data = read_clustering(targetclass=targtype, read_lss=True, trim_broad=True)#, rows=np.arange(10))
            fast, meta, lss = data[targtype]['fast'], data[targtype]['meta'], data[targtype]['lss']
            del data
            weight = lss['WEIGHT'] / np.sum(lss['WEIGHT'])
            I = rand.choice(len(meta), size=nrows, p=weight, replace=False)

            outfile = os.path.join(datadir, f'ftemplates-{args.specprod}-{targtype}.fits')            
            restframe_templates(fast[I], meta[I], outfile, minwave=args.minwave,
                                maxwave=args.maxwave, dwave=args.dwave)

    if args.empca_templates:
        import redrock
        from astropy.io import fits
        from empca import empca

        flux = []
        for targtype in ['BGS_ANY', 'LRG', 'ELG']:
            templatefile = os.path.join(datadir, f'ftemplates-{args.specprod}-{targtype}.fits')
            log.info(f'Reading {templatefile}')
            flux.append(fitsio.read(templatefile, 'FLUX'))
        flux = np.vstack(flux) # [ngal, nwave]
        #flux = flux[:100, :]
        ngal = flux.shape[0]

        model = empca(flux, niter=args.niter, nvec=args.ncomp)
        for ii in range(model.coeff.shape[0]):
            model.coeff[ii] /= np.linalg.norm(model.coeff[ii])
        
        empca_eigenvec = model.eigvec  # [ncomp, npix]
        empca_eigencoeff = model.coeff # [ngal, ncomp]
        empca_model = empca_eigencoeff.dot(empca_eigenvec)

        header = fits.Header()
        header['CRVAL1'] = (args.minwave, 'restframe starting wavelength [Angstroms]')
        header['CDELT1'] = args.dwave
        header['RRTYPE']   = 'GALAXY'
        header['RRSUBTYP'] = ''
        header['RRVER'] = redrock.__version__
        header['VERSION'] = ('TBD', 'Template version')
        #header['INSPEC'] = os.environ['DESI_BASIS_TEMPLATES']
        #header['SEED'] = opts.seed
        header['EXTNAME'] = 'BASIS_VECTORS'
        
        hdus = fits.HDUList()
        hdus.append(fits.PrimaryHDU(empca_eigenvec, header=header))
        hdus.append(fits.ImageHDU(empca_eigencoeff, name='ARCHETYPE_COEFF'))
        hdus.writeto(empca_outfile, overwrite=True)
        log.info(f'Wrote {empca_outfile}')


    if args.template_qa:

        # compare the new and old PCA templates        
        hdr = fitsio.read_header(empca_outfile, ext='BASIS_VECTORS')
        ncomp = hdr['NAXIS2']
        wave = np.arange(hdr['NAXIS1']) * hdr['CDELT1'] + hdr['CRVAL1']

        empca_eigenvec = fitsio.read(empca_outfile, ext='BASIS_VECTORS')     # H matrix - [ncomp, npix]
        empca_eigencoeff = fitsio.read(empca_outfile, ext='ARCHETYPE_COEFF') # W matrix - [ngal, ncomp]
        empca_model = empca_eigencoeff.dot(empca_eigenvec) # [ngal, npix]

        pngfile = os.path.join(qadir, 'rrtemplate-galaxy.png')

        #from speclite import filters
        #filt = filters.load_filters('decam2014-g', 'decam2014-r')
        #padflux, padwave = filt.pad_spectrum(nmf_eigenvec, wave, axis=0, method='edge')
        #mags = filt.get_ab_magnitudes(padflux, padwave) # speclite.filters wants an [nmodel,npix] array
        #gr = mags['decam2014-g'] - mags['decam2014-r']
        #srt = np.argsort(gr)

        ylim = np.percentile(empca_eigenvec, [0.1, 99.9])

        fig, ax = plt.subplots()#figsize=(8, 5))
        I = np.arange(len(wave))
        #I = np.where((wave > 3727-20) * (wave < 3727+20))[0]
        #I = np.where(wave < 900.)[0]

        current_palette = sns.color_palette()
        sns.set_palette('rainbow', empca_eigenvec.shape[0])
        colors = iter(sns.color_palette())
    
        # plot in reverse order, so the most important templates are on top
        for ic in range(args.ncomp-1, -1, -1):
        #for ic in range(args.ncomp):
            yplot = empca_eigenvec[ic, I] / np.std(empca_eigenvec[ic, I])
            ax.plot(wave[I], yplot, alpha=0.9, color=next(colors), lw=1)
        #for ii, ic in enumerate(srt):
            #I = np.where(empca_eigenvec[ic, :] > 0)[0]
            #ax.plot(wave[I]/1e4, empca_eigenvec[ic, I] + ii)
        #ax.set_ylim(ylim) # -0.01, 0.01)
        ax.set_ylim(-6, 6)#7.5, 7.5)
        #ax.set_xlim(3727-20, 3727+20)
        #ax.set_yticklabels([])
        ax.set_xlabel(r'Rest-frame Wavelength ($\AA$)')
        ax.set_ylabel(r'$F\ /\ \sigma_{F}$')
        #ax.set_ylabel(r'Normalized Flux (+offsets)')
        ax.margins(x=0)
        #ax.set_xscale('log')
        #ax.xaxis.set_major_formatter(ticker.FuncFormatter(lambda y, _: '{:g}'.format(y)))
        fig.tight_layout()
        fig.savefig(pngfile)
        log.info(f'Wrote {pngfile}')
        sns.set_palette(current_palette)
    
        pdb.set_trace()

        # 4-panel SED figure
        pngfile = os.path.join(qadir, f'ftemplates-{args.specprod}.png')

        current_palette = sns.color_palette()
        sns.set_palette('rainbow')#'Spectral')#'coolwarm')
        #sns.set(context='talk', style='ticks', font_scale=0.6)#, rc=rc)
        nplot = 30

        fig = plt.figure(figsize=(10, 8))
        gs = fig.add_gridspec(nrows=4, ncols=4)#, height_ratios=[1, 0.5])

        def _makeplot(xx, targtype, wavelims=None, xlabel=False, ylabel=False, zoom=False, zoomlabel=None):
            templatefile = os.path.join(datadir, f'ftemplates-{args.specprod}-{targtype}.fits')
            templatewave = fitsio.read(templatefile, 'WAVE')
            if wavelims is not None:
                W = np.where((templatewave > wavelims[0]) * (templatewave < wavelims[1]))[0]
            else:
                W = np.arange(len(templatewave))
            flux = fitsio.read(templatefile, 'FLUX')
            meta = fitsio.read(templatefile, 'METADATA')
            I = rand.choice(len(meta), size=nplot, replace=False)
            ylim = [np.min(templatewave[np.newaxis, :][:, W] * flux[I, :][:, W]),
                    np.max(templatewave[np.newaxis, :][:, W] * flux[I, :][:, W])]
            for igal in I:
                if zoom:
                    xx.plot(templatewave[W], templatewave[W] * flux[igal, W], alpha=0.5, lw=1, color='gray')
                else:
                    xx.plot(templatewave[W], templatewave[W] * flux[igal, W], alpha=0.5, lw=1, color='gray')
            if zoom:
                xx.set_ylim(ylim[0], ylim[1]*1.5)
            else:
                xx.set_ylim(ylim)
            #xx.set_ylim(1, np.max(templatewave[W] * flux[I, :][:, W]))
            xx.set_yscale('log')
            xx.set_yticklabels([])
            xx.margins(x=0)
            if zoom:
                xx.set_xticklabels([])
                if zoomlabel:
                    xx.text(0.05, 0.92, zoomlabel, ha='left', va='top', transform=xx.transAxes, fontsize=10)
            else:
                xx.set_xscale('log')
                if ylabel:
                    xx.set_ylabel(r'Normalized $\lambda F_{\lambda}$')
                if xlabel:
                    xx.set_xlabel(r'Rest-frame Wavelength ($\AA$)')
                    xx.xaxis.set_major_formatter(ticker.FuncFormatter(lambda y, _: '{:g}'.format(y)))
                else:
                    xx.set_xticklabels([])
                xx.text(0.05, 0.95, f'{targtype.replace("_ANY", "")}', ha='left', va='top', transform=xx.transAxes)
                xx.text(0.94, 0.11, r'$\langle z\rangle={:.2f}$'.format(np.median(meta['Z'])), 
                        ha='right', va='center', transform=xx.transAxes)

        xx = fig.add_subplot(gs[:2, :2]) # rows x cols
        _makeplot(xx, 'BGS_ANY', wavelims=None, ylabel=True)
        
        xx = fig.add_subplot(gs[:2, 2:]) # rows x cols
        _makeplot(xx, 'LRG', wavelims=None)
        
        xx = fig.add_subplot(gs[2:, :2]) # rows x cols
        _makeplot(xx, 'ELG', wavelims=None, ylabel=True, xlabel=True)

        xx = fig.add_subplot(gs[2, 2]) # rows x cols
        _makeplot(xx, 'ELG', wavelims=[1215.67-12, 1215.67+12], zoom=True, zoomlabel=r'Ly$\alpha$')

        xx = fig.add_subplot(gs[2, 3]) # rows x cols
        _makeplot(xx, 'ELG', wavelims=[3728.483-12, 3728.483+12], zoom=True, zoomlabel=r'[OII] $\lambda\lambda3726,29$')

        xx = fig.add_subplot(gs[3, 2]) # rows x cols
        _makeplot(xx, 'ELG', wavelims=[5008.238-12, 5008.238+12], zoom=True, zoomlabel=r'[O III] $\lambda5007$')
        
        xx = fig.add_subplot(gs[3, 3]) # rows x cols
        _makeplot(xx, 'ELG', wavelims=[6564.613-12, 6564.613+12], zoom=True, zoomlabel=r'H$\alpha$')
        
        fig.tight_layout()
        fig.savefig(pngfile)
        log.info(f'Wrote {pngfile}')

        sns.set_palette(current_palette)

    if args.run_redrock:
        os.environ['RR_TEMPLATE_DIR'] = templatedir # note!

        # EDR / VI tiles
        vi = read_vi()
        run_redrock(vi, specprod=args.specprod, run_tiles=True, overwrite=args.overwrite) 
        return
                    
        # LAE/LBG VI tiles from Tertiary 26
        vi26 = read_vi_tertiary26()
        run_redrock(vi26, specprod=args.specprod, run_tiles=False, overwrite=args.overwrite)

    if args.redshift_qa:
        from desispec.validredshifts import validate
        
        # merge the EDR redshift-fitting results with the VI results
        merge_zcatfile = os.path.join(templatedir, f'zcat-{args.specprod}.fits')
        if not os.path.isfile(merge_zcatfile) or args.overwrite:
            vi = read_vi()
            vi26 = read_vi_tertiary26()
            
            zcatfiles_tiles = glob(os.path.join(reduxdir, f'zcat-{args.specprod}-[0-9]-?????.fits'))
            zcat_tiles = vstack([Table(fitsio.read(zcatfile)) for zcatfile in zcatfiles_tiles])
            merge_tiles = join(zcat_tiles, vi, keys='TARGETID')

            zcatfiles_healpix = glob(os.path.join(reduxdir, f'zcat-tertiary26-?????.fits'))
            zcat_healpix = vstack([Table(fitsio.read(zcatfile)) for zcatfile in zcatfiles_healpix])
            merge_healpix = join(zcat_healpix, vi26, keys='TARGETID')

            #merge = merge_healpix
            #merge['SUFFIX'] = ''
            merge = vstack((merge_tiles, merge_healpix))
            merge.write(merge_zcatfile, overwrite=True)
            log.info(f'Wrote {len(merge)} objects to {merge_zcatfile}')

        merge_zcatfile_new = os.path.join(templatedir, f'zcat-{args.specprod}-new.fits')
        if not os.path.isfile(merge_zcatfile_new) or args.overwrite:
            vi = read_vi()
            vi26 = read_vi_tertiary26()
            
            zcat_new_tiles = []
            rrfiles_tiles = glob(os.path.join(reduxdir, 'redrock-[0-9]-?????.fits'))
            for rrfile in rrfiles_tiles:
                zcat_new_tiles1 = validate(rrfile, return_target_columns=True,
                                           extra_columns=['TARGETID', 'Z', 'ZWARN', 'COADD_FIBERSTATUS', 'SPECTYPE', 'DELTACHI2'])
                zcat_new_tiles.append(zcat_new_tiles1)
            zcat_new_tiles = vstack(zcat_new_tiles)
            merge_new_tiles = join(zcat_new_tiles, vi, keys='TARGETID')            
            
            zcat_new_healpix = []
            rrfiles_healpix = glob(os.path.join(reduxdir, 'redrock-?????.fits'))
            for rrfile in rrfiles_healpix:
                zcat_new_healpix1 = validate(rrfile, return_target_columns=True,
                                             extra_columns=['TARGETID', 'Z', 'ZWARN', 'COADD_FIBERSTATUS', 'SPECTYPE', 'DELTACHI2'])
                zcat_new_healpix.append(zcat_new_healpix1)
            zcat_new_healpix = vstack(zcat_new_healpix)
            merge_new_healpix = join(zcat_new_healpix, vi26, keys='TARGETID')

            #merge = merge_new_healpix
            #merge['SUFFIX'] = ''

            merge = vstack((merge_new_tiles, merge_new_healpix))
            merge.write(merge_zcatfile_new, overwrite=True)
            log.info(f'Wrote {len(merge)} objects to {merge_zcatfile_new}')

        # read the data
        merge = Table(fitsio.read(merge_zcatfile))
        log.info(f'Read {len(merge)} objects from {merge_zcatfile}')

        merge_new = Table(fitsio.read(merge_zcatfile_new))
        log.info(f'Read {len(merge_new)} objects from {merge_zcatfile_new}')

        def zstats(z, ztrue):
            N = len(z)
            dz = z - ztrue
            Idoom = np.where(C_LIGHT * np.abs(dz) > 1e3)[0]
            #Idoom = np.where((C_LIGHT * np.abs(dz) / (1. + ztrue)) > 1e3)[0]
            txt = [f'N={N}', f'N(|dv|>1000 km/s)={len(Idoom)} ({100*len(Idoom)/N:.1f} %)']
            return N, Idoom, txt

        # make the plots
        zlims = {'BGS': [-0.1, 4.], 'LRG': [-0.1, 4.], 'ELG': [-0.1, 4.], 'QSO': [-0.1, 7.], '': [-0.1, 7.]}
        
        #for targtype in ['']:
        for targtype in ['BGS', 'LRG', 'ELG', 'QSO', '']:
            I = merge['SUFFIX'] == targtype # VI target type
            oo = merge[I]
            nn = merge_new[I]

            if targtype == '': # LAE/LBG
                Qcut = '3'
                Ioo = np.arange(len(oo))
                Inn = np.arange(len(nn))
                zlim = [-0.1, 7.]
            else:
                Qcut = '2.5'
                Ioo = oo[f'GOOD_{targtype.upper()}']
                Inn = nn[f'GOOD_{targtype.upper()}']
                zlim = zlims[targtype]

            #zlim = [-0.1, np.max(np.hstack((oo['VI_Z'][Ioo], oo['Z'][Ioo], nn['VI_Z'][Inn], nn['Z'][Inn])))]

            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(10, 8))

            No, Iodoom, otxt = zstats(oo['Z'][Ioo], oo['VI_Z'][Ioo])
            ax1.scatter(oo['VI_Z'][Ioo], oo['Z'][Ioo], s=25, alpha=0.5, edgecolor='k')
            ax1.text(0.96, 0.06, '\n'.join(otxt), va='bottom', ha='right',
                     transform=ax1.transAxes, fontsize=10)
            ax1.set_ylabel('Redshift [Iron Templates]')

            Nn, Indoom, ntxt = zstats(nn['Z'][Inn], nn['VI_Z'][Inn])
            ax2.scatter(nn['VI_Z'][Inn], nn['Z'][Inn], s=25, alpha=0.5, edgecolor='k')
            ax2.text(0.96, 0.06, '\n'.join(ntxt), va='bottom', ha='right',
                     transform=ax2.transAxes, fontsize=10)
            ax2_twin = ax2.twinx()
            ax2_twin.set_ylabel('Redshift [New PCA Templates]')
            
            ax3.set_xlabel(f'Redshift [VI; Q>{Qcut}]')
            ax4.set_xlabel(f'Redshift [VI; Q>{Qcut}]')

            for xx in [ax1, ax2, ax3, ax4, ax2_twin]:
                xx.set_xlim(zlim)
                xx.set_ylim(zlim)
                xx.plot(zlim, zlim, color='k', lw=1, alpha=0.5, zorder=0)
            
            fig.tight_layout()
            pngfile = os.path.join(qadir, f'vi-redrock-{targtype}.png')

            fig.savefig(pngfile)
            log.info(f'Wrote {pngfile}')

            #pdb.set_trace()

if __name__ == '__main__':
    main()

