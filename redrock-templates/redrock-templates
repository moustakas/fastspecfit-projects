#!/usr/bin/env python

"""Build new Redrock templates.

source /global/cfs/cdirs/desi/software/desi_environment.sh main
module load fastspecfit/main

time $HOME/code/desihub/fastspecfit-projects/redrock-templates/redrock-templates

"""
import os, pdb
import numpy as np
import fitsio
from astropy.table import Table, vstack, join
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

from desitarget import geomask
from desiutil.log import get_logger
log = get_logger()

from fastspecfit.util import C_LIGHT

#sns.set(context='talk', style='ticks', font_scale=0.9)#, rc=rc)

datadir = os.path.join(os.getenv('DESI_ROOT'), 'users', 'ioannis', 'fastspecfit', 'redrock-templates', 'data')

def get_version(specprod):
    ver = {'fuji': 'v3.0', 'guadalupe': 'v3.0', 'iron': 'v2.0'}
    return ver[specprod]    

def get_vacdir(specprod='fuji', version=None):

    if version is None:
        version = get_version(specprod)

    #if 'NERSC_HOST' in os.environ:
    #    vacdir = '/pscratch/sd/i/ioannis/fastspecfit/vac/data/'+specprod+'/catalogs' # to be updated
    #else:
    vacdir = os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'fastspecfit', specprod, version, 'catalogs')
    log.info(f'VAC dir {vacdir}')

    return vacdir


def match_lss(specprod='iron', overwrite=False):
    """Match to the clustering catalogs (full and clustering).

    https://desi.lbl.gov/trac/wiki/keyprojects/y1kp3/Y1details


    """
    from fastspecfit.io import read_fastspecfit
    from fastspecfit.io import write_fastspecfit

    vacdir = get_vacdir(specprod)

    # read the clustering catalogs
    if specprod == 'fuji':
        lssdir = os.path.join(os.getenv('DESI_ROOT'), 'vac', 'edr', 'lss', 'v2.0', 'LSScats')
    elif specprod == 'iron':
        lssdir = os.path.join(os.getenv('DESI_ROOT'), 'vac', 'edr', 'lss', 'v2.0', 'LSScats')
        #lssdir = '/global/cfs/cdirs/desi/survey/catalogs/Y1/LSS/iron/LSScats/v0.6/'
    else:
        raise NotImplemented

    # redshift limits / cuts
    zlims = {'BGS_ANY': [0.01, 0.6], 'LRG': [0.4, 1.1], 'ELG': [0.6, 1.6]}
    
    for targtype in ['BGS_ANY', 'LRG', 'ELG']:
        log.info('##################################################')
        log.info(f'Working on {targtype}')
        if targtype == 'BGS_ANY':
            sv3file = os.path.join(vacdir, f'fastspec-{specprod}-sv3-bright.fits')
            allfast, allmeta, _, _ = read_fastspecfit(sv3file)
        else:
            sv3file = os.path.join(vacdir, f'fastspec-{specprod}-sv3-dark.fits')
            allfast, allmeta, _, _ = read_fastspecfit(sv3file)
        
        for lsstype in ['clustering']:
            log.info('--------------------')
            outfastfile = os.path.join(datadir, f'fastspec-{specprod}-{lsstype}-{targtype}.fits')
            outlssfile = os.path.join(datadir, f'lss-{specprod}-{lsstype}-{targtype}.fits')
    
            if os.path.isfile(outfastfile) and os.path.isfile(outlssfile) and not overwrite:
                log.info(f'fastspecfit file {outfastfile} exists')
                log.info(f'LSS clustering file {outlssfile} exists')
            else:
                if lsstype == 'clustering':
                    lssNfile = os.path.join(lssdir, 'clustering', f'{targtype}_N_clustering.dat.fits')
                    lssSfile = os.path.join(lssdir, 'clustering', f'{targtype}_S_clustering.dat.fits')
                    lssN = fitsio.read(lssNfile)
                    lssS = fitsio.read(lssSfile)
                    alllss = Table(np.concatenate((lssN, lssS)))
                    log.info(f'Read {len(lssN):,d} objects from {lssNfile}')
                    log.info(f'Read {len(lssS):,d} objects from {lssSfile}')
                    log.info(f'  Total number of LSS {targtype}: {len(alllss):,d}')
                    del lssN, lssS
                    
                indx_fast, indx_lss = geomask.match(allfast['TARGETID'], alllss['TARGETID'])
                fast = allfast[indx_fast]
                meta = allmeta[indx_fast]
                lss = alllss[indx_lss]
                assert(np.all(meta['TARGETID'] == lss['TARGETID']))

                ## Any missing objects are going to be because Z_TILE != Z_HP
                ## and Z_HP < 1e-3 but we trimmed those above.
                #miss = alllss[np.delete(np.arange(len(alllss)), indx_lss)]
                #try:
                #    assert(len(miss) == 0)
                #except:
                #    log.warning('Missing the following objects!')
                #    print(miss)

                # apply redshift cuts
                I = (meta['Z'] > zlims[targtype][0]) * (meta['Z'] < zlims[targtype][1])
                log.info(f'Trimming to {np.sum(I):,d} objects with z={zlims[targtype][0]:.2f}-{zlims[targtype][1]:.2f}.')
                fast = fast[I]
                meta = meta[I]
                lss = lss[I]
               
                write_fastspecfit(fast, meta, outfile=outfastfile, verbose=False)

                lss.write(outlssfile, overwrite=True)
                log.info(f'Wrote {len(lss):,d} objects to {outlssfile}')


def read_clustering(targetclass=['BGS_ANY', 'LRG', 'ELG'], specprod='iron',
                    lsstype='clustering', rows=None):
    """Read the matched clustering files (from match_lss).

    """
    from fastspecfit.io import read_fastspecfit

    data = {}
    for targtype in np.atleast_1d(targetclass):
        fastfile = os.path.join(datadir, f'fastspec-{specprod}-{lsstype}-{targtype}.fits')
        if not os.path.isfile(fastfile):
            log.info(f'{fastfile} not found.')
        else:
            fast, meta, _, _ = read_fastspecfit(fastfile, rows=rows)
            lssfile = os.path.join(datadir, f'lss-{specprod}-{lsstype}-{targtype}.fits')
            lss = Table(fitsio.read(lssfile, rows=rows))
            log.info(f'Read {len(lss):,d} objects from {lssfile}')
            data[targtype] = {'fast': fast, 'meta': meta, 'lss': lss}
            
    return data     


def add_bitnames(meta):

    desi_bitnames = np.zeros(len(meta), dtype='U300')
    bgs_bitnames = np.zeros(len(meta), dtype='U300')
    mws_bitnames = np.zeros(len(meta), dtype='U300')
    scnd_bitnames = np.zeros(len(meta), dtype='U300')
    cmx_bitnames = np.zeros(len(meta), dtype='U300')
    targetclass = np.zeros(len(meta), dtype='U300')

    def get_targetclass(targetclass, name):
        for cc in ['BGS', 'LRG', 'ELG', 'QSO', 'MWS', 'SCND', 'STD']:
            if cc in name:
                for iobj, tclass in enumerate(targetclass):
                    if tclass == '':
                        targetclass[iobj] = cc
                    else:
                        if not cc in tclass: # only once
                            targetclass[iobj] = ' '.join([tclass, cc])
        return targetclass
    
    for survey, prefix in zip(['SV3'], ['SV3_']):
    #for survey, prefix in zip(['CMX', 'SV1', 'SV2', 'SV3', 'MAIN'], ['CMX_', 'SV1_', 'SV2_', 'SV3_', '']):
        I = meta['SURVEY'] == survey.lower()
        if np.sum(I) > 0:
            if survey == 'MAIN':
                from desitarget.targetmask import desi_mask, bgs_mask, mws_mask, scnd_mask
            elif survey == 'SV1':
                from desitarget.sv1.sv1_targetmask import desi_mask, bgs_mask, mws_mask, scnd_mask
            elif survey == 'SV2':
                from desitarget.sv2.sv2_targetmask import desi_mask, bgs_mask, mws_mask, scnd_mask
            elif survey == 'SV3':
                from desitarget.sv3.sv3_targetmask import desi_mask, bgs_mask, mws_mask, scnd_mask
            elif survey == 'CMX':
                from desitarget.cmx.cmx_targetmask import cmx_mask

            if survey == 'CMX':
                for name in cmx_mask.names():
                    J = np.where(meta['CMX_TARGET'.format(prefix)] & cmx_mask.mask(name) != 0)[0]
                    if len(J) > 0:
                        cmx_bitnames[J] = [' '.join([bit, name]) for bit in cmx_bitnames[J]]
                        #if 'QSO' in name:
                        #    pdb.set_trace()
                        #print(name, targetclass[J])
                        targetclass[J] = get_targetclass(targetclass[J], name)
            else:
                for name in desi_mask.names():
                    J = np.where(meta['{}DESI_TARGET'.format(prefix)] & desi_mask.mask(name) != 0)[0]
                    if len(J) > 0:
                        desi_bitnames[J] = [' '.join([bit, name]) for bit in desi_bitnames[J]]
                        targetclass[J] = get_targetclass(targetclass[J], name)
                        
                for name in bgs_mask.names():
                    J = np.where(meta['{}BGS_TARGET'.format(prefix)] & bgs_mask.mask(name) != 0)[0]
                    if len(J) > 0:
                        bgs_bitnames[J] = [' '.join([bit, name]) for bit in bgs_bitnames[J]]
                        targetclass[J] = get_targetclass(targetclass[J], name)
                        
                for name in mws_mask.names():
                    J = np.where(meta['{}MWS_TARGET'.format(prefix)] & mws_mask.mask(name) != 0)[0]
                    if len(J) > 0:
                        mws_bitnames[J] = [' '.join([bit, name]) for bit in mws_bitnames[J]]
                        targetclass[J] = get_targetclass(targetclass[J], name)
                        
                for name in scnd_mask.names():
                    J = np.where(meta['{}SCND_TARGET'.format(prefix)] & scnd_mask.mask(name) != 0)[0]
                    if len(J) > 0:
                        scnd_bitnames[J] = [' '.join([bit, name]) for bit in scnd_bitnames[J]]
                        targetclass[J] = get_targetclass(targetclass[J], name)

    meta['DESI_BITNAMES'] = desi_bitnames
    meta['BGS_BITNAMES'] = bgs_bitnames
    meta['MWS_BITNAMES'] = mws_bitnames
    meta['SCND_BITNAMES'] = scnd_bitnames
    meta['CMX_BITNAMES'] = cmx_bitnames
    meta['TARGETCLASS'] = targetclass

def build_emline_model(lineamps, linevshifts, linesigmas, linewaves, 
                       emlinewave, dlog10wave=None, redshift=0.0):

    from fastspecfit.util import trapz_rebin

    if dlog10wave is None:
        dlog10wave = 5. / C_LIGHT / np.log(10) # equivalent to km/s

    # Cut to lines with non-zero amplitudes.
    I = lineamps > 0
    if np.count_nonzero(I) > 0:
        linevshifts = linevshifts[I]
        linesigmas = linesigmas[I]
        lineamps = lineamps[I]
        linewaves = linewaves[I]

        # demand at least 20 km/s for rendering the model
        if np.any(linesigmas) < 20.:
            linesigmas[linesigmas<20.] = 20.

        # line-width [log-10 Angstrom] and redshifted wavelength [log-10 Angstrom]
        log10sigmas = linesigmas / C_LIGHT / np.log(10) 
        linezwaves = np.log10(linewaves * (1.0 + redshift + linevshifts / C_LIGHT))

        log10wave = []
        for linezwave, log10sigma in zip(linezwaves, log10sigmas):
            log10wave.append(np.arange(linezwave - (5 * log10sigma), linezwave + (5 * log10sigma), dlog10wave))
        log10wave = np.hstack([np.log10(np.min(emlinewave)-1), np.log10(np.max(emlinewave)+1), ] + log10wave)
        S = np.argsort(log10wave)
        log10wave = log10wave[S]
        log10model = np.zeros_like(log10wave)
        
        for lineamp, linezwave, log10sigma in zip(lineamps, linezwaves, log10sigmas):
            J = np.abs(log10wave - linezwave) < (5 * log10sigma)
            log10model[J] += lineamp * np.exp(-0.5 * (log10wave[J]-linezwave)**2 / log10sigma**2)

    modelflux = np.hstack(log10model)
    emlinemodel = trapz_rebin(10**log10wave, modelflux, emlinewave)

    return emlinemodel

def read_ftemplates():
    
    from fastspecfit.io import cache_templates

    _ftemplatesdir = os.environ['FTEMPLATES_DIR']
    ftemplatesdir = os.path.join(os.getenv('PSCRATCH'), 'fastspecfit', 'templates')
    log.warning(f'Temporarily hacking FTEMPLATES_DIR to {ftemplatesdir}!')

    os.environ['FTEMPLATES_DIR'] = ftemplatesdir
    templatecache = cache_templates(templateversion='1.1.1', read_linefluxes=True)
    os.environ['FTEMPLATES_DIR'] = _ftemplatesdir

    return templatecache


def restframe_templates(fast, meta, outfile, minwave=100., maxwave=1.1e4):
    """Reconstruct the rest-frame templates.

    """
    from fastspecfit.io import read_fastspecfit, write_fastspecfit, cache_templates, FLUXNORM

    ngal = len(meta)

    templatecache = read_ftemplates()
    nsed = len(templatecache['templateinfo'])

    I = np.where((templatecache['templatewave'] > minwave) * (templatecache['templatewave'] < maxwave))[0]
    templatewave = templatecache['templatewave'][I]
    templateflux = templatecache['templateflux'][I, :]
    templateflux_nolines = templatecache['templateflux_nolines'][I, :]

    J = np.where((templatecache['linewaves'] > minwave) * (templatecache['linewaves'] < maxwave))[0]
    linewaves = templatecache['linewaves'][J]
    linefluxes = templatecache['linefluxes'][J]

    del templatecache

    # reconstruct the continuum-only templates
    continuum = fast['COEFF'].data.dot(templateflux_nolines.T) # note: no line-emission
    templates_lowres = fast['COEFF'].data.dot(templateflux.T) # note: low-res line-emission

    # now generate the individual emission-line spectra but using the measured
    # line-width (if any)
    nominal_sigma = 90. # [km/s]
    nline = len(linewaves)

    linevshifts = np.zeros_like(linewaves) # no velocity shifts
    
    linespectra = np.zeros_like(continuum)
    for igal in range(ngal):
        if igal % 20 == 0:
            log.info(f'Working on galaxy {igal} / {ngal}')
        
        if fast['NARROW_SIGMA'][igal] > 0:
            linesigmas = np.zeros(nline) + fast['NARROW_SIGMA'][igal]
        else:
            linesigmas = np.zeros(nline) + nominal_sigma
        #linesigmas = np.zeros(nline) + 500.

        linezwaves = linewaves * (1. + linevshifts / C_LIGHT)

        #lineamps = C_LIGHT * linefluxes / (np.sqrt(2 * np.pi) * linesigmas[:, np.newaxis] * linewaves[:, np.newaxis])
        emlinemodels = np.zeros_like(templateflux_nolines)
        I = np.where((np.sum(linefluxes, axis=0) > 0) * (fast['COEFF'][igal] > 0))[0]
        if len(I) > 0:
            for imodel in I:
                #print(igal, imodel)
                lineamps = C_LIGHT * linefluxes[:, imodel] / (np.sqrt(2 * np.pi) * linesigmas * linezwaves)
                emlinemodel = build_emline_model(lineamps, linevshifts, linesigmas,
                                                 linewaves, emlinewave=templatewave)
                emlinemodels[:, imodel] = emlinemodel
                #plt.clf()
                #I = np.where((templatewave > 4800.) * (templatewave < 5100.))[0]                
                #plt.plot(templatewave[I], emlinemodel[I])
                #plt.savefig('/global/cfs/cdirs/desi/users/ioannis/tmp2/junk.png')
                #pdb.set_trace()

        if np.max(emlinemodels) > 0:
            linespectra[igal, :] = fast['COEFF'][igal].dot(emlinemodels.T)
        #plt.clf()
        #I = np.where((templatewave > 4800.) * (templatewave < 5100.))[0]                
        #plt.plot(templatewave[I], continuum[igal, I] + linespectra[igal, I])
        #plt.plot(templatewave[I], templates_lowres[igal, I])
        ##plt.plot(templatewave[I], linespectra[igal, I])
        #plt.savefig('/global/cfs/cdirs/desi/users/ioannis/tmp2/junk.png')
        #pdb.set_trace()
    
    templates = continuum + linespectra

    # normalize at 5500 A
    for igal in range(ngal):
        norm = np.interp(5500., templatewave, templates[igal, :])
        templates[igal, :] /= norm
        templates_lowres[igal, :] /= norm
    
    #T = np.where(templatewave < 6e4)[0]
    #fitsio.write(outfile, templates[:, T], clobber=True, extname='FLUX')
    #fitsio.write(outfile, templatewave[T], extname='WAVE')
    #fitsio.write(outfile, meta.as_array(), extname='METADATA')
    #fitsio.write(outfile, fast.as_array(), extname='FASTSPEC')
    #print(f'Wrote {outfile}')

    #igal = 2

    I = np.where((templatewave > 1e3) * (templatewave < 1e4))[0]
    #I = np.where((templatewave > 4800.) * (templatewave < 5100.))[0]
 
    fig, ax = plt.subplots()
    #ax.plot(templatewave[I]/1e4, templates[igal, I], label='Custom')
    #ax.scatter(templatewave[I]/1e4, templates_lowres[igal, I], label='FSPS', alpha=0.5)
    #ax.plot(templatewave[I]/1e4, linespectra[igal, I], label='Custom')
    #ax.plot(templatewave[I]/1e4, continuum[igal, I], label='Custom')
    for igal in range(ngal):
        #ax.plot(templatewave/1e4, templatewave * templates[igal, :], alpha=0.5)
        ax.plot(templatewave[I]/1e4, templates[igal, I], label='Custom', alpha=0.5)
        #ax.plot(templatewave[I]/1e4, templates_lowres[igal, I], label='FSPS', alpha=0.5)
    ax.set_ylabel(r'Normalized $\lambda F_{\lambda}$')
    ax.set_xlabel(r'Rest-frame Wavelength ($\mu$m)')
    ax.set_xscale('log')
    ax.set_yscale('log')
    #ax.set_ylim(1e-8, 1e7)
    ax.xaxis.set_major_formatter(ticker.FuncFormatter(lambda y, _: '{:g}'.format(y)))
    #ax.legend()
    #ax.margins(0)
    fig.tight_layout()
    pngfile = outfile.replace('.fits', '.png')
    fig.savefig(pngfile)
    print(f'Wrote {pngfile}')

def main():
    """Main wrapper."""

    import argparse

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--match-lss', action='store_true', help='Match to the LSS catalogs (no figures, just catalogs).')
    parser.add_argument('--parent-templates', action='store_true', help='Build the parent rest-frame templates.')
    parser.add_argument('--lae-templates', action='store_true', help='LAE/COSMOS sample.')
    parser.add_argument('--nmf-templates', action='store_true', help='Find the NMF basis templates.')
    parser.add_argument('--template-qa', action='store_true', help='Build some QA.')
    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')
    parser.add_argument('--specprod', default='iron', help='Spectroscopic production.')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing QA files.')    
    args = parser.parse_args()

    desi_root = os.getenv('DESI_ROOT')
    outdir = desi_root+'/users/ioannis/fastspecfit/redrock-templates'
    tertiarydir = desi_root+'/users/ioannis/tertiary/tertiary26'

    # build the parent samples
    if args.match_lss:
        match_lss(specprod=args.specprod, overwrite=args.overwrite)

    # build the rest-frame templates
    if args.parent_templates:
        for targtype in ['BGS_ANY', 'LRG', 'ELG']:
            data = read_clustering(targetclass=targtype, rows=np.arange(150))
            fast, meta = data[targtype]['fast'], data[targtype]['meta']
            del data

            outfile = os.path.join(datadir, f'ftemplates-{args.specprod}-{targtype}.fits')            
            restframe_templates(fast, meta, outfile)


    if args.lae_templates:
        # see fastspecfit-projects/tertiary/fastspecfit-tertiary
        fastfile = os.path.join(tertiarydir, 'fastspec-vi-tertiary26.fits')
        fast, meta, _, _ = read_fastspecfit(fastfile)

        # one galaxy has all zero coefficients
        I = np.sum(fast['COEFF'].data, axis=1) > 0

        outfile = outdir+'/fastspec-vi-tertiary26-templates.fits'
        restframe_templates(fast[I], meta[I], outfile)


    #nmf_outfile = outdir+'/rrtemplate-nmf-galaxy.fits'        

    if args.nmf_templates:
        # read the basis templates
        templatewave = fitsio.read(outdir+'/fastspec-vi-tertiary26-templates.fits', 'WAVE')

        templateflux = []
        templateflux.append(fitsio.read(outdir+'/fastspec-vi-tertiary26-templates.fits', 'FLUX'))
        for oneclass in ['BGS', 'ELG', 'LRG']:
            templateflux.append(fitsio.read(outdir+f'/{specprod}-{version}-{oneclass}.fits', 'FLUX'))
        templateflux = np.vstack(templateflux) # [ngal, npix]

        #T = np.where(templatewave < 6e4)[0]
        #templatewave = templatewave[T]
        #templateflux = templateflux[T, :]

        dw = 0.5
        wave = np.arange(550., 1e4, dw)
        npix = len(wave)
        ngal = templateflux.shape[0]

        flux = np.zeros((ngal, npix))
        for igal in range(ngal):
            flux[igal, :] = np.interp(wave, templatewave, templateflux[igal, :])

        ncomp = 10
        g = nmf.NMF(flux, n_components=ncomp) # input matrix should be [ngal, npix]
        chi2, time_used = g.SolveNMF(maxiters=1000, tol=1e-3)
        
        nmf_eigenvec = g.H # [nc, npix]
        nmf_eigencoeff = g.W # [ngal, nc]
        nmf_model = nmf_eigencoeff.dot(nmf_eigenvec) # [ngal, npix]

        header = fits.Header()
        header['CRVAL1'] = (wave[0], 'restframe starting wavelength [Angstroms]')
        header['CDELT1'] = dw
        header['RRTYPE']   = 'GALAXY'
        header['RRSUBTYP'] = ''
        header['RRVER'] = 'ver' # redrock.__version__
        header['VERSION'] = ('TBD', 'Template version')
        #header['INSPEC'] = os.environ['DESI_BASIS_TEMPLATES']
        #header['SEED'] = opts.seed
        header['EXTNAME'] = 'BASIS_VECTORS'
        
        hdus = fits.HDUList()
        hdus.append(fits.PrimaryHDU(nmf_eigenvec, header=header))
        hdus.append(fits.ImageHDU(nmf_eigencoeff, name='ARCHETYPE_COEFF'))
        
        hdus.writeto(nmf_outfile, overwrite=True)
        print(f'Wrote {nmf_outfile}')


    if args.template_qa:
        
        # NMF templates

        hdr = fitsio.read_header(nmf_outfile, ext='BASIS_VECTORS')
        ncomp = hdr['NAXIS2']
        wave = np.arange(hdr['NAXIS1']) * hdr['CDELT1'] + hdr['CRVAL1']

        nmf_eigenvec = fitsio.read(nmf_outfile, ext='BASIS_VECTORS')     # H matrix
        nmf_eigencoeff = fitsio.read(nmf_outfile, ext='ARCHETYPE_COEFF') # W matrix

        nmf_model = nmf_eigencoeff.dot(nmf_eigenvec) # [ngal, npix]

        if False:
            # read the basis templates
            templatewave = fitsio.read(outdir+'/fastspec-vi-tertiary26-templates.fits', 'WAVE')
            templateflux = []
            templateflux.append(fitsio.read(outdir+'/fastspec-vi-tertiary26-templates.fits', 'FLUX'))
            for oneclass in ['BGS', 'ELG', 'LRG']:
                templateflux.append(fitsio.read(outdir+f'/{specprod}-{version}-{oneclass}.fits', 'FLUX'))
            templateflux = np.vstack(templateflux) # [ngal, npix]

            wmin, wmax = 3500, 5500 # 6500, 6600
            I = np.where((wave > wmin) * (wave < wmax))[0]
            J = np.where((templatewave > wmin) * (templatewave < wmax))[0]

            pngfile = outdir+'/rrtemplate-nmf-galaxy-models.png'
            fig, ax = plt.subplots(10, 1, figsize=(6, 20), sharex=True)

            for ii in range(10):
                ax[ii].plot(templatewave[J], templateflux[ii, J], label='Data', lw=2)
                ax[ii].plot(wave[I], nmf_model[ii, I], alpha=0.5, label='NMF')
                ax[ii].legend()
                ax[ii].set_ylim(0, np.max((np.max(nmf_model[ii, I]), np.max(templateflux[ii, J]))))
            fig.tight_layout()
            fig.savefig(pngfile)
            print(f'Wrote {pngfile}')

        pngfile = outdir+'/rrtemplate-nmf-galaxy.png'

        from speclite import filters
        filt = filters.load_filters('decam2014-g', 'decam2014-r')
        padflux, padwave = filt.pad_spectrum(nmf_eigenvec, wave, axis=0, method='edge')
        mags = filt.get_ab_magnitudes(padflux, padwave) # speclite.filters wants an [nmodel,npix] array
        gr = mags['decam2014-g'] - mags['decam2014-r']
        srt = np.argsort(gr)

        fig, ax = plt.subplots()#figsize=(8, 5))
        I = np.where((wave > 0.5) * (wave < 6e4))[0]
        for ii, ic in enumerate(srt):
            #I = np.where(nmf_eigenvec[ic, :] > 0)[0]
            ax.plot(wave[I]/1e4, nmf_eigenvec[ic, I] + ii)
        ax.set_ylim(-1, 15)
        ax.set_xlim(0.1, 1)
        ax.set_yticklabels([])
        ax.set_xlabel(r'Rest-frame Wavelength ($\mu$m)')
        ax.set_ylabel(r'Normalized Flux (+offsets)')
        ax.margins(x=0)
        #ax.set_yscale('log')
        fig.tight_layout()
        fig.savefig(pngfile)
        print(f'Wrote {pngfile}')


        pdb.set_trace()


        # 4-panel SED figure
        templatewave = fitsio.read(outdir+'/fastspec-vi-tertiary26-templates.fits', 'WAVE')

        sns.set(context='talk', style='ticks', font_scale=0.6)#, rc=rc)
        fig, ax = plt.subplots(2, 2, sharex=True, sharey=True)
        for ii, (xx, oneclass) in enumerate(zip(ax.flat, ['BGS', 'LRG', 'ELG', ''])):
            if ii == 3:
                continue
            flux = fitsio.read(outdir+f'/{specprod}-{version}-{oneclass}.fits', 'FLUX')
            meta = fitsio.read(outdir+f'/{specprod}-{version}-{oneclass}.fits', 'METADATA')
            #print(oneclass, np.median(meta['Z']))
            for igal in range(flux.shape[0]):
                xx.plot(templatewave/1e4, templatewave * flux[igal, :], alpha=0.5)
            xx.text(0.1, 0.85, f'{oneclass}', ha='left', va='center', transform=xx.transAxes)
            xx.text(0.92, 0.15, r'$\langle z\rangle={:.2f}$'.format(np.median(meta['Z'])), 
                    ha='right', va='center', transform=xx.transAxes)

            #inset = fig.add_axes([0.66, 0.6, 0.25, 0.27])
            #inset.hist(meta['Z'], density=True, bins=100)
                
        flux = fitsio.read(outdir+'/fastspec-vi-tertiary26-templates.fits', 'FLUX')
        meta = fitsio.read(outdir+'/fastspec-vi-tertiary26-templates.fits', 'METADATA')
        #print('LAE', np.median(meta['Z']))
        for igal in range(flux.shape[0]):
            ax[1, 1].plot(templatewave/1e4, templatewave * flux[igal, :], alpha=0.5)
        xx = ax[1, 1]
        xx.text(0.1, 0.85, 'LAE', ha='left', va='center', transform=xx.transAxes)
        xx.text(0.92, 0.15, r'$\langle z\rangle={:.2f}$'.format(np.median(meta['Z'])), 
                ha='right', va='center', transform=xx.transAxes)
        #inset = fig.add_axes([0.66, 0.6, 0.25, 0.27])
        #inset.hist(meta['Z'], density=True, bins=100)

        for xx in (ax[0, 0], ax[1, 0]):
            xx.set_ylabel(r'Normalized $\lambda F_{\lambda}$')
        for xx in (ax[1, 0], ax[1, 1]):
            xx.set_xlabel(r'Rest-frame Wavelength ($\mu$m)')
        for xx in ax.flat:
            xx.set_xscale('log')
            xx.set_yscale('log')
            xx.set_ylim(1e-8, 1e7)
            xx.xaxis.set_major_formatter(ticker.FuncFormatter(lambda y, _: '{:g}'.format(y)))
            xx.margins(0)
        fig.tight_layout()
        pngfile = outdir+f'/nmf-parent-templates.png'
        fig.savefig(pngfile)
        print(f'Wrote {pngfile}')



if __name__ == '__main__':
    main()

